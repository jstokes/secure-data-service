package org.slc.sli.api.security.oauth;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.PostConstruct;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.security.oauth2.common.ExpiringOAuth2RefreshToken;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.ClientToken;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.TokenStore;

import org.slc.sli.api.config.EntityDefinition;
import org.slc.sli.api.config.EntityDefinitionStore;
import org.slc.sli.api.representation.EntityBody;
import org.slc.sli.api.security.SLIPrincipal;
import org.slc.sli.api.security.resolve.RolesToRightsResolver;
import org.slc.sli.api.service.EntityService;
import org.slc.sli.domain.Entity;
import org.slc.sli.domain.EntityRepository;

/**
 * Responsible for storage and management of access and refresh tokens for OAuth
 * 2.0 implementation.
 * 
 * 
{
  "_id" : UUID [auto-generated by Mongo],
  "user_id" : String,  
  "user_realm" : String,  
  "user_roles" : String,  
  "access_token" : 
  {
    "value" : String,
    "expiration" : Date,
    "token_type" : String,
    "refresh_token" :
    {
      "value" : String,
      "expiration" : Date
    }
  }
}
 * 
 * @author shalka
 */
public class TokenManager implements TokenStore {
    
    @Autowired
    private EntityRepository repo;

    @Autowired
    private EntityDefinitionStore store;

    private EntityService         service;
    
    @Autowired
    private RolesToRightsResolver rolesToRightsResolver;

    @PostConstruct
    public void init() {
        EntityDefinition def = store.lookupByResourceName("authorizedSessions");
        setService(def.getService());
    }
    
    // Injector
    public void setStore(EntityDefinitionStore store) {
        this.store = store;
    }
    
    // Injector
    public void setService(EntityService service) {
        this.service = service;
    }

    //Injector 
    public void setEntityRepository(EntityRepository repo) {
        this.repo = repo;
    }
    
    //Injector 
    public void setRolesToRightsResolver(RolesToRightsResolver r) {
        this.rolesToRightsResolver = r;
    }

    @Override
    public OAuth2Authentication readAuthentication(OAuth2AccessToken token) {
        Iterable<Entity> results = repo.findByQuery("authorizedSessions", new Query(Criteria.where("body.access_token.value").is(token.getValue())), 0, 1);
        for (Entity cur : results) {
            Map<String, Object> body = cur.getBody();
            
            ClientToken clientToken = new ClientToken(((String) body.get("user_id")), null, null, null, 
                    rolesToRightsResolver.resolveRoles((String) body.get("user_realm"), (List<String>) body.get("user_roles")));
            return new OAuth2Authentication(clientToken, null);
        }
        return null;
    }

    @Override
    public OAuth2Authentication readAuthentication(ExpiringOAuth2RefreshToken token) {
        Iterable<Entity> results = repo.findByQuery("authorizedSessions", new Query(Criteria.where("body.access_token.refresh_token.value").is(token.getValue())), 0, 1);
        for (Entity cur : results) {
            Map<String, Object> body = cur.getBody();
            
            ClientToken clientToken = new ClientToken(((String) body.get("user_id")), null, null, null, 
                    rolesToRightsResolver.resolveRoles((String) body.get("user_realm"), (List<String>) body.get("user_roles")));
            return new OAuth2Authentication(clientToken, null);
        }
        return null;
    }

    @Override
    public void storeAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {
        EntityBody container = new EntityBody();
        SLIPrincipal principal = (SLIPrincipal) authentication.getPrincipal();
        container.put("user_id", principal.getId());
        container.put("user_realm", principal.getRealm());
        container.put("user_roles", principal.getRoles());  // ?

        EntityBody accessToken = new EntityBody();
        accessToken.put("value", token.getValue());
        accessToken.put("expiration", token.getExpiration());
        accessToken.put("token_type", token.getTokenType());
        ExpiringOAuth2RefreshToken rt = (ExpiringOAuth2RefreshToken) token.getRefreshToken();
        EntityBody refreshToken = new EntityBody();
        refreshToken.put("value", token.getRefreshToken().getValue());
        refreshToken.put("expiration", rt.getExpiration());
        accessToken.put("refresh_token", refreshToken);
        
        container.put("access_token", accessToken);
        service.create(container);
    }

    @Override
    public OAuth2AccessToken readAccessToken(String tokenValue) {
        OAuth2AccessToken result = new OAuth2AccessToken(tokenValue);
        Iterable<Entity> results = repo.findByQuery("authorizedSessions", 
                new Query(Criteria.where("body.access_token.value").is(tokenValue)), 0, 1);
        for (Entity entity : results) {
            @SuppressWarnings("unchecked")
            Map<String, Object> accessToken = (Map<String, Object>) entity.getBody().get("access_token");
            result.setExpiration((Date) accessToken.get("expiration"));
            result.setTokenType((String) accessToken.get("token_type"));
            
            Map<String, Object> refreshToken = (Map<String, Object>) accessToken.get("refresh_token");
            
            ExpiringOAuth2RefreshToken rt = new ExpiringOAuth2RefreshToken((String) refreshToken.get("value"), 
                    (Date) refreshToken.get("expiration"));
        }
        return result;
    }

    @Override
    public void removeAccessToken(String tokenValue) {
        Iterable<Entity> results = repo.findByQuery("authorizedSessions", 
                new Query(Criteria.where("body.access_token.value").is(tokenValue)), 0, 1);
        for (Entity entity : results) {
            service.delete(entity.getEntityId());
        }
    }

    @Override
    public void storeRefreshToken(ExpiringOAuth2RefreshToken refreshToken, OAuth2Authentication authentication) {
        SLIPrincipal principal = (SLIPrincipal) authentication.getClientAuthentication().getPrincipal();
        Iterable<Entity> results = repo.findByQuery("authorizedSessions", new Query(Criteria.where("body.user_id").is(principal.getId())), 0, 1);
        for (Entity cur : results) {
            Map<String, Object> body = cur.getBody();
            Map<String, Object> rt = new HashMap<String, Object>();
            rt.put("expiration", refreshToken.getExpiration());
            rt.put("value", refreshToken.getValue());
            Map<String, Object> accessToken = (Map<String, Object>) body.get("access_token");
            accessToken.put("refresh_token", rt);
            service.update(cur.getEntityId(), (EntityBody) body);
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public ExpiringOAuth2RefreshToken readRefreshToken(String tokenValue) {
        Iterable<Entity> results = repo.findByQuery("authorizedSessions", new Query(Criteria.where("body.access_token.refresh_token.value").is(tokenValue)), 0, 1);
        for (Entity cur : results) {
            Map<String, Object> accessToken = (Map<String, Object>) cur.getBody().get("access_token");
            Map<String, Object> refreshToken = (Map<String, Object>) accessToken.get("refresh_token");
            Date expirationDate = (Date) refreshToken.get("expiration");
            return new ExpiringOAuth2RefreshToken(tokenValue, expirationDate);
        }
        return null;
    }

    @Override
    public void removeRefreshToken(String tokenValue) {
        Iterable<Entity> results = repo.findByQuery("authorizedSessions", new Query(Criteria.where("body.access_token.refresh_token.value").is(tokenValue)), 0, 1);
        for (Entity cur : results) {
            cur.getBody().remove("refresh_token");
            service.update(cur.getEntityId(), (EntityBody) cur.getBody());
        }
    }

    @Override
    public void removeAccessTokenUsingRefreshToken(String refreshToken) {
        Iterable<Entity> results = repo.findByQuery("authorizedSessions", new Query(Criteria.where("body.access_token.refresh_token.value").is(refreshToken)), 0, 1);
        for (Entity cur : results) {
            service.delete(cur.getEntityId());
        }
    }
}
