require 'mongo'
require 'rbconfig'
require 'json'
require 'socket'
require 'colorize'
require 'nokogiri'
require_relative './test/features/utils/db_client'
require_relative './test/features/utils/rakefile_common'
require_relative './test/features/utils/db_utils'


Dir.glob('suites/*.rake').each { |r| import r }

def convertTenantIdToDbName(tenantId)
  return Digest::SHA1.hexdigest tenantId
end

##parses complexTypes.xsd and returns a hash of {tableName => [list,of,fields]}
##for fields that are pii
def getPiiFields()

  encryptedPiiFields = {}

  f = File.open(COMPLEX_TYPES);
  doc = Nokogiri.XML(f)
  doc.xpath('//xs:complexType').each do |complexType|
    ctName = "#{complexType.attribute('name')}"
    complexType.xpath('xs:sequence/xs:element').each do |element|
      fieldName = "#{element.attribute('name')}"
      piiNode = element.xpath('xs:annotation/xs:appinfo/sli:PersonallyIdentifiableInfo')
      if !piiNode.empty? and piiNode.text =~ /true/
        field = "body.#{fieldName}"
        if encryptedPiiFields[ctName] == nil
          encryptedPiiFields[ctName] = [field]
        else
          encryptedPiiFields[ctName].push(field)
        end
      end
    end
  end
  f.close
  puts "YOUR ENCRYPTED FIELDS ARE: #{encryptedPiiFields.to_s}"
  encryptedPiiFields
end

###################################################
# Section to setup necessary env vars and overrides

DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
SYSTEM_DB_NAME = ENV['SYSTEM_DB_NAME'] ? ENV['DB_NAME'] : "sli"

MONGO_BIN = ENV['MONGO_HOME'] ? ENV['MONGO_HOME']+"/bin/" : ""

ENCRYPT_TOOL_COMMAND = %Q<java -jar ../encryption-tool/target/EncryptionTool.jar ../data-access/dal/keyStore/ciKeyStore.jks ../data-access/dal/keyStore/ciEncryption.properties>

COMPLEX_TYPES = '../domain/src/main/resources/sliXsd/ComplexTypes.xsd'

OTHER_TAGS = ENV['OTHER_TAGS'] ? "--tags "+ENV['OTHER_TAGS'] : ""

TENANT_COLLECTION = [convertTenantIdToDbName("Midgar"), convertTenantIdToDbName("Hyrule"), convertTenantIdToDbName("Security"), convertTenantIdToDbName("Other"), convertTenantIdToDbName("Zork"), convertTenantIdToDbName("SLI"), convertTenantIdToDbName("T1"), convertTenantIdToDbName("T2"), convertTenantIdToDbName("T3"), convertTenantIdToDbName("mreynolds"), convertTenantIdToDbName("chaos_mokey_org"), convertTenantIdToDbName("fakedev_zork_net")]

ENCRYPTED_PII_FIELDS = getPiiFields()
#######################################################

if ENV['HEADLESS'] 
  puts "Headless environment"
  require 'headless'
  headless = Headless.new
  headless.start
end  
  
$SUCCESS=true
$failures = Hash.new

$collectionSet = ["student",
                  "studentSchoolAssociation",
                  "course",
                  "educationOrganization",
                  "section",
                  "studentSectionAssociation",
                  "staff",
                  "staffEducationOrganizationAssociation",
                  "teacherSchoolAssociation",
                  "teacherSectionAssociation",
                  "session",
                  "assessment",
                  "studentAssessment",
                  "gradebookEntry",
                  "courseTranscript",
                  "studentGradebookEntry",
                  "parent",
                  "studentParentAssociation",
                  "attendance",
                  "program",
                  "studentCompetency",
                  "cohort",
                  "courseOffering",
                  "learningObjective",
                  "learningStandard",
                  "gradingPeriod",
                  "staffCohortAssociation",
                  "staffProgramAssociation",
                  "studentCohortAssociation",
                  "studentProgramAssociation",
                  "disciplineAction",
                  "disciplineIncident",
                  "studentDisciplineIncidentAssociation",
                  "graduationPlan",
                  "yearlyTranscript"]


# This method is to run a given test of set of test where a fixture is not needed
# Inputs: (String) testDirPath = path to a directory of tests or a single feature file (starting in acceptance-tests directory)
def runTests(testDirPath)
  @tags ||= ["~@wip", "~@sandbox"]
  sh "cucumber #{testDirPath} --tags #{@tags.join(' --tags ')} #{OTHER_TAGS} -c --strict -f junit --out ./target -f pretty" do |success, exit_code|
    if success
      $failures[testDirPath[testDirPath.rindex('/')+1..-1]] = "Passed"
    else
      $failures[testDirPath[testDirPath.rindex('/')+1..-1]] = "Failed"
      $SUCCESS=false
      raise "Tests Failed" unless (ENV['FAILSLOW'])
    end
  end
end

def system_collection?(collection)
  %w(tenant realm securityEvent application roles tenantJobLock userSession userAccount).include? collection
end


def set_fixture(collection, fixture_name=nil, fixture_path='test/data', drop=true)
  disable_NOTABLESCAN
  db_used = system_collection?(collection) ? 'sli' : DB_NAME
  fixture_name ||= "#{collection}_fixture.json"

  removeCollectionsCleanly(collection) if drop

  sh "#{MONGO_BIN}mongoimport -d #{db_used} -c #{collection} -h #{Property[:db_host]} --file #{fixture_path}/#{fixture_name}" do |success, exit_code|
    raise "Exited with code: #{exit_code.exitstatus}, please confirm that mongo binaries are on your PATH" unless success
  end

  # These fields are encrypted after we import the sandbox data
  # this is a map of tablename -> field name

  #if ENCRYPTED_PII_FIELDS[collection] != nil
  #
  #  puts "ENCRYPTING TABLE #{collection}"
  #
  #  encryptionToolProcess = IO.popen(ENCRYPT_TOOL_COMMAND, "w+")
  #  encryptFields(db_used, collection, ENCRYPTED_PII_FIELDS[collection], encryptionToolProcess)
  #
  #  Process.kill('SIGALRM', encryptionToolProcess.pid)
  #
  #end
end

#encryptes all the fields listed in 'fields' in
#collection 'collection' in the 'db_used' database
def encryptFields(db_used, collection, fields, encryptionToolProcess)

  conn = Mongo::Connection.new(Property[:db_host],Property[:db_port])
  db = conn.db(db_used)
  collection = db.collection(collection)

  collection.find.each { |doc|
    fields.each {|field|

      value = getNestedField(doc, field);

      if value != nil
        value = recursiveEncrypt(value, encryptionToolProcess)
        putNestedField(doc, field, value);
      end

    }
    collection.remove({'_id' => doc['_id']})
    collection.insert(doc)
  }

  conn.close
end

##encrypts a single value or every value in a Hash
def recursiveEncrypt(document, encryptionToolProcess)
  value = document
  if value.is_a?(Hash)
    value.each do |key, val|
       value[key]=recursiveEncrypt(val, encryptionToolProcess)
    end
  elsif value.is_a?(Array)
    value = value.map {|item| recursiveEncrypt(item, encryptionToolProcess)}
  else
    value = encryptField(value, encryptionToolProcess) if value
  end
  value
end

#returns a subdocument of a document
#field names are separated by '.'
def getNestedField(doc, field)
  subdoc = doc
  field.split('.').each { |fieldpart|
    subdoc = subdoc[fieldpart] unless subdoc==nil
  }
  return subdoc;
end

#puts a document into another document
def putNestedField(doc, field, value)
  subdoc = doc
  fieldParts = field.split('.')
  i = 0;
  while i < fieldParts.length - 1 do
    subdoc = subdoc[fieldParts[i]] unless subdoc==nil
    i=i+1;
  end
  subdoc[fieldParts[fieldParts.length-1]] = value unless subdoc==nil
end

#encryptes a field with the encryption-tool
#external process
def encryptField(value, encryptionToolProcess)
  if not value =~ /^ESTRING:(.*)/
    encryptionToolProcess.write("#{value}\n")
    ciphertext = encryptionToolProcess.readline
    ciphertext = "ESTRING:#{ciphertext.strip}"
    return ciphertext
  end

  value
end

def set_fixtures(collections, fixture_path='test/data')
  collections.each do |key, value|
    set_fixture(key,value,fixture_path)
  end
end

def display_failure_report

  $failures.each do |key, value|
    color = (value == 'Passed' ? :green : :red)
    puts "#{key} tests #{value}".colorize(color)
  end

  if $SUCCESS
    puts 'Completed All Tests'
  else
    raise 'Tests have failed'
  end
end

def cleanse_realms
  puts 'Clean up all but the boostrapped realms in mongo'

  query = {'$and' => [
    {'body.uniqueIdentifier' => {'$ne'=>'Shared Learning Collaborative'}},
    {'body.uniqueIdentifier' => {'$ne' => 'Sandbox IDP'}}
  ]}

  DbClient.new.for_sli.open do |db|
    db.remove(:realm, query)
  end
end

def cleanse_apps
  puts 'Clean up all but the boostrapped applications in mongo'
  DbClient.new.for_sli.open do |db|
    db.remove(:application, {'$not' => {'body.bootstrap' => true}}, :safe => true)
  end
end

def cleanse_tenant_collection
  puts 'Clean up test tenants in mongo'
  @conn = Mongo::Connection.new(Property[:db_host],Property[:db_port])
  @db = @conn.db('sli')
  @tenantColl = @db.collection('tenant')

  @tenantColl.find.each do |row|
    if TENANT_COLLECTION.include?(row['body']['tenantId'])
      @tenantColl.remove(row, :safe => true)
    end
    if row['body']['tenantId'].start_with?("devldapuser")
      @tenantColl.remove(row, :safe => true)
    end
  end
end


def cleanseCollectionWithTenantID(collectionName, specificTenants)
  db_used = system_collection?(collectionName) ? 'sli' : DB_NAME
  puts "Removing documents in #{collectionName} with tenantIds #{specificTenants}"
  @conn = Mongo::Connection.new(Property[:db_host],Property[:db_port])
  @db = @conn.db(db_used)
  coll = @db.collection(collectionName)

  #need a few if blocks for apps, app Auth, oauth tokens, realms
  if collectionName == "tenant"
    cleanse_tenant_collection
  else
    coll.remove({}, :safe => true)
  end
end

def removeCollectionsCleanly(collectionName, specificTenants=nil)
  db_used = system_collection?(collectionName) ? 'sli' : DB_NAME

  unless specificTenants
    cleanseCollectionWithTenantID(collectionName, specificTenants)
  else
    sh "#{MONGO_BIN}mongo #{Property[:db_host]}/#{db_used} --quiet --eval \"db.#{collectionName}.remove({}); assert.eq(null, db.getLastError());\""
  end

  sh "#{MONGO_BIN}mongo #{Property[:db_host]}/#{DB_NAME} --quiet --eval \"db.adminCommand('flushRouterConfig'); assert.eq(null, db.getLastError());\""
end

def set_realm_idp_urls
  old_idp_url = 'http://local.slidev.org:8082/simple-idp'
  new_idp_url = Property[:simpleIDP_login_url]

  DbClient.new.for_sli.open do |db|
    db.find(:realm).each do |realm|
      if realm['body']['idp']['id'].start_with?(old_idp_url)
        new_url = realm['body']['idp']['id'].sub(old_idp_url,new_idp_url)
        db.update(:realm,
          {'_id' => realm['_id']},
          {
            '$set' => {
              'body.idp.id' => new_url,
              'body.idp.redirectEndpoint' => new_url
            }
          }
        )
      end
    end
  end
end

############################################################################################################


######################################################################################################
# Rake tasks

task :default => :production

# Task that initializes the realm fixture.  Should only be done once
task :realmInit => :appInit do
  disable_NOTABLESCAN

  #Preserve the bootstrap realm
  cleanse_realms
  set_fixture('realm', nil, 'test/data', false)
  set_realm_idp_urls

  [
    ['anotherfakerealm', 'customRole_anotherfakerealm_fixture.json'],
    ['chaos_mokey_org', 'customRole_chaos_mokey_org_fixture.json'],
    ['developer-email@slidev.org', 'customRole_chaos_mokey_org_fixture.json'],
    ['fakedev_zork_net',  'customRole_fakedev_zork_net_fixture.json'],
    ['sandboxadministrator@slidev.org', 'customRole_sandboxadministrator@slidev.org_fixture.json'],
    ['anothersandboxdeveloper@slidev.org', nil],
    ['Security', 'customRole_Security_fixture.json'],
    ['Zork', 'customRole_Zork_fixture.json'],
    ['Hyrule', 'customRole_Hyrule_fixture.json'],
    ['Midgar', 'customRole_Midgar_fixture.json']
  ].each do |tenant, fixture|
    DB_NAME = DbClient.tenant_to_db_name(tenant)
    set_fixture 'customRole', fixture
    DbUtils.swap_realm_ids tenant
  end

  enable_NOTABLESCAN
end

desc 'Manual Test of Bulk Extract'
task :callBeet do
  prompt = !(ENV['BEET_URL'] && ENV['BEET_TOKEN'] && ENV['BEET_APP'] && ENV['BEET_OUTFILE'])
  puts ENV['BEET_URL']
  puts ENV['BEET_TOKEN']
  puts ENV['BEET_APP']
  puts ENV['BEET_OUTFILE']
  if prompt
    puts "Missing paramaters detected:"
    puts "BEET_URL= Full URL to BulkExtractEndPoint, example https://local.slidev.org:8443/api/rest/bulk/extract/tenant"
    puts "BEET_TOKEN= token of the app/user making the call to the BEEP, example t-1238-61a81be81-1324-e1cb-515cb534a90"
    puts "BEET_APP= client ID of the app making the call, example vavedra9ub"
    puts "BEET_OUTFILE= path to output file"
    return
  end
  testTls(ENV['BEET_URL'], ENV['BEET_TOKEN'], ENV['BEET_APP'], ENV['BEET_OUTFILE'])
end

# Task that initializes the application registration fixture
task :appInit => :displayProperties do
  disable_NOTABLESCAN

  #Preserve the bootstrap apps
  cleanse_apps
  set_fixture 'application', 'application_fixture.json', 'test/data', false

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : 'Midgar')
  DbClient.new(:tenant => 'Midgar').open { |db| db.remove_all(:applicationAuthorization) }
  set_fixture 'applicationAuthorization'
  update_sample_app_urls

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : 'Hyrule')
  set_fixture 'applicationAuthorization', 'applicationAuthorization_Hyrule_fixture.json'

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : 'fakedev_zork_net')
  set_fixture 'applicationAuthorization', 'applicationAuthorization_fakedev_fixture.json'

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : 'chaos_mokey_org')
  set_fixture 'applicationAuthorization', 'applicationAuthorization_chaos_fixture.json'

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : 'Security')
  set_fixture 'applicationAuthorization', 'applicationAuthorization_secured_fixture.json'

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : 'Midgar')
  set_fixture 'userSession', 'oauth_authentication_tokens.json'

  enable_NOTABLESCAN
end

desc 'Approve inBloom apps for ingested realms'
task :addBootstrapAppAuths do
  require_relative 'test/features/utils/rakefile_common.rb'
  require 'securerandom'
  allLeaAllowApp 'inBloom Dashboards'
  allLeaAllowApp 'inBloom Data Browser'
end

task :loadDefaultIngestionTenants do
  #jshort - must fix with some profile swap
  #set_fixture("tenant", "defaultIngestionTenant_fixture.json", "test/data")

  # chung - the code below is a ruby port of tenant bootstrapping by ingestion.
  # It generates time-based shard type 1 uuids and replaces dbName with SHA1 digest.
  private

  def get_default_tenant_docs
    # Read default tenant JSON documents specified in ingestion-core
    tenant_doc_dir = "#{File.dirname(__FILE__)}/../ingestion/ingestion-core/src/main/resources/tenants"
    tenants = []
    Dir.foreach(tenant_doc_dir) do |file|
      next if file == "." or file == ".."
      doc = {
        "type" => "tenant",
        "body" => JSON.parse(IO.read("#{tenant_doc_dir}/#{file}"))
      }
      doc["body"]["landingZone"].each do |lz|
        lz["path"] = lz["path"].gsub(File::SEPARATOR, File::ALT_SEPARATOR || File::SEPARATOR)
      end
      tenants << doc
    end
    tenants
  end

      def replace_placeholders(lzs)
    hostname_placeholder = "<hostname>"
    lzpath_placeholder = "<lzpath>"
    hostname = Socket.gethostname
    # Read parent LZ path from sli.properties if not specified
    if ENV['ingestion_landing_zone']
      parent_lz_path = ENV['ingestion_landing_zone']
    else
      require_relative 'test/features/utils/rakefile_common.rb'
      parent_lz_path = ""
      sli_props_loc = Property['ingestion_properties_file']
      File.readlines(sli_props_loc).each do |line|
        if line.include?("landingzone.inbounddir")
          parent_lz_path = line.split("=")[1].strip
        end
      end
    end
    # Dir.chdir hack to make sure both absolute and relative parent LZ paths are resolved
    current_dir = Dir.getwd
    Dir.chdir("#{File.dirname(__FILE__)}/../ingestion/ingestion-service")
    lzs.each do |lz|
      lz_server = lz["ingestionServer"]
      lz["ingestionServer"].replace(lz_server.gsub(hostname_placeholder, hostname))
      lz_path = lz["path"]
      FileUtils.mkdir_p(parent_lz_path) if !Dir.exists?(parent_lz_path)
      Dir.chdir(parent_lz_path) do
        new_path = Dir.getwd.gsub(File::SEPARATOR, File::ALT_SEPARATOR || File::SEPARATOR)
        if new_path.start_with?("c:")
          new_path = new_path.sub("c:", "C:");
        end
        lz["path"].replace(lz_path.gsub(lzpath_placeholder, new_path))
        Dir.mkdir(lz["path"]) if !Dir.exists?(lz["path"])
      end
    end
    Dir.chdir(current_dir)
  end

  private
  def replace_id_and_dbName(tenant)
    tenant = ShardType1UUIDPKFactory.new.create_pk(tenant)
    tenant["body"]["dbName"].replace(convertTenantIdToDbName(tenant["body"]["dbName"]))
  end

  tenant_col = Mongo::Connection.new(Property[:db_host],Property[:db_port]).db('sli').collection('tenant')
  get_default_tenant_docs.each do |tenant|
    lzs = tenant["body"]["landingZone"]
    replace_placeholders(lzs)
    replace_id_and_dbName(tenant)
    puts "Inserting default tenant: tenantId = #{tenant["body"]["tenantId"]}"
    tenant_col.remove("body.tenantId" => tenant["body"]["tenantId"])
    tenant_col.insert(tenant)
  end
end

# This task will be used for end-to-end integration tests but currently just run all
# available acceptance tests
desc 'Default Task: Run All Acceptances Tests'
task :production => [:apiAndSecurityTests, :ingestionTests, :ingestionOfflineSimpleTest] do
  display_failure_report
end

# This task is used as an entry point to run the smoke tests,
# a suite of tests that will run quickly but only catch 80% or less of real failures
desc 'Run Smoke Tests'
task :smokeTests => [:displayProperties,
                    :apiSmokeTests,
                    :ingestionSmokeTests,
                    :dashboardSmokeTests,
                    :bulkExtractSmokeTests,
                    :adminSmokeTests] do
  display_failure_report
end

desc 'Display all properties'
task :displayProperties do
  puts "Acceptance properties:"
  Property.getProps.each {|k,v| puts "#{k}: #{v}"}
end


# This task is used as an entry point in Jenkins to run API and Security Tests
# It is needed so that it fails the build if there are any failures based on the
# 'raise' exception logic below.  Rake will exit immediately if you raise an exception
# before all the tests complete and will show incomplete results
desc "Run API/Security Acceptances Tests"
task :apiAndSecurityTests => [
                              :apiV1Tests,
                              :apiSuperDocTests,
                              :securityTests,
                              :userAdminCrudTests,
                              :provisioningTests,
                              :onboardingTests,
                              :apiMegaTests,
                              :v1SecurityEventTests] do
# 2014-5-14 TAF : OSI added these but not relevant for Search indexer
#                              :v1SecurityEventTests,
#                              :apiIngestionJobTests,
#                              :runAssmtSearchIndexer ] do

  display_failure_report
end

desc "Run all sandbox tests"
task :sandboxTests => :realmInit do

  @tags = ['~@wip', '@sandbox']

  Rake::Task['importSandboxData'].execute
  runTests('test/features/simple_idp/SimpleIDP.feature')

  Rake::Task['apiSandboxTests'].execute
  Rake::Task['adminToolsTests'].execute

  Rake::Task['importSandboxBulkExtractData'].execute
  runTests('test/features/bulk_extract/features/bulk_extract_sandbox.feature')

  display_failure_report
end

############################################################
# API Sandbox Tests start
############################################################
desc "Run Sandbox API tests"
task :apiSandboxTests do

  @tags = ["~@wip", "@sandbox", "~@rc"]

  data = [
    %w( educationOrganization educationOrganization_fixture_zork.json ),
    %w( staffEducationOrganizationAssociation staffEducationOrganizationAssociation_fixture_zork.json ),
    %w( staff staff_fixture_zork.json ),
    %w( teacherSchoolAssociation teacherSchoolAssociation_fixture_zork.json )
  ]

  # TODO: Fix this god-awful mess of this global DB_NAME constant
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "fakedev_zork_net")
  set_fixtures(data)

  data = [
    %w( educationOrganization educationOrganization_fixture_chaos.json ),
    %w( staffEducationOrganizationAssociation staffEducationOrganizationAssociation_fixture_chaos.json ),
    %w( staff staff_fixture_chaos.json ),
    %w( teacherSchoolAssociation teacherSchoolAssociation_fixture_chaos.json )
  ]

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "chaos_mokey_org")
  set_fixtures(data)

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")

  Rake::Task["securityTests"].invoke
end

############################################################
# API V1 tests start
############################################################
desc "Run API V1 acceptance tests"
task :apiV1Tests => [
                     :apiV1EntityTests,
                     :apiV1EntitySecurityTests,
                     :apiV1DuplicateLinkTest,
                     :apiV1QueryingTests,
                     :apiV1NTSQueryingTests,
                     :apiV1AssociationTests,
                     :apiPatchTests,
                     :v1homeUriTests,
                     :v1ValidationTests,
                     :v1TeacherValidationTests,
                     :v1HierarchyTraversalTests,
                     :v1DirectReferencesTests,
                     :v1DirectReferenceCollectionsTests,
                     :v1NoCascadeDeletionTests,
                     :v1EncryptionTests,
                     :v1SortingAndPagingTests,
                     :v1ListTests,
                     :v1NewEndpointTests,
                     :v1ListAttendanceEndpointTests,
                     :v1TargetTests,
                     :v1EndUserStoryCustomEntityTests,
                     :v1StudentOptionalFieldsTests,
                     :v1SingleStudentViewTests,
                     :v1BlacklistValidationTests,
                     :v1XMLTests,
                     :v1CommaSeparatedListOrderTests,
                     :v1SelectorTests,
                     :longLivedSessionTests,
                     :apiVersionTests,
                     :apiV1GranularAccessTests,
                     :apiV1YearlyTranscriptTests] do
end

task :apiV1EntitySecurityTests do
  # Import the data once, none of these tests edit the data
  Rake::Task["importSandboxData"].execute
  runTests("test/features/apiV1/entities/context_security")
end

desc "Run API Tests using Odin ingested data"
task :apiOdinTests => [:apiOdinFederatedAppsTests, :apiOdinPrep, :apiOdinFederatedAppsTests, :apiOdinSuperAssessment, :apiOdinSecurityTests, :apiOdinMultipleParentTests, :apiV1SearchLimitTests] do
  display_failure_report
end

desc "Run API Security Tests using Odin ingested data"
task :apiOdinSecurityTests => [:apiOdinPrep, :apiOdinStudentLogin, :apiOdinParentLogin] do
  runTests("test/features/apiV1/integration/public_data.feature")
  display_failure_report
end

desc "Prep for running api odin tests"
task :apiOdinPrep => [:apiOdinSecurityGenerate, :apiOdinSecurityIngestion, :apiOdinSetupAPI] do
  display_failure_report
end

############################################################
# API V1 tests end
############################################################

############################################################
# API Selenium tests start
# NOTE: Do not add these tests to the production run yet!
#       While they can be run locally without issues,
#       Firefox cannot start on Jenkins, and will cause
#       all these tests to fail
############################################################
desc "Run API Selenium Tests"
task :apiSeleniumTests => [:adminToolsTests, :databrowserTests] do
  display_failure_report
end

desc "Run Admin-Tools Selenium Tests"
task :adminToolsTests => [
        :provisionIntegrationTests,
        :preloadResourceTests,
        :realmInit,
        :accountApprovalInterfaceTests,
        :accountApprovalTests,
        :onboardingIntegrationTests,
        :sandboxUserAdminTests,
        :samtEmailNotificationTests,
        :adminWebTests] do
  display_failure_report
end

desc "Run Dataprowler Selenium Tests"
task :databrowserTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/databrowser/ssp.feature")
  runTests("test/features/databrowser/databrowser_simple_detail_view.feature")
  runTests("test/features/databrowser/databrowser_selective_deny.feature")
  runTests("test/features/databrowser/critical_auth_bugfix.feature")
  #runTests("test/features/databrowser/student_authentication.feature")
  runTests("test/features/databrowser/databrowser_external_idp_login.feature") unless Property['ci_artifact_idp_type'].nil? || Property['ci_artifact_idp_type'].downcase == 'none'
  runTests("test/features/databrowser/databrowser_breadcrumbtrail.feature")
  runTests("test/features/databrowser/databrowser_homepagecounts.feature")
  runTests("test/features/databrowser/databrowser_homepageEdOrgsTable.feature")
  display_failure_report
end

task :homePageCountTests do
  runTests("test/features/databrowser/databrowser_homepagecounts.feature")
  display_failure_report
end

desc "Run sample breadcrumbtrail tests"
task :breadcrumbTests => [] do
  runTests("test/features/databrowser/databrowser_breadcrumbtrail.feature")
end

desc "Run tests for countOnly URLs"
task :apiCountOnlyTests => [] do
  runTests("test/features/apiV1/countOnly/countOnly.feature")
end

# ingestionJob api calls obtain data about previously run ingestion jobs:
# files processed, records ingested, # errors encountered, etc.
desc "Run tests for ingestion job data"
task :apiIngestionJobTests => [] do
  :turnOnNOTABLESCAN
  runTests("test/features/apiV1/ingestionJob/ingestionJob.feature")
end

desc "Run Device and Agent Tests"
task :deviceTests => :realmInit do
  runTests("test/features/device")
  display_failure_report
end

desc "Run Dashboard Tests"
task :dashboardTests do
  runTests("test/features/dashboard/dash/population_widget.feature")
  runTests("test/features/dashboard/dash/k3view.feature")
  runTests("test/features/dashboard/dash/user_based_views.feature")
  runTests("test/features/dashboard/dash/dashboard_login.feature")
  runTests("test/features/dashboard/dash/student_profile.feature")
  runTests("test/features/dashboard/dash/attendance.feature")
  runTests("test/features/dashboard/dash/contact_info_live.feature")
  runTests("test/features/dashboard/dash/dashboard_html_escape.feature")
  runTests("test/features/dashboard/dash/qunit_tests.feature")
  display_failure_report
end

############################################################
# Dashboard SDS tests start
############################################################
desc 'Run Dashboard Tests against SDS'
task :dashboardSdsTests => [
        #:runSearchBulkExtract
        :dashboardSdsUploadConfigTests,
        :dashboardSdsCoreStudentsTests,
        :dashboardSdsContactInfoTests,
        :dashboardSdsLoginTests,
        :dashboardSdsHSViewTests,
        :dashboardSdsK3ViewTests,
        :dashboardSdsPopWidgetTests,
        :dashboardSdsStudentProfileTests,
        :dashboardSdsUserBasedViewsTests,
        :dashboardSdsAttendanceTests,
        :dashboardStudentSearchTests,
        :dashboardSdsTranscriptPanelTests,
        :dashboardAssessmentTests,
        :dashboardSdsSectionProfileTests,
        :dashboardSdsTeacherProfileTests,
        :dashboardSdsAttendanceCalendarTests,
        :dashboardSdsDashboardBuilderTests] do
  display_failure_report
end
############################################################
# Dashboard SDS tests end
############################################################


############################################################
# Ingestion tests start
############################################################
desc "Run Ingestion Acceptances Tests"
task :ingestionTests => [
        :loadDefaultIngestionTenants, # called multi
        :corruptZip,
        :genericEdOrgs,
        :ingestionBellSchedulesAndClassPeriodsTest,
        :ingestionSectionLevelAttendanceEventsTest,
        :ingestionAttendanceEventCategoriesTest,
        :ingestionDeletionTests,
        :ingestionTenantPurgeTests,
        :ingestionJobFailOnMissingIndexTest,
        :ingestionDbSpinupTest,
        :ingestionDupDetectTest,
        :ingestionInternationalAddressTests,
        :ingestionAcceptanceSdsTest, # called multi
        :ingestionConcurrentTenantTest,
        :ingestionLearningObjectiveTest,
        :ingestionSeoaa,
        :ingestionNegativeTests,
        :ingestionAttendanceTests,
        :ingestionCommonCoreTest,
        :ingestionEncryptionTests,
        :ingestionPropagatedTest,
        :ingestionidNamespaceTest,
        :ingestionSmooksVerificationTests,
        :ingestionXsdValidationTest,
        :ingestionOfflineSimpleTest,
        :ingestionBatchJobTest,
        :ingestionIgnoreIDRefsTest,
        :ingestionTenantTest,
        :ingestionBlacklistValidationTests,
        :ingestionXXETest,
        :ingestionCompetencyLevelDescriptorTest,
        :ingestionDryRunTest,
        :ingestionHealthCheckTest,
        :ingestionSmallSampleDataSet,
        :ingestionMediumSampleDataSet,
        :partialTransformedIngestionTest,
        :partialIngestionTest,
        :ingestionDeltaTest,
        :ingestionPreloading,
        :ingestionJeffCoOnboardingTest,
        :ingestionSuperDocTests,
        :ingestionSubdocTests,
        :ingestionErrorWarnCountTest,
        :ingestionRevertDataTest,
        :ingestionUniqueSectionCodeTest,
        :ingestionSecurityEventTest
  ] do
  display_failure_report
end

############################################################
# Ingestion tests end
############################################################

############################################################
# Odin Data Generation tests start
############################################################
desc "Run Odin Data Generation Acceptances Tests"
task :odinTests do
  runTests("test/features/odin/generate_odin_data_set.feature")
  runTests("test/features/ingestion/features/ingestion_OdinDataSet.feature")
  display_failure_report
end

############################################################
# Odin Data Generation tests end
############################################################

############################################################
# Integration Tests start
############################################################
desc "Run Integration Acceptance Tests"
task :integrationTests => [:realmInit] do
  OTHER_TAGS = OTHER_TAGS+" --tags @integration"
  Rake::Task["loadDefaultIngestionTenants"].invoke
  Rake::Task["ingestionAcceptanceSdsTest"].execute
  Rake::Task["crossAppTests"].execute
  Rake::Task["dashboardSdsTests"].invoke
  display_failure_report
end
############################################################
# Integration Tests end
############################################################

############################################################
# SDK Tests start
############################################################
desc "Run JavaSDK acceptance tests"
task :JavaSDKTests => [:JavaSDKSampleAppTest,:JavaSDKCRUDTest,:JavaRESTCRUDTest] do
  display_failure_report
end
############################################################
# SDK Tests end
############################################################

############################################################
# Onboarding Integration Tests start
############################################################

desc "testing tests"
task :testTest do
  runTests("test/features/databrowser/test.feature")
end

desc "Run Onboarding Integration Tests"
task :onboardingIntegrationTests do
runTests("test/features/sandbox/Integration/onboarding_integration.feature")
  end

desc "Run Provisioning Integration Tests"
task :provisionIntegrationTests do
  runTests("test/features/sandbox/Provision/Provision_Integrated.feature")
end

desc "Run Sandbox Auto Provisioning ingestion test"
task :sandboxAutoIngestTest => [:realmInit] do
  @tags ||= ["~@wip", "@sandbox"]
  @tags << ["@auto-prov-ingest"]
  runTests("test/features/sandbox/Provision/Provision_Integrated.feature")
end

desc "Run API preload resource Tests"
task :preloadResourceTests => [:realmInit] do
@tags ||= ["~@wip", "@sandbox"]
Rake::Task["importSandboxData"].execute
runTests("test/features/sandbox/preload/tenant_preload.feature")
end

############################################################
# Onboarding Integration Tests end
############################################################

############################################################
# Super Admin Management Tools Tests begin
############################################################
desc "Run Super Admin Management Tools Tests"
task :userAdminTests => [:importSandboxData] do
#runTests("test/features/sandbox/UserAdmin/User_Admin_Interface.feature")
runTests("test/features/admintools/SAMT_Account_Management_Interface.feature")
end
task :sandboxUserAdminTests => [:realmInit] do
@tags ||= ["~@wip", "@sandbox"]
Rake::Task["importSandboxData"].execute
runTests("test/features/sandbox/UserAdmin/User_Admin_Interface.feature")
runTests("test/features/sandbox/UserAdmin/TOU_displayed.feature")
end

task :sandboxSamtEmailNotificationTests do
@tags ||= ["~@wip", "@sandbox"]
runTests("test/features/sandbox/UserAdmin/samt_email_notification.feature")
end

task :samtEmailNotificationTests do
@tags ||= ["~@wip", "~@sandbox"]
runTests("test/features/sandbox/UserAdmin/samt_email_notification.feature")
end

desc "Run Admin Welcome Email Production Tests"
task :adminWelcomeEmail do
  @tags ||= ["~@wip", "~@sandbox"]
  runTests("test/features/admintools/Admin_Welcome_Email.feature")
end

###########################################################
# Super Admin Management Tools Tests end
############################################################





############################################################
# User Registration App Tests
############################################################

desc "Run User Registration App Tests"
task :userRegistrationTests => [:userRegistrationProdTests, :userRegistrationSbTests] do
  display_failure_report
end

desc "Run User Registration App Tests - Production"
task :userRegistrationProdTests do
  @tags = ["~@wip", "@production"]
  runTests("test/features/admintools/accountRequest.feature")
end

desc "Run User Registration App Tests - Sandbox"
task :userRegistrationSbTests do
  @tags = ["~@wip", "@sandbox"]
  runTests("test/features/admintools/accountRequest.feature")
end

############################################################
# User Registration App Tests end
############################################################

############################################################
# Api Documentation Setup
############################################################
desc "Run the data setup needed to generate the API Documentation"
task :apiDocumentationSetup => [:realmInit, :ingestionAcceptanceSdsTest] do
  display_failure_report
end
############################################################
# Api Documentation Setup
############################################################

desc "Export Storied Test Data"
task :exportStoriedData do
  Rake::Task["ingestionAcceptanceSdsTest"].execute
  if $SUCCESS
    $collectionSet.each do |collection|
      sh "rm -f test/data/storied_data/Hyrule/sds_#{collection}.json"
      DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
      sh "#{MONGO_BIN}mongoexport -d #{DB_NAME} -c #{collection} -h #{Property[:db_host]} -o test/data/storied_data/Hyrule/sds_#{collection}.json"

      sh "rm -f test/data/storied_data/sds_#{collection}.json"
      DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
      sh "#{MONGO_BIN}mongoexport -d #{DB_NAME} -c #{collection} -h #{Property[:db_host]} -o test/data/storied_data/sds_#{collection}.json"
    end
  else
    puts 'Ingestion Failed! Fixture Data Not Updated! Please fix and re-run'.red
  end

end

desc "Import Storied Data Set"
task :importStoriedData do
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
  hyruleData = $collectionSet.map do |collection|
    [collection, "storied_data/Hyrule/sds_#{collection}.json"]
  end
  set_fixtures(hyruleData)

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  midgarData = $collectionSet.map do |collection|
    [collection, "storied_data/sds_#{collection}.json"]
  end
  set_fixtures(midgarData)
end

desc "Import Secured Data Set"
task :importSecuredData do
  $collectionSet.each do |collection|
    begin
      dropCollectionsCleanly(collection)
    rescue
    end
  end
  secured_data = %w(
    assessment
    attendance
    cohort
    course
    courseTranscript
    educationOrganization
    program
    section
    session
    staff
    staffCohortAssociation
    staffEducationOrganizationAssociation
    staffProgramAssociation
    student
    studentAssessment
    studentCompetency
    studentSchoolAssociation
    studentGradebookEntry
    teacherSchoolAssociation
    parent
    yearlyTranscript
  ).map {|c| [c,"#{c}.json"]}

  tenant = {
    'type' => 'tenant',
    'body' => {
      'tenantId' => 'Security',
      'dbName' => convertTenantIdToDbName('Security')
    },
    'metaData' => {
      'tenantId' => 'Security'
    }
  }

  db = Mongo::Connection.new(Property[:db_host],Property[:db_port])['sli']
  db['tenant'].insert(tenant) if db['tenant'].find_one({"body.tenantId" => "Security"}).nil?
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Security")
  set_fixtures(secured_data, 'test/data/secured')

  other_secured_data = %w(
    educationOrganization
    student
    studentSchoolAssociation
  ).map {|c| [c, "#{c}.json"]}

  tenant = {
    'type' => 'tenant',
    'body' => {
      'tenantId' => 'Other',
      'dbName' => convertTenantIdToDbName('Other')
    },
    'metaData' => {
      'tenantId' => 'Other'
    }
  }

  db = Mongo::Connection.new(Property[:db_host],Property[:db_port])['sli']
  db['tenant'].insert(tenant) if db['tenant'].find_one({"body.tenantId" => "Other"}).nil?
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Other")
  set_fixtures(other_secured_data, 'test/data/secured/Other')

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
end

desc 'Import Sandbox Test Data to Midgar'
task :importSandboxMidgarData do
  midgar_data = %w(
    session
    program
    section
    calendarDate
    course
    student
    parent
    staff
    assessment
    assessmentFamily
    assessmentPeriodDescriptor
    studentAssessment
    attendance
    studentSchoolAssociation
    teacherSchoolAssociation
    educationOrganization
    staffEducationOrganizationAssociation
    schoolSessionAssociation
    courseOffering
    courseTranscript
    studentGradebookEntry
    disciplineIncident
    disciplineAction
    cohort
    staffCohortAssociation
    staffProgramAssociation
    learningStandard
    learningObjective
    studentCompetency
    gradingPeriod
    graduationPlan
    studentCompetencyObjective
    competencyLevelDescriptor
    yearlyTranscript
    classPeriod
  )
  set_fixtures(midgar_data, 'test/data/Midgar_data')
end

desc "Import Sandbox Test Data to Hyrule"
task :importSandboxHyruleData do
  hyrule_data = %w(
    session
    section
    course
    student
    staff
    assessment
    assessmentFamily
    assessmentPeriodDescriptor
    studentSchoolAssociation
    teacherSchoolAssociation
    educationOrganization
    staffEducationOrganizationAssociation
    gradingPeriod
    yearlyTranscript
  )
  set_fixtures(hyrule_data, 'test/data/Hyrule_data')
end

desc "Import Sandbox Test Data"
task :importSandboxData do
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  Rake::Task["importSandboxMidgarData"].execute
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "developer-email@slidev.org")
  Rake::Task["importDevAccountData"].execute
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
  Rake::Task["importSandboxHyruleData"].execute
end

desc "Import ingestion_batch_job data to newBatchJob"
task :importNewBatchJobData do
  DB_NAME = "ingestion_batch_job"
  ingestion_data = %w(
    newBatchJob
  )
  set_fixtures(ingestion_data, 'test/data')
end

desc "Import Migration Test Data to Midgar"
task :importMigrationData do
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  migration_data = %w( 
    session
    program
    section
    course
    student
    parent
    staff
    assessment
    attendance
    studentSchoolAssociation
    teacherSchoolAssociation
    educationOrganization
    staffEducationOrganizationAssociation
    schoolSessionAssociation
    courseOffering
    courseTranscript
    studentGradebookEntry
    disciplineIncident
    disciplineAction
    cohort
    staffCohortAssociation
    staffProgramAssociation
    learningStandard
    learningObjective
    studentCompetency
    gradingPeriod
    graduationPlan
    studentCompetencyObjective
    competencyLevelDescriptor
    yearlyTranscript
  ) 
  set_fixtures(migration_data, 'test/data/migration_data')
end

desc "Import developer email Test Data"
task :importDevAccountData do
  collection, file= 'educationOrganization', 'developer-email_data/educationOrganization_fixture.json'
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "developer-email@slidev.org")
  set_fixture(collection, file)
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "slcdeveloper")
  set_fixture(collection, file)
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
end

desc "Import Sandbox Test Data"
task :importPurgeData do
  purge_data = [
    %w( educationOrganization PurgeFixtureData/educationOrganization_fixture.json ),
    %w( applicationAuthorization PurgeFixtureData/applicationAuthorization_Hyrule_fixture.json ),
    %w( customRole PurgeFixtureData/customRole_Hyrule_fixture.json )
  ]
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
  set_fixtures purge_data
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
end

desc "Import Unified Data Set"
task :importUnifiedData => :realmInit do
  unified_data = %w(
    assessment
    assessmentFamily
    assessmentPeriodDescriptor
    studentAssessment
    attendance
    course
    courseOffering
    educationOrganization
    staffEducationOrganizationAssociation
    parent
    section
    session
    student
    studentSchoolAssociation
    studentGradebookEntry
    courseTranscript
    staff
    teacherSchoolAssociation
  ).map {|c| [c, "unified_data/uds_#{c}.json"]}
  set_fixtures unified_data
end

desc "Import Bulk Extract"
task :importSandboxBulkExtractData => [:realmInit] do
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "developer-email@slidev.org")

  bulk_extract_data = $collectionSet.map {|c| [c, "bulk_extract_data/sds_#{c}.json"]}
  set_fixtures(bulk_extract_data)

  set_fixture('applicationAuthorization', 'applicationAuthorization_developer-email_fixture.json')

  cleanse_apps
  set_fixture('application', 'application_sandbox_BE.json', 'test/data', false)
end

desc 'Run indexing script on databases, no drop'
task :runDbIndexingScript do
  sh "cd #{File.dirname(__FILE__)}/../config/scripts; sh resetAllDbs.sh --nodrop"
end

desc "Turn on notablescan flag"
task :turnOnNOTABLESCAN do
  enable_NOTABLESCAN
end

desc "Turn off notablescan flag"
task :turnOffNOTABLESCAN do
  disable_NOTABLESCAN
end

desc "Help information for this Rakefile"
task :help do
  puts <<-eos
This Rakefile assumes one of two things: an environment variable MONGO_HOME
is set to the home directory of mongo (just before bin) or that the mongo binaries
are on your PATH.

By default, the tests run against the deployed API/application that is running on
localhost:8080 and also assumes a mongo server running on localhost (at default port).

To change this behavior use the following syntax to override:

cmd>rake property=value <rake Task>

Example:

cmd>rake DB_NAME=sli api_server_url=my.API.server.com production

The properties available to override are as follows:

DB_NAME                This property selects which mongo db to set the fixture to (default: sli)
api_server_url         This property selects which running instance of the API to run tests against (default: localhost)
admintools_server_url  This property selects which running instance of the Admin Tools to run tests against (default: localhost)
DEBUG                  This property tells the test code to display debug output in the console
OTHER_TAGS             This property allows you to run tests with debug tags, so pass a tag for this env var ie: @test
FAILSLOW               This property will tell cucumber to continue even if tests fail. Normally it will fail on the first error.
eos

end

#######################################################
# Primary Key Factory Class for Shard Type 1 UUIDs
#######################################################

class ShardType1UUIDPKFactory
  require 'securerandom'
  def create_pk(doc)
    chars = ('a'..'z').to_a
    prefix = Time.new.year.to_s + Array.new(2, '').collect{chars[rand(chars.size)]}.join
    doc['_id'] ||= "#{prefix}-#{SecureRandom.uuid}"
    doc
  end
end

def update_sample_app_urls
  old_url = 'http://local.slidev.org:8081/'
  new_url = Property['sampleApp_server_address']

  conn = Mongo::Connection.new(Property[:db_host],Property[:db_port])
  db = conn.db('sli')

  apps = db['application']

  apps.find.each do |app|
    # reset urls if it points to old sample app url
    set_vals = {}
    set_vals['body.administration_url'] = app['body']['administration_url'].sub(old_url,new_url) if app['body']['administration_url'] && app['body']['administration_url'].start_with?(old_url)
    set_vals['body.application_url']    = app['body']['application_url'].sub(old_url,new_url) if app['body']['application_url'] && app['body']['application_url'].start_with?(old_url)
    set_vals['body.redirect_uri']       = app['body']['redirect_uri'].sub(old_url,new_url) if app['body']['redirect_uri'] && app['body']['redirect_uri'].start_with?(old_url)

    unless set_vals.empty?
      apps.update(
          {'_id' => app['_id']},
          {
              '$set' => set_vals
          }
      )
    end
  end
end

