require 'mongo'
require 'rbconfig'
require 'json'
require 'socket'


Dir.glob('suites/*.rake').each { |r| import r }

def convertTenantIdToDbName(tenantId)
  return Digest::SHA1.hexdigest tenantId
end

###################################################
# Section to setup necessary env vars and overrides

DB_HOST = ENV['DB_HOST'] ? ENV['DB_HOST'] : "localhost"

DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
SYSTEM_DB_NAME = ENV['SYSTEM_DB_NAME'] ? ENV['DB_NAME'] : "sli"

MONGO_BIN = ENV['MONGO_HOME'] ? ENV['MONGO_HOME']+"/bin/" : ""

EXPAND = ENV['CUKE_EXPAND'] ? "--expand" : ""

COLOR = ENV['FORCE_COLOR'] ? "-c" : ""

OTHER_TAGS = ENV['OTHER_TAGS'] ? "--tags "+ENV['OTHER_TAGS'] : ""

TODROP = ENV['TODROP'] ? true : false

CERTAIN_TENANTS = ENV['CERTAIN_TENANTS'] ? true : false

TENANT_COLLECTION = [convertTenantIdToDbName("Midgar"), convertTenantIdToDbName("Hyrule"), convertTenantIdToDbName("Security"), convertTenantIdToDbName("Other"), convertTenantIdToDbName("Zork"), convertTenantIdToDbName("SLI"), convertTenantIdToDbName("T1"), convertTenantIdToDbName("T2"), convertTenantIdToDbName("T3"), convertTenantIdToDbName("mreynolds"), convertTenantIdToDbName("chaos_mokey_org"), convertTenantIdToDbName("fakedev_zork_net")]

IS_WINDOWS = (RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/)

#######################################################

$SUCCESS=true
$failures = Hash.new

$collectionSet = [
	"student",
	"studentSchoolAssociation",
	"course",
	"educationOrganization",
	"section",
	"studentSectionAssociation",
	"staff",
	"staffEducationOrganizationAssociation",
	"teacherSchoolAssociation",
	"teacherSectionAssociation",
	"session",
	"assessment",
	"studentAssessment",
	"gradebookEntry",
	"courseTranscript",
	"studentGradebookEntry",
	"parent",
	"studentParentAssociation",
	"attendance",
	"program",
	"studentAcademicRecord",
	"grade",
	"studentCompetency",
	"reportCard",
	"cohort",
	"courseOffering",
	"learningObjective",
	"learningStandard",
	"gradingPeriod",
	"staffCohortAssociation",
	"staffProgramAssociation",
	"studentCohortAssociation",
	"studentProgramAssociation",
	"disciplineAction",
	"disciplineIncident",
	"studentDisciplineIncidentAssociation",
	"graduationPlan"]

#######################################################################################################
# Helper defs

# This method is to run a given test or set of tests that have a dependency on a fixture being loaded
# Inputs: (String) testDirPath = path to a directory of tests or a single feature file (starting in acceptance-tests directory)
# Inputs: (String) collectionName = name of mongo collection to load fixture data to
# Inputs: (String) fixtureFileName = name of json file in the test/data folder
def runFixtureAndTests(testDirPath, collectionName, fixtureFileName)
  setFixture(collectionName,fixtureFileName) {runTests(testDirPath)}
end

# This method is to run a given test of set of test where a fixture is not needed
# Inputs: (String) testDirPath = path to a directory of tests or a single feature file (starting in acceptance-tests directory)
def runTests(testDirPath)

  if IS_WINDOWS
    @tags ||= ["~@wip", "~@sandbox", "~@not-windows"]
  else
    @tags ||= ["~@wip", "~@sandbox"]
  end

  sh "cucumber #{testDirPath} #{EXPAND} --tags #{@tags.join(' --tags ')} #{OTHER_TAGS} #{COLOR} --strict -f junit --out ./target -f pretty" do |success, exit_code|
    if success
      $failures[testDirPath[testDirPath.rindex('/')+1..-1]] = "Passed"
    else
      $failures[testDirPath[testDirPath.rindex('/')+1..-1]] = "Failed"
      $SUCCESS=false
      raise "Tests Failed" unless (ENV['FAILSLOW'])
    end
  end
end

def isSystemCollection(collectionName)
  if collectionName == "tenant"
    return true
  elsif collectionName == "realm"
    return true
  elsif collectionName == "securityEvent"
    return true
  elsif collectionName == "application"
    return true
  elsif collectionName == "roles"
    return true
  elsif collectionName == "tenantJobLock"
    return true
  elsif collectionName == "userSession"
    return true
  elsif collectionName == "userAccount"
    return true
  else
    return false
  end
end

def setFixture(collectionName,fixtureFileName,fixtureFilePath="test/data",dropExistingCollection=true)
  disable_NOTABLESCAN()

  if isSystemCollection(collectionName)
    db_used = SYSTEM_DB_NAME
  else
    db_used = DB_NAME
  end

  if TODROP
    dropOption = (dropExistingCollection) ? "--drop":""
  else
    if dropExistingCollection
      if CERTAIN_TENANTS
        removeCollectionsCleanly(collectionName, TENANT_COLLECTION)
      else
        removeCollectionsCleanly(collectionName)
      end
      dropOption = ""
    end
  end

  #sh "#{MONGO_BIN}mongo #{DB_HOST}/#{DB_NAME} --quiet --eval \"printjson(db.#{collectionName}.dropIndexes().msg)\""

  sh "#{MONGO_BIN}mongoimport #{dropOption}  -d #{db_used} -c #{collectionName} -h #{DB_HOST} --file #{fixtureFilePath}/#{fixtureFileName}" do |success, exit_code|
    #allow for user to pass block to run the test for each running of setFixture
    if(success && block_given?)
      yield
    else
      puts "Exited with code: #{exit_code.exitstatus}, please confirm that mongo binaries are on your PATH" unless success
    end
  end
end

def addMultipleFixtureFiles(myHash, fixtureFilePath="test/data")
  myHash.each do |key, value|
    setFixture(key,value,fixtureFilePath,false)
  end
end

def setMultipleFixtureFiles(myHash)
  myHash.each do |key, value|
    setFixture(key,value)
  end
end

def displayFailureReport()
  startRed = "\e[31m"
  startGreen = "\e[32m"
  colorReset = "\e[0m"

  $failures.each do |key, value|
    if ENV['FORCE_COLOR']
      puts "#{startRed}#{key} tests #{value}#{colorReset}" if value == "Failed"
      puts "#{startGreen}#{key} tests #{value}#{colorReset}" if value == "Passed"
    else
      puts "#{key} tests #{value}"
    end

  end
end

def cleanseRealms()
  puts 'About to clean up all but the boostrapped realms in mongo'
  @conn = Mongo::Connection.new(DB_HOST)
  @db = @conn.db(SYSTEM_DB_NAME)
  @realmColl = @db.collection('realm')

  @realmColl.find.each do |row|
    if row['body']['uniqueIdentifier'] != 'Shared Learning Collaborative' and row['body']['uniqueIdentifier'] != 'SandboxIDP'
      @realmColl.remove(row)
    end
  end

end

def cleanseApps()
  puts 'About to clean up all but the boostrapped applications in mongo'
  @conn = Mongo::Connection.new(DB_HOST)
  @db = @conn.db(SYSTEM_DB_NAME)
  @appColl = @db.collection('application')

  @appColl.find.each do |row|
    if row['body']['bootstrap'] != true
      @appColl.remove(row, :safe => true)
    end
  end
end

def cleanseTenantCollection()
  puts 'About to clean up test tenants in mongo'
  @conn = Mongo::Connection.new(DB_HOST)
  @db = @conn.db(SYSTEM_DB_NAME)
  @tenantColl = @db.collection('tenant')

  @tenantColl.find.each do |row|
    if TENANT_COLLECTION.include?(row['body']['tenantId'])
      @tenantColl.remove(row, :safe => true)
    end
    if row['body']['tenantId'].start_with?("devldapuser")
      @tenantColl.remove(row, :safe => true)
    end
  end
end


def cleanseCollectionWithTenantID(collectionName, specificTenants)
  if isSystemCollection(collectionName)
    db_used = SYSTEM_DB_NAME
  else
    db_used = DB_NAME
  end

  puts "Removing documents in #{collectionName} with tenantIds #{specificTenants}"
  @conn = Mongo::Connection.new(DB_HOST)
  @db = @conn.db(db_used)
  coll = @db.collection(collectionName)

  #need a few if blocks for apps, app Auth, oauth tokens, realms
  if collectionName == "tenant"
    cleanseTenantCollection
  else
    coll.remove({}, :safe => true)
  end
end

def removeCollectionsCleanly(collectionName, specificTenants=nil)
  if isSystemCollection(collectionName)
    db_used = SYSTEM_DB_NAME
  else
    db_used = DB_NAME
  end

  if specificTenants != nil
    cleanseCollectionWithTenantID(collectionName, specificTenants)
  else
    sh "#{MONGO_BIN}mongo #{DB_HOST}/#{db_used} --quiet --eval \"db.#{collectionName}.remove({}); assert.eq(null, db.getLastError());\""
  end

  sh "#{MONGO_BIN}mongo #{DB_HOST}/#{DB_NAME} --quiet --eval \"db.adminCommand('flushRouterConfig'); assert.eq(null, db.getLastError());\""
#  sh "#{MONGO_BIN}mongo #{DB_HOST}/#{db_used} --quiet --eval \"db.getLastError()\""
end

# The admin realm and sandbox realm IDs are dynamically created during bootstrap,
# so here we swap out references to those realms in long-lived sessions with
# the dynamic ID of the realm.
def swap_realm_ids()
  @conn = Mongo::Connection.new(DB_HOST)
  @db = @conn.db(SYSTEM_DB_NAME)
  @dbTenant = @conn.db(DB_NAME)
  realm_col = @db.collection('realm')
  user_sessions = @db.collection('userSession')
  custom_roles = @dbTenant.collection('customRole')
  to_swap = [
        {"unique_realm_id" => "Shared Learning Collaborative", "placeholder" => "ADMIN_REALM_ID_PLACEHOLDER"},
        {"unique_realm_id" => "Shared Learning Collaborative", "placeholder" => "SANDBOX_REALM_ID_PLACEHOLDER"},
  ]

  to_swap.each do |realm|
    realm_ent = realm_col.find_one({"body.uniqueIdentifier" => realm['unique_realm_id']})

    if realm_ent
      puts "Swapping realm ID for #{realm['unique_realm_id']}"
      realm_id = realm_ent['_id']
      update_count = 0
      user_sessions.find({"body.principal.realm" => realm['placeholder']}).each do |row|
        user_sessions.update({"_id" => row["_id"]}, {"$set" => {"body.principal.realm" => realm_id}})
        update_count = update_count + 1
      end
      puts "\tUpdated #{update_count} user sessions"

      update_count = 0
      custom_roles.find({"body.realmId" => realm['placeholder']}).each do |row|
        custom_roles.update({"_id" => row["_id"]}, {"$set" => {"body.realmId" => realm_id}})
        update_count = update_count + 1
      end
      puts "\tUpdated #{update_count} custom roles."

    else
      puts "Skipping realm ID swap for #{realm['unique_realm_id']}"
    end
  end
end

# The app ids for bootstrapped apps are dynamically generated,
# so here we swap out references to those apps in the app authroization
# wht the dynamic ID of the app.
def swap_app_ids(dbName)
  @conn = Mongo::Connection.new(DB_HOST)
  @db = @conn.db(SYSTEM_DB_NAME)
  @dbTenant = @conn.db(dbName)

  to_swap = [
        {"app_name" => "inBloom Data Browser", "placeholder" => "DATABROWSER_ID_PLACEHOLDER"},
        {"app_name" => "inBloom Dashboards", "placeholder" => "DASHBOARD_ID_PLACEHOLDER"},
  ]
  apps = @db.collection('application')
  app_auths = @dbTenant.collection('applicationAuthorization')

  to_swap.each do |app|
    puts "Swapping IDs for #{app['app_name']}"
    app_ent = apps.find_one({"body.name" => app['app_name']})
    if app_ent
      app_id = app_ent['_id']
      update_count = 0
      app_auths.find("body.appIds" =>  app['placeholder']).each do |row|
        app_ids = row['body']['appIds']
        app_ids[app_ids.index(app['placeholder'])] = app_id
        app_auths.update({"_id" => row["_id"]}, {"$set" => {"body.appIds" => app_ids}})
        update_count = update_count + 1
      end
      puts "\tUpdate #{update_count} entries"
    end
  end
end

############################################################################################################


######################################################################################################
# Rake tasks

task :default => :production

# Task that initializes the realm fixture.  Should only be done once
task :realmInit => [:appInit] do
  disable_NOTABLESCAN()

  #Preserve the bootstrap realm
  cleanseRealms()
  setFixture("realm", "realm_fixture.json", "test/data", false)

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "anotherfakerealm")
  setFixture("customRole", "customRole_anotherfakerealm_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "chaos_mokey_org")
  setFixture("customRole", "customRole_chaos_mokey_org_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "developer-email@slidev.org")
  setFixture("customRole", "customRole_developer-email@slidev.org_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "fakedev_zork_net")
  setFixture("customRole", "customRole_fakedev_zork_net_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "sandboxadministrator@slidev.org")
  setFixture("customRole", "customRole_sandboxadministrator@slidev.org_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "anothersandboxdeveloper@slidev.org")
  setFixture("customRole", "customRole_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Security")
  setFixture("customRole", "customRole_Security_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Zork")
  setFixture("customRole", "customRole_Zork_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
  setFixture("customRole", "customRole_Hyrule_fixture.json", "test/data")
  swap_realm_ids()

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  setFixture("customRole", "customRole_Midgar_fixture.json", "test/data")
  swap_realm_ids()

  enable_NOTABLESCAN()
end

task :appDenialInit do
  setFixture("application", "application_denial_fixture.json")
end

task :realmInitNoPeople => [:realmInit] do
end

# Task that initializes the application registration fixture
task :appInit do
  disable_NOTABLESCAN()
  #Preserve the bootstrap apps
  cleanseApps()
  setFixture("application", "application_fixture.json", "test/data", false)
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  cleanseCollectionWithTenantID("applicationAuthorization", "Midgar")
  setFixture("applicationAuthorization", "applicationAuthorization_fixture.json")
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
  setFixture("applicationAuthorization", "applicationAuthorization_Hyrule_fixture.json")
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "fakedev_zork_net")
  setFixture("applicationAuthorization", "applicationAuthorization_fakedev_fixture.json")
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "chaos_mokey_org")
  setFixture("applicationAuthorization", "applicationAuthorization_chaos_fixture.json")
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Security")
  setFixture("applicationAuthorization", "applicationAuthorization_secured_fixture.json")

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  setFixture("userSession", "oauth_authentication_tokens.json")
  swap_app_ids(convertTenantIdToDbName("Midgar"))
  swap_app_ids(convertTenantIdToDbName("Hyrule"))
  enable_NOTABLESCAN()
end

desc "Approve inBloom apps for ingested realms"
task :addBootstrapAppAuths do
  require_relative 'test/features/utils/rakefile_common.rb'
  require 'securerandom'
  allLeaAllowApp("inBloom Dashboards")
  allLeaAllowApp("inBloom Data Browser")
end

task :loadDefaultIngestionTenants do
  #jshort - must fix with some profile swap
  #setFixture("tenant", "defaultIngestionTenant_fixture.json", "test/data")

  # chung - the code below is a ruby port of tenant bootstrapping by ingestion.
  # It generates time-based shard type 1 uuids and replaces dbName with SHA1 digest.
  private
  def get_default_tenant_docs
    # Read default tenant JSON documents specified in ingestion-core
    tenant_doc_dir = "#{File.dirname(__FILE__)}/../ingestion/ingestion-core/src/main/resources/tenants"
    tenants = []
    Dir.foreach(tenant_doc_dir) do |file|
      next if file == "." or file == ".."
      doc = {
        "type" => "tenant",
        "body" => JSON.parse(IO.read("#{tenant_doc_dir}/#{file}"))
      }
      doc["body"]["landingZone"].each do |lz|
        lz["path"] = lz["path"].gsub(File::SEPARATOR, File::ALT_SEPARATOR || File::SEPARATOR)
      end
      tenants << doc
    end
    tenants
  end

  private
  def replace_placeholders(lzs)
    hostname_placeholder = "<hostname>"
    lzpath_placeholder = "<lzpath>"
    hostname = Socket.gethostname
    # Read parent LZ path from sli.properties if not specified
    if ENV['ingestion_landing_zone']
      parent_lz_path = ENV['ingestion_landing_zone']
    else
      require_relative 'test/features/utils/rakefile_common.rb'
      parent_lz_path = ""
      sli_props_loc = PropLoader.getProps["ingestion_properties_file"]
      File.readlines(sli_props_loc).each do |line|
        if line.include?("landingzone.inbounddir")
          parent_lz_path = line.split("=")[1].strip
        end
      end
    end
    # Dir.chdir hack to make sure both absolute and relative parent LZ paths are resolved
    current_dir = Dir.getwd
    Dir.chdir("#{File.dirname(__FILE__)}/../ingestion/ingestion-service")
    lzs.each do |lz|
      lz_server = lz["ingestionServer"]
      lz["ingestionServer"].replace(lz_server.gsub(hostname_placeholder, hostname))
      lz_path = lz["path"]
      FileUtils.mkdir_p(parent_lz_path) if !Dir.exists?(parent_lz_path)
      Dir.chdir(parent_lz_path) do
        new_path = Dir.getwd.gsub(File::SEPARATOR, File::ALT_SEPARATOR || File::SEPARATOR)
        if new_path.start_with?("c:")
          new_path = new_path.sub("c:", "C:");
        end
        lz["path"].replace(lz_path.gsub(lzpath_placeholder, new_path))
        Dir.mkdir(lz["path"]) if !Dir.exists?(lz["path"])
      end
    end
    Dir.chdir(current_dir)
  end

  private
  def replace_id_and_dbName(tenant)
    tenant = ShardType1UUIDPKFactory.new.create_pk(tenant)
    tenant["body"]["dbName"].replace(convertTenantIdToDbName(tenant["body"]["dbName"]))
  end

  tenant_col = Mongo::Connection.new(DB_HOST).db(SYSTEM_DB_NAME).collection('tenant')
  get_default_tenant_docs.each do |tenant|
    lzs = tenant["body"]["landingZone"]
    replace_placeholders(lzs)
    replace_id_and_dbName(tenant)
    puts "Inserting default tenant: tenantId = #{tenant["body"]["tenantId"]}"
    tenant_col.remove("body.tenantId" => tenant["body"]["tenantId"])
    tenant_col.insert(tenant)
  end
end

# Run a whole series of acceptance and integration tests
desc "Run API, Ingestion, Dashboard, SDK, and SimpleIDP acceptance tests"
task :fullSuite => [
  :production,
  :dashboardTests,
  :ingestionTests,
  :integrationTests,
  :JavaSDKTests,
  :sandboxTests,
  :adminSandboxTests,
  :apiSeleniumTests] do

  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

# This task will be used for end-to-end integration tests but currently just run all
# available acceptance tests
desc "Default Task: Run All Acceptances Tests"
task :production => [:apiAndSecurityTests, :ingestionTests, :ingestionOfflineToolTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

# This task is used as an entry point to run the smoke tests,
# a suite of tests that will run quickly but only catch 80% or less of real failures
desc "Run Smoke Tests"
task :smokeTests => [:apiSmokeTests, :ingestionSmokeTests, :dashboardSmokeTests, :databrowserSmokeTests, :adminSmokeTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end


# This task is used as an entry point in Jenkins to run API and Security Tests
# It is needed so that it fails the build if there are any failures based on the
# 'raise' exception logic below.  Rake will exit immediately if you raise an exception
# before all the tests complete and will show incomplete results
desc "Run API/Security Acceptances Tests"
task :apiAndSecurityTests => [:apiV1Tests, :apiSuperDocTests, :securityTests, :migrationTests, :provisioningTests, :onboardingTests, :apiMegaTests, :v1SecurityEventTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

desc "Run all sandbox tests"
task :sandboxTests => [:realmInit, :simpleIdpSandboxTests, :apiSandboxTests, :adminSandboxTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

############################################################
# API V1 tests start
############################################################
desc "Run API V1 acceptance tests"
task :apiV1Tests => [
	:apiV1EntityTests,
	:apiV1EntitySecurityTests,
	:apiV1DuplicateLinkTest,
	:apiV1QueryingTests,
	:apiV1NTSQueryingTests,
	:apiV1AssociationTests,
	:apiPatchTests,
	:v1homeUriTests,
	:v1ValidationTests,
	:v1TeacherValidationTests,
	:v1WhiteListValidationTests,
	:v1HierarchyTraversalTests,
	:v1DirectReferencesTests,
	:v1DirectReferenceCollectionsTests,
	:v1CascadeDeletionTests,
	:v1EncryptionTests,
	:v1SortingAndPagingTests,
	:v1ListTests,
	:v1NewEndpointTests,
	:v1TargetTests,
	:v1EndUserStoryAssessmentTests,
	:v1EndUserStoryCustomEntityTests,
	:v1StudentOptionalFieldsTests,
	:v1SingleStudentViewTests,
	:v1BlacklistValidationTests,
	:v1XMLTests,
	:userAdminCrudTests,
	:v1CommaSeparatedListOrderTests,
	:v1SelectorTests,
	:longLivedSessionTests,
	:apiVersionTests,
	:apiV1GranularAccessTests] do
  displayFailureReport()
end

task :apiV1EntitySecurityTests do
  # Import the data once, none of these tests edit the data
  Rake::Task["importSandboxData"].execute
  runTests("test/features/apiV1/entities/context_security")
end

desc "Run API Tests using Odin ingested data"
task :apiOdinTests => [:apiOdinGenerate, :apiOdinIngestion, :apiOdinSuperAssessment] do
  displayFailureReport()
    if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

task :apiAssessmentTests => [apiOdinSuperAssessment] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

desc "Run API V1 Super Assessment acceptance tests"
task :apiSuperAssessmentTests => [:apiOdinSuperAssessment] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

############################################################
# API V1 tests end
############################################################

############################################################
# API Selenium tests start
# NOTE: Do not add these tests to the production run yet!
#       While they can be run locally without issues,
#       Firefox cannot start on Jenkins, and will cause
#       all these tests to fail
############################################################
desc "Run API Selenium Tests"
task :apiSeleniumTests => [:adminToolsTests, :databrowserTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

desc "Run Reset and Change Password Selenium Tests"
task :resetAndChangePasswordTests => [:realmInit] do
  runTests("test/features/admintools/reset_change_password.feature")
end

desc "Run Admin-Tools Selenium Tests"
task :adminToolsTests => [
	:provisionIntegrationTests,
	:preloadResourceTests,
	:realmInit,
	:accountApprovalInterfaceTests,
	:accountApprovalTests,
	:onboardingIntegrationTests,
	:resetAndChangePasswordTests,
	:sandboxUserAdminTests,
	:samtEmailNotificationTests,
	:adminWebTests] do
  Rake::Task["importSandboxData"].execute
  Rake::Task["realmInit"].execute
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

desc "Run Dataprowler Selenium Tests"
task :databrowserTests => [:realmInit] do
  Rake::Task["importSandboxData"].execute
  runTests("test/features/databrowser/ssp.feature")
  runTests("test/features/databrowser/databrowser_simple_detail_view.feature")
  runTests("test/features/databrowser/databrowser_selective_deny.feature")
  runTests("test/features/databrowser/critical_auth_bugfix.feature")
  runTests("test/features/databrowser/student_authentication.feature")
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

desc "Run Device and Agent Tests"
task :deviceTests => [:realmInit] do
  runTests("test/features/device")
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

############################################################
# Dashboard tests start
############################################################
desc "Run Dashboard Tests"
task :dashboardTests => [
	:dashboardPopWidgetTests,
	:dashboardK3ViewTests,
	:dashboardHSViewTests,
	:dashboardUserBasedViewTests,
	:dashboardIntegratedTests,
	:dashboardLoginTests,
	:dashboardStudentProfileTests,
	:dashboardAttendance,
	:dashboardStudentHistoricalDataTests,
	:dashboardStudentContactInfoLiveTests,
	:dashboardStudentGradebookEntryTests,
	:dashboardHTMLEscapeTests,
	:dashboardQunitTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end

end
############################################################
# Dashboard tests end
############################################################

############################################################
# Dashboard SDS tests start
############################################################
desc "Run Dashboard Tests against SDS"
task :dashboardSdsTests => [
	:runSearchBulkExtract,
	:dashboardSdsUploadConfigTests,
	:dashboardSdsCoreStudentsTests,
	:dashboardSdsContactInfoTests,
	:dashboardSdsLoginTests,
	:dashboardSdsHSViewTests,
	:dashboardSdsK3ViewTests,
	:dashboardSdsPopWidgetTests,
	:dashboardSdsStudentProfileTests,
	:dashboardSdsUserBasedViewsTests,
	:dashboardSdsAttendanceTests,
	:dashboardStudentSearchTests,
	:dashboardSdsTranscriptPanelTests,
	:dashboardAssessmentTests,
	:dashboardSdsSectionProfileTests,
	:dashboardSdsTeacherProfileTests,
	:dashboardSdsAttendanceCalendarTests,
	:dashboardSdsDashboardBuilderTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end
############################################################
# Dashboard SDS tests end
############################################################


############################################################
# Ingestion tests start
############################################################
desc "Run Ingestion Acceptances Tests"
task :ingestionTests => [
	:loadDefaultIngestionTenants,
	:IngestionIndexValidationTest,
	:ingestionTenantPurgeTests,
	:ingestionJobFailOnMissingIndexTest,
	:ingestionDbSpinupTest,
	:ingestionDupDetectTest,
	:ingestionAcceptanceSdsTest,
	:ingestionConcurrentTenantTest,
	:ingestionLearningObjectiveTest,
	:ingestionNegativeTests,
	:ingestionAttendanceTests,
	:ingestionCommonCoreTest,
	:ingestionEncryptionTests,
	:ingestionPropagatedTest,
	:ingestionidNamespaceTest,
	:ingestionSmooksVerificationTests,
	:ingestionXsdValidationTest,
	:ingestionOfflineSimpleTest,
	:ingestionBatchJobTest,
	:ingestionIgnoreIDRefsTest,
	:ingestionIndexTest,
	:ingestionTenantTest,
	:ingestionBlacklistValidationTests,
	:ingestionXXETest,
	:ingestionCompetencyLevelDescriptorTest,
	:ingestionDryRunTest,
	:ingestionComplexObjectArrayIdRefTest,
	:ingestionHealthCheckTest,
	:ingestionSmallSampleDataSet,
	:ingestionMediumSampleDataSet,
	:partialTransformedIngestionTest,
	:partialIngestionTest,
	:ingestionDeltaTest,
	:ingestionPreloading,
	:ingestionJeffCoOnboardingTest,
	:ingestionSuperDocTests,
	:ingestionSubdocTests,
	:ingestionErrorWarnCountTest,
	:ingestionRevertDataTest,
	:ingestionUniqueSectionCodeTest,
	:ingestionSecurityEventTest
  ] do

  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end


desc "Run High Priority Emma Ingestion Acceptances Tests"
    #New or tests modified this sprint, or tests that have recently failed
    task :highPriority => [
    	:loadDefaultIngestionTenants,
    	:ingestionPreloading,
    	:ingestionDeltaTest] do
end

desc "Run Normal Priority Emma Ingestion Acceptances Tests"
    task :normalPriority => [
    	:loadDefaultIngestionTenants,
    	:IngestionIndexValidationTest,
    	:ingestionDbSpinupTest,
    	:ingestionAcceptanceSdsTest,
    	:ingestionConcurrentTenantTest,
    	:ingestionLearningObjectiveTest,
    	:ingestionNegativeTests,
    	:ingestionAttendanceTests,
    	:ingestionCommonCoreTest,
    	:ingestionEncryptionTests,
        :ingestionidNamespaceTest,
        :ingestionSmooksVerificationTests,
        :ingestionXsdValidationTest,
        :ingestionBatchJobTest,
        :ingestionIgnoreIDRefsTest,
        :ingestionTenantPurgeTests,
        :ingestionIndexTest,
        :ingestionTenantTest,
        :ingestionBlacklistValidationTests,
        :ingestionXXETest,
        :ingestionCompetencyLevelDescriptorTest,
        :ingestionDryRunTest,
        :ingestionComplexObjectArrayIdRefTest,
        :ingestionHealthCheckTest,
        :ingestionSmallSampleDataSet,
        :ingestionMediumSampleDataSet,
        :partialTransformedIngestionTest,
        :partialIngestionTest,
        :ingestionJeffCoOnboardingTest,
        :ingestionSuperDocTests,
        :ingestionSubdocTests,
        :ingestionErrorWarnCountTest,
        :ingestionRevertDataTest,
        :ingestionUniqueSectionCodeTest,
        :ingestionDupDetectTest] do
end

desc "Run Emma Ingestion Acceptances Tests"
    task :ingestionEmmaTests => [:highPriority, :normalPriority] do

    displayFailureReport()
        if $SUCCESS
        puts "Completed All Tests"
    else
        raise "Tests have failed"
  end
end
############################################################
# Ingestion tests end
############################################################

############################################################
# Odin Data Generation tests start
############################################################
desc "Run Ingestion Acceptances Tests"
task :odinTests => [:odinGenerateTests, :ingestOdinDataSet] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

desc "Run Odin Jmeter generate and ingest for use with Jmeter API Performance Tests"
task :jmeterOdinTests => [:generateOdinJmeterDataSet, :ingestOdinJmeterDataSet] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end
############################################################
# Odin Data Generation tests end
############################################################

############################################################
# List Attendance Endpoint tests start
############################################################
desc "Run List Attendance Endpoint tests"
task :listAttendanceEndPoint => [
	:loadDefaultIngestionTenants,
	:odin10k1GenerateTests,
	:ingestOdin10k1DataSet,
	:realmInit,
	:v1ListAttendanceEndpointTests] do

  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end
############################################################
# List Attendance Endpoint tests end
############################################################

############################################################
# Integration Tests start
############################################################
desc "Run Integration Acceptance Tests"
task :integrationTests => [:realmInitNoPeople] do
  OTHER_TAGS = OTHER_TAGS+" --tags @integration"
  Rake::Task["loadDefaultIngestionTenants"].invoke
  Rake::Task["ingestionAcceptanceSdsTest"].execute
  Rake::Task["crossAppTests"].execute
  Rake::Task["searchApiTests"].invoke
  Rake::Task["dashboardSdsTests"].invoke
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end
############################################################
# Integration Tests end
############################################################

############################################################
# SDK Tests start
############################################################
desc "Run JavaSDK acceptance tests"
task :JavaSDKTests => [:JavaSDKSampleAppTest,:JavaSDKCRUDTest,:JavaRESTCRUDTest] do
    displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end
############################################################
# SDK Tests end
############################################################

############################################################
# Onboarding Integration Tests start
############################################################


desc "Run Onboarding Integration Tests"
task :onboardingIntegrationTests do
runTests("test/features/sandbox/Integration/onboarding_integration.feature")
  end

desc "Run Provisioning Integration Tests"
task :provisionIntegrationTests do
  runTests("test/features/sandbox/Provision/Provision_Integrated.feature")
end

desc "Run Sandbox Auto Provisioning ingestion test"
task :sandboxAutoIngestTest => [:realmInit] do
  @tags ||= ["~@wip", "@sandbox"]
  @tags << ["@auto-prov-ingest"]
  runTests("test/features/sandbox/Provision/Provision_Integrated.feature")
end

desc "Run API preload resource Tests"
task :preloadResourceTests => [:realmInit] do
@tags ||= ["~@wip", "@sandbox"]
Rake::Task["importSandboxData"].execute
runTests("test/features/sandbox/preload/tenant_preload.feature")
end

############################################################
# Onboarding Integration Tests end
############################################################

############################################################
# Super Admin Management Tools Tests begin
############################################################
desc "Run Super Admin Management Tools Tests"
task :userAdminTests => [:importSandboxData] do
#runTests("test/features/sandbox/UserAdmin/User_Admin_Interface.feature")
runTests("test/features/admintools/SAMT_Account_Management_Interface.feature")
end
task :sandboxUserAdminTests => [:realmInit] do
@tags ||= ["~@wip", "@sandbox"]
Rake::Task["importSandboxData"].execute
runTests("test/features/sandbox/UserAdmin/User_Admin_Interface.feature")
runTests("test/features/sandbox/UserAdmin/TOU_displayed.feature")
end

task :sandboxSamtEmailNotificationTests do
@tags ||= ["~@wip", "@sandbox"]
runTests("test/features/sandbox/UserAdmin/samt_email_notification.feature")
end

task :samtEmailNotificationTests do
@tags ||= ["~@wip", "~@sandbox"]
runTests("test/features/sandbox/UserAdmin/samt_email_notification.feature")
end

desc "Run Admin Welcome Email Production Tests"
task :adminWelcomeEmail do
  @tags ||= ["~@wip", "~@sandbox"]
  runTests("test/features/admintools/Admin_Welcome_Email.feature")
end

###########################################################
# Super Admin Management Tools Tests end
############################################################





############################################################
# User Registration App Tests
############################################################

desc "Run User Registration App Tests"
task :userRegistrationTests => [:userRegistrationProdTests, :userRegistrationSbTests] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end

desc "Run User Registration App Tests - Production"
task :userRegistrationProdTests do
  @tags = ["~@wip", "@production"]
  runTests("test/features/admintools/accountRequest.feature")
end

desc "Run User Registration App Tests - Sandbox"
task :userRegistrationSbTests do
  @tags = ["~@wip", "@sandbox"]
  runTests("test/features/admintools/accountRequest.feature")
end

############################################################
# User Registration App Tests end
############################################################

############################################################
# SIF tests start
############################################################
desc "Run SIF Tests"
task :sifTests => [
	:sifSchoolInfoTest,
	:sifLEAInfoTest,
	:sifStudentSchoolEnrollmentTest,
	:sifStudentLEARelationshipTest,
	:sifStaffPersonalTest,
	:sifEmployeePersonalTest,
	:sifEmploymentRecordTest,
	:sifStaffAssignmentTest,
	:sifSmokeTests,
	:sifIntegratedTest,
	:sifEmployeeAssignmentTest
	] do
  displayFailureReport()
  if $SUCCESS
    puts "Completed All Tests"
  else
    raise "Tests have failed"
  end
end
############################################################
# SIF tests end
############################################################


desc "Export Storied Test Data"
task :exportStoriedData do
  Rake::Task["ingestionAcceptanceSdsTest"].execute
  if $SUCCESS
    $collectionSet.each do |collection|
      sh "rm -f test/data/storied_data/Hyrule/sds_#{collection}.json"
      DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
      sh "#{MONGO_BIN}mongoexport -d #{DB_NAME} -c #{collection} -h #{DB_HOST} -o test/data/storied_data/Hyrule/sds_#{collection}.json"

      sh "rm -f test/data/storied_data/sds_#{collection}.json"
      DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
      sh "#{MONGO_BIN}mongoexport -d #{DB_NAME} -c #{collection} -h #{DB_HOST} -o test/data/storied_data/sds_#{collection}.json"
    end
  else
    if ENV['FORCE_COLOR']
      puts "\e[31m Ingestion Failed! Fixture Data Not Updated! Please fix and re-run \e[0m"
    else
      puts "Ingestion Failed! Fixture Data Not Updated! Please fix and re-run"
    end
  end

end

desc "Import Storied Data Set"
task :importStoriedData do
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
  hyruleHash = Hash[]
  $collectionSet.each do |collection|
    hyruleHash["#{collection}"] = "storied_data/Hyrule/sds_#{collection}.json"
  end
  setMultipleFixtureFiles(hyruleHash)

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  testHash = Hash[]
  $collectionSet.each do |collection|
    testHash["#{collection}"] = "storied_data/sds_#{collection}.json"
  end
  setMultipleFixtureFiles(testHash)

  if TODROP
    Rake::Task["runDbIndexingScript"].execute
  end
end

desc "Import Secured Data Set"
task :importSecuredData do
  $collectionSet.each do |collection|
    begin
      dropCollectionsCleanly(collection)
    rescue
    end
  end
  testHash = Hash[
    "assessment" => "secured/assessment.json",
    "attendance" => "secured/attendance.json",
    "cohort" => "secured/cohort.json",
    "course" => "secured/course.json",
    "courseTranscript" => "secured/courseTranscript.json",
    "grade" => "secured/grade.json",
    "educationOrganization" => "secured/educationOrganization.json",
    "program" => "secured/program.json",
    "reportCard" => "secured/reportCard.json",
    "section" => "secured/section.json",
    "session" => "secured/session.json",
    "staff" => "secured/staff.json",
    "staffCohortAssociation" => "secured/staffCohortAssociation.json",
    "staffEducationOrganizationAssociation" => "secured/staffEducationOrganizationAssociation.json",
    "staffProgramAssociation" => "secured/staffProgramAssociation.json",
    "student" => "secured/student.json",
    "studentAssessment" => "secured/studentAssessment.json",
    "studentCompetency" => "secured/studentCompetency.json",
    "studentAcademicRecord" => "secured/studentAcademicRecord.json",
    "studentSchoolAssociation" => "secured/studentSchoolAssociation.json",
    "studentGradebookEntry" => "secured/studentGradebookEntry.json",
    "teacherSchoolAssociation" => "secured/teacherSchoolAssociation.json",
    "parent" => "secured/parent.json",
  ]

   tenant = {
    "type" => "tenant",
    "body" => {
      "tenantId" => "Security",
      "dbName" => convertTenantIdToDbName("Security")
      },
    "metaData" => {
        "tenantId" => "Security"
      }
  }

  db = Mongo::Connection.new(DB_HOST)['sli']
  db['tenant'].insert(tenant) if db['tenant'].find_one({"body.tenantId" => "Security"}).nil?
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Security")
  setMultipleFixtureFiles(testHash)

  testHash = Hash[
    "educationOrganization" => "secured/Other/educationOrganization.json",
    "student" => "secured/Other/student.json",
    "studentSchoolAssociation" => "secured/Other/studentSchoolAssociation.json"
  ]

     tenant = {
    "type" => "tenant",
    "body" => {
      "tenantId" => "Other",
      "dbName" => convertTenantIdToDbName("Other")
      },
    "metaData" => {
        "tenantId" => "Other"
      }
  }

  db = Mongo::Connection.new(DB_HOST)['sli']
  db['tenant'].insert(tenant) if db['tenant'].find_one({"body.tenantId" => "Other"}).nil?
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Other")
  setMultipleFixtureFiles(testHash)

  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")

  if TODROP
    Rake::Task["runDbIndexingScript"].execute
  end
end

desc "Import Sandbox Test Data to Midgar"
task :importSandboxMidgarData do
  testHash = Hash[
    "session" => "Midgar_data/session_fixture.json",
    "program" => "Midgar_data/program_fixture.json",
    "section" => "Midgar_data/section_fixture.json",
    "course" => "Midgar_data/course_fixture.json",
    "student" => "Midgar_data/student_fixture.json",
    "parent" => "Midgar_data/parent_fixture.json",
    "staff" => "Midgar_data/staff_fixture.json",
    "assessment" => "Midgar_data/assessment_fixture.json",
    "assessmentFamily" => "Midgar_data/assessmentFamily_fixture.json",
    "assessmentPeriodDescriptor" => "Midgar_data/assessmentPeriodDescriptor_fixture.json",
    "studentAssessment" => "Midgar_data/studentAssessment_fixture.json",
    "attendance" => "Midgar_data/attendance_fixture.json",
    "studentSchoolAssociation" => "Midgar_data/studentSchoolAssociation_fixture.json",
    "teacherSchoolAssociation" => "Midgar_data/teacherSchoolAssociation_fixture.json",
    "educationOrganization" => "Midgar_data/educationOrganization_fixture.json",
    "aggregationDefinition" => "Midgar_data/aggregationdefinition_fixture.json",
    "staffEducationOrganizationAssociation" => "Midgar_data/staffEducationOrganizationAssociation_fixture.json",
    "schoolSessionAssociation" => "Midgar_data/schoolSessionAssociation_fixture.json",
    "courseOffering" => "Midgar_data/sessionCourseAssociation_fixture.json",
    "courseTranscript" => "Midgar_data/courseTranscript_fixture.json",
    "studentGradebookEntry" => "Midgar_data/studentGradebookEntry_fixture.json",
    "disciplineIncident" => "Midgar_data/disciplineIncident_fixture.json",
    # "studentDisciplineIncidentAssociation" => "Midgar_data/studentDisciplineIncidentAssociation_fixture.json",
    "disciplineAction" => "Midgar_data/disciplineAction_fixture.json",
    "cohort" => "Midgar_data/cohort_fixture.json",
    "staffCohortAssociation" => "Midgar_data/staffCohortAssociation_fixture.json",
    "staffProgramAssociation" => "Midgar_data/staffProgramAssociation_fixture.json",
    "studentAcademicRecord" => "Midgar_data/studentAcademicRecord_fixture.json",
    "learningStandard" => "Midgar_data/learningStandard_fixture.json",
    "learningObjective" => "Midgar_data/learningObjective_fixture.json",
    "grade" => "Midgar_data/grade_fixture.json",
    "studentCompetency" => "Midgar_data/studentCompetency_fixture.json",
    "gradingPeriod" => "Midgar_data/gradingPeriod_fixture.json",
    "adminDelegation" => "Midgar_data/adminDelegation_fixture.json",
    "reportCard" => "Midgar_data/reportCard_fixture.json",
    "graduationPlan" => "Midgar_data/graduationPlan_fixture.json",
    "studentCompetencyObjective" => "Midgar_data/studentCompetencyObjective_fixture.json",
    "competencyLevelDescriptor" => "Midgar_data/competencyLevelDescriptor_fixture.json"
  ]
  setMultipleFixtureFiles(testHash)
end


desc "Import Sandbox Test Data to Hyrule"
task :importSandboxHyruleData do
  testHash = Hash[
    "session" => "Hyrule_data/session_fixture.json",
    "section" => "Hyrule_data/section_fixture.json",
    "course" => "Hyrule_data/course_fixture.json",
    "student" => "Hyrule_data/student_fixture.json",
    "staff" => "Hyrule_data/staff_fixture.json",
    "assessment" => "Hyrule_data/assessment_fixture.json",
    "assessmentFamily" => "Hyrule_data/assessmentFamily_fixture.json",
    "assessmentPeriodDescriptor" => "Hyrule_data/assessmentPeriodDescriptor_fixture.json",
    "studentSchoolAssociation" => "Hyrule_data/studentSchoolAssociation_fixture.json",
    "teacherSchoolAssociation" => "Hyrule_data/teacherSchoolAssociation_fixture.json",
    "educationOrganization" => "Hyrule_data/educationOrganization_fixture.json",
    "staffEducationOrganizationAssociation" => "Hyrule_data/staffEducationOrganizationAssociation_fixture.json",
    "gradingPeriod" => "Hyrule_data/gradingPeriod_fixture.json",
    "reportCard" => "Hyrule_data/reportCard_fixture.json"
  ]
  setMultipleFixtureFiles(testHash)
end

desc "Import Sandbox Test Data"
task :importSandboxData do
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  Rake::Task["importSandboxMidgarData"].execute
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
  Rake::Task["importSandboxHyruleData"].execute
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")

  if TODROP
    Rake::Task["runDbIndexingScript"].execute
  end
  Rake::Task["runSearchBulkExtract"].execute
end


desc "Import Migration Test Data to Midgar"
task :importMigrationData do
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")
  testHash = Hash[
    "session" => "migration_data/session_fixture.json",
    "program" => "migration_data/program_fixture.json",
    "section" => "migration_data/section_fixture.json",
    "course" => "migration_data/course_fixture.json",
    "student" => "migration_data/student_fixture.json",
    "parent" => "migration_data/parent_fixture.json",
    "staff" => "migration_data/staff_fixture.json",
    "assessment" => "migration_data/assessment_fixture.json",
    "attendance" => "migration_data/attendance_fixture.json",
    "studentSchoolAssociation" => "migration_data/studentSchoolAssociation_fixture.json",
    "teacherSchoolAssociation" => "migration_data/teacherSchoolAssociation_fixture.json",
    "educationOrganization" => "migration_data/educationOrganization_fixture.json",
    "staffEducationOrganizationAssociation" => "migration_data/staffEducationOrganizationAssociation_fixture.json",
    "schoolSessionAssociation" => "migration_data/schoolSessionAssociation_fixture.json",
    "courseOffering" => "migration_data/courseOffering_fixture.json",
    "courseTranscript" => "migration_data/courseTranscript_fixture.json",
    "studentGradebookEntry" => "migration_data/studentGradebookEntry_fixture.json",
    "disciplineIncident" => "migration_data/disciplineIncident_fixture.json",
    # "studentDisciplineIncidentAssociation" => "migration_data/studentDisciplineIncidentAssociation_fixture.json",
    "disciplineAction" => "migration_data/disciplineAction_fixture.json",
    "cohort" => "migration_data/cohort_fixture.json",
    "staffCohortAssociation" => "migration_data/staffCohortAssociation_fixture.json",
    "staffProgramAssociation" => "migration_data/staffProgramAssociation_fixture.json",
    "studentAcademicRecord" => "migration_data/studentAcademicRecord_fixture.json",
    "learningStandard" => "migration_data/learningStandard_fixture.json",
    "learningObjective" => "migration_data/learningObjective_fixture.json",
    "grade" => "migration_data/grade_fixture.json",
    "studentCompetency" => "migration_data/studentCompetency_fixture.json",
    "gradingPeriod" => "migration_data/gradingPeriod_fixture.json",
    "reportCard" => "migration_data/reportCard_fixture.json",
    "graduationPlan" => "migration_data/graduationPlan_fixture.json",
    "studentCompetencyObjective" => "migration_data/studentCompetencyObjective_fixture.json",
    "competencyLevelDescriptor" => "migration_data/competencyLevelDescriptor_fixture.json"
  ]
  setMultipleFixtureFiles(testHash)
end

desc "Import Sandbox Test Data"
task :importZorkSandboxData do
  testHash = Hash[
    "educationOrganization" => "educationOrganization_fixture_zork.json",
    "staffEducationOrganizationAssociation" => "staffEducationOrganizationAssociation_fixture_zork.json",
    "staff" => "staff_fixture_zork.json",
    "teacherSchoolAssociation" => "teacherSchoolAssociation_fixture_zork.json",

   ]
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "fakedev_zork_net")
  setMultipleFixtureFiles(testHash)
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")

  if TODROP
    Rake::Task["runDbIndexingScript"].execute
  end
end

desc "Import Sandbox Test Data"
task :importChaosSandboxData do
  testHash = Hash[
    "educationOrganization" => "educationOrganization_fixture_chaos.json",
    "staffEducationOrganizationAssociation" => "staffEducationOrganizationAssociation_fixture_chaos.json",
    "staff" => "staff_fixture_chaos.json",
    "teacherSchoolAssociation" => "teacherSchoolAssociation_fixture_chaos.json",

   ]
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "chaos_mokey_org")
  setMultipleFixtureFiles(testHash)
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")

  if TODROP
    Rake::Task["runDbIndexingScript"].execute
  end
end

desc "Import Sandbox Test Data"
task :importPurgeData do
  tenantTestHash = Hash[
    "educationOrganization" => "PurgeFixtureData/educationOrganization_fixture.json",
    "applicationAuthorization" => "PurgeFixtureData/applicationAuthorization_Hyrule_fixture.json",
    "customRole" => "PurgeFixtureData/customRole_Hyrule_fixture.json"
   ]
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Hyrule")
  setMultipleFixtureFiles(tenantTestHash)
  DB_NAME = convertTenantIdToDbName(ENV['DB_NAME'] ? ENV['DB_NAME'] : "Midgar")

  if TODROP
    Rake::Task["runDbIndexingScript"].execute
  end
end

desc "Import Unified Data Set"
task :importUnifiedData => [:realmInit] do
  testHash = Hash[
    "assessment" => "unified_data/uds_assessment.json",
    "assessmentFamily" => "unified_data/uds_assessmentFamily.json",
    "assessmentPeriodDescriptor" => "unified_data/uds_assessmentPeriodDescriptor.json",
    "studentAssessment" => "unified_data/uds_studentAssessment_fixture.json",
    "attendance" => "unified_data/uds_attendance.json",
    "course" => "unified_data/uds_course.json",
    "courseOffering" => "unified_data/uds_courseOffering.json",
    "educationOrganization" => "unified_data/uds_educationOrganization.json",
    "staffEducationOrganizationAssociation" => "unified_data/uds_staffEducationOrganizationAssociation.json",
    "parent" => "unified_data/uds_parent.json",
    "section" => "unified_data/uds_section.json",
    "session" => "unified_data/uds_session.json",
    "student" => "unified_data/uds_student.json",
    "studentSchoolAssociation" => "unified_data/uds_studentSchoolAssociation.json",
    "studentGradebookEntry" => "unified_data/uds_studentGradebookEntry.json",
    "courseTranscript" => "unified_data/uds_courseTranscript.json",
    "staff" => "unified_data/uds_staff.json",
    "teacherSchoolAssociation" => "unified_data/uds_teacherSchoolAssociation.json"
  ]
  setMultipleFixtureFiles(testHash)

  if TODROP
    Rake::Task["runDbIndexingScript"].execute
  end
end

desc "Run indexing script on databases, no drop"
task :runDbIndexingScript do
  sh "cd #{File.dirname(__FILE__)}/../config/scripts; sh resetAllDbs.sh --nodrop"
end

desc "Turn on notablescan flag"
task :turnOnNOTABLESCAN do
  enable_NOTABLESCAN
end

desc "Turn off notablescan flag"
task :turnOffNOTABLESCAN do
  disable_NOTABLESCAN
end

desc "Help information for this Rakefile"
task :help do
  puts <<-eos
This Rakefile assumes one of two things: an environment variable MONGO_HOME
is set to the home directory of mongo (just before bin) or that the mongo binaries
are on your PATH.

By default, the tests run against the deployed API/application that is running on
localhost:8080 and also assumes a mongo server running on localhost (at default port).

By default, any Scenario Outlines will be expanded in the console output for ease of development,
but at the command line, the env var "NO_EXPAND" may be defined to run without expanding the Scenario
Outline to allow for proper JUnit XML output files for display in Jenkins

To change this behavior use the following syntax to override:

cmd>rake property=value <rake Task>

Example:

cmd>rake DB_HOST=myNewDbHost.domain.name api_server_url=my.API.server.com production

The properties available to override are as follows:

DB_HOST                This property selects which mongo instance to set the fixture to (default: localhost)
DB_NAME                This property selects which mongo db to set the fixture to (default: sli)
api_server_url         This property selects which running instance of the API to run tests against (default: localhost)
admintools_server_url  This property selects which running instance of the Admin Tools to run tests against (default: localhost)
DEBUG                  This property tells the test code to display debug output in the console
CUKE_EXPAND            This property tells cucumber to expand Scenario Outlines (for use in jenkins, default: not expand)
OTHER_TAGS             This property allows you to run tests with debug tags, so pass a tag for this env var ie: @test
FAILSLOW               This property will tell cucumber to continue even if tests fail. Normally it will fail on the first error.
eos

end

desc "Get a list of all available tasks"
task :tasks do
    puts "The following are all the available tasks:"

    tasks = Rake.application.tasks
    tasks.each do |t|
      puts ":" + t.to_s
    end
end

#######################################################
# Primary Key Factory Class for Shard Type 1 UUIDs
#######################################################

class ShardType1UUIDPKFactory
  require 'securerandom'
  def create_pk(doc)
    chars = ("a".."z").to_a
    prefix = Time.new.year.to_s + Array.new(2, '').collect{chars[rand(chars.size)]}.join
    doc["_id"] ||= prefix + "-" + SecureRandom.uuid
    doc
  end
end

