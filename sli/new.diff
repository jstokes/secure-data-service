diff --git a/sli/acceptance-tests/test/features/security/path_checking_security.feature b/sli/acceptance-tests/test/features/security/path_checking_security.feature
index 64df24036f74d743bf051a4f23680bfb76e67ff8..fed8b934b6f80bf24228cf732384b72ad945bb26 100644
--- a/sli/acceptance-tests/test/features/security/path_checking_security.feature
+++ b/sli/acceptance-tests/test/features/security/path_checking_security.feature
@@ -181,7 +181,7 @@ Scenario Outline: Deny multiple IDs in URI if those IDs are rewritten to query p
 #NOTE: This test will need to be reworked if the API is ever made to support multiple ids in query params
     Given I am logged in using "rrogers" "rrogers1234" to realm "IL"
      When I call <Path> using ID <IDs>
-     Then I should receive a return code of 413
+     Then I should receive a return code of 400
 
 Examples:
   | Path                                   | IDs                                    |
diff --git a/sli/api/src/main/java/org/slc/sli/api/exceptions/EntityTypeNotFoundException.java b/sli/api/src/main/java/org/slc/sli/api/exceptions/EntityTypeNotFoundException.java
new file mode 100644
index 0000000000000000000000000000000000000000..9802cf44ad422cb0223395c1fde021a1e0b6ba1f
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/exceptions/EntityTypeNotFoundException.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.exceptions;
+
+/**
+ * Indicates that looking up an entity type was unsuccessful.
+ */
+public class EntityTypeNotFoundException extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+
+    public EntityTypeNotFoundException(String message) {
+        super(message);
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/exceptions/RequestBlockedException.java b/sli/api/src/main/java/org/slc/sli/api/exceptions/RequestBlockedException.java
new file mode 100644
index 0000000000000000000000000000000000000000..05635142653f797bec4c03d104d5f9ec63870095
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/exceptions/RequestBlockedException.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.exceptions;
+
+/**
+ * Indicates that a request to the API has been blocked.
+ */
+public class RequestBlockedException extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+
+    public RequestBlockedException(String message) {
+        super(message);
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/exceptions/URITranslationException.java b/sli/api/src/main/java/org/slc/sli/api/exceptions/URITranslationException.java
new file mode 100644
index 0000000000000000000000000000000000000000..f35ee7996f5ce121e73b19f503fb983cb88b7c6e
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/exceptions/URITranslationException.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.exceptions;
+
+/**
+ * Indicates a failure of URI translation.
+ */
+public class URITranslationException extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+
+    public URITranslationException(String message) {
+        super(message);
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/exceptions/UriMutationException.java b/sli/api/src/main/java/org/slc/sli/api/exceptions/UriMutationException.java
new file mode 100644
index 0000000000000000000000000000000000000000..8034000cc19dd3ada3b46e70236947fbc35fe853
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/exceptions/UriMutationException.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.exceptions;
+
+/**
+ * Indicates that a student was not in any cohorts or programs.
+ */
+public class UriMutationException extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+
+    public UriMutationException(String message) {
+        super(message);
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/PreProcessFilter.java b/sli/api/src/main/java/org/slc/sli/api/jersey/PreProcessFilter.java
index f9e86fe99bda58b18a23eb45433c9c3bb43aa81d..83a3d652c65a3853cdcec1c6e3ed26835ad2dffa 100644
--- a/sli/api/src/main/java/org/slc/sli/api/jersey/PreProcessFilter.java
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/PreProcessFilter.java
@@ -23,6 +23,7 @@ import org.slc.sli.api.config.EntityDefinitionStore;
 import org.slc.sli.api.constants.PathConstants;
 import org.slc.sli.api.constants.ResourceNames;
 import org.slc.sli.api.criteriaGenerator.DateFilterCriteriaGenerator;
+import org.slc.sli.api.exceptions.RequestBlockedException;
 import org.slc.sli.api.resources.generic.MethodNotAllowedException;
 import org.slc.sli.api.resources.generic.config.ResourceEndPoint;
 import org.slc.sli.api.resources.generic.util.ResourceMethod;
@@ -286,7 +287,7 @@ public class PreProcessFilter implements ContainerRequestFilter {
         }
 
         if (this.resourceEndPoint.getBlockGetRequestEndPoints().contains(requestPath)) {
-            throw new EntityNotFoundException(request.getPath());
+            throw new RequestBlockedException(request.getPath());
         }
     }
 }
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/APIAccessDeniedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/APIAccessDeniedExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ed2e17b57b046d211edd5ce238f0bed6d64c94a
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/APIAccessDeniedExceptionHandler.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.security.SLIPrincipal;
+import org.slc.sli.api.security.SecurityEventBuilder;
+import org.slc.sli.api.security.context.APIAccessDeniedException;
+import org.slc.sli.api.security.service.AuditLogger;
+import org.slc.sli.common.constants.EntityNames;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.security.core.context.SecurityContextHolder;
+import org.springframework.stereotype.Component;
+
+import javax.servlet.http.HttpServletResponse;
+import javax.ws.rs.core.*;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+import java.io.IOException;
+
+/**
+ * Handler for catching API access denied exceptions that log security events.
+ *
+ * @author bsuzuki
+ */
+@Provider
+@Component
+public class APIAccessDeniedExceptionHandler implements ExceptionMapper<APIAccessDeniedException> {
+
+    private static final Logger LOG = LoggerFactory.getLogger(APIAccessDeniedExceptionHandler.class);
+
+    @Autowired
+    private SecurityEventBuilder securityEventBuilder;
+
+    @Autowired
+    private AuditLogger auditLogger;
+
+    @Context
+    UriInfo uriInfo;
+
+    @Context
+    private HttpHeaders headers;
+
+    @Context
+    private HttpServletResponse response;
+
+    @Override
+    public Response toResponse(APIAccessDeniedException e) {
+        //There are a few jax-rs resources that generate HTML content, and we want the
+        //default web-container error handler pages to get used in those cases.
+        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
+            try {
+                response.sendError(403, e.getMessage());
+                logSecurityEvent(e);
+                return null;    //the error page handles the response, so no need to return a response
+            } catch (IOException ex) {
+                LOG.error("Error displaying error page", ex);
+            }
+        }
+
+        Response.Status errorStatus = Response.Status.FORBIDDEN;
+        SLIPrincipal principal = null ;
+        if (SecurityContextHolder.getContext().getAuthentication() != null) {
+            principal = (SLIPrincipal)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
+            LOG.warn("Access has been denied to user: {}",principal );
+        } else {
+            LOG.warn("Access has been denied to user for being incorrectly associated");
+        }
+        LOG.warn("Cause: {}", e.getMessage());
+
+        logSecurityEvent(e);
+
+        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
+        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
+            errorType = MediaType.APPLICATION_XML_TYPE;
+        }
+        
+        return Response.status(errorStatus).entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), "Access DENIED: " + e.getMessage())).type(errorType).build();
+    }
+
+    private void logSecurityEvent(APIAccessDeniedException e) {
+
+        if (e.getTargetEdOrgIds() != null) {
+            // if we already have the target edOrgs - good to go
+            auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+                    + e.getMessage(), e.getRealm(), EntityNames.EDUCATION_ORGANIZATION, e.getTargetEdOrgIds().toArray(new String[0])));
+
+        } else if (e.getEntityType() != null) {
+
+            if (e.getEntities() != null && !e.getEntities().isEmpty()) {
+                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+                        + e.getMessage(), e.getRealm(), e.getEntityType(), e.getEntities()));
+
+            } else if (e.getEntityIds() != null && !e.getEntityIds().isEmpty()) {
+                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+                        + e.getMessage(), e.getRealm(), e.getEntityType(), e.getEntityIds().toArray(new String[0])));
+            } else {
+                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+                        + e.getMessage(), e.getPrincipal(), e.getClientId(), e.getRealm(), null, e.isTargetIsUserEdOrg()));
+            }
+        } else {
+            auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+                    + e.getMessage(), e.getPrincipal(), e.getClientId(), e.getRealm(), null, e.isTargetIsUserEdOrg()));
+        }
+    }
+
+    private String getThrowingClassName(Exception e) {
+        if (e != null && e.getStackTrace() != null) {
+            StackTraceElement ste = e.getStackTrace()[0];
+            if (ste != null) {
+                return ste.getClassName();
+            }
+        }
+        return null;
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/AccessDeniedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/AccessDeniedExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b75f17cf44333722304660c3587af9dae1081dd
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/AccessDeniedExceptionHandler.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import java.io.IOException;
+
+import javax.servlet.http.HttpServletResponse;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.UriInfo;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.security.access.AccessDeniedException;
+import org.springframework.security.core.context.SecurityContextHolder;
+import org.springframework.stereotype.Component;
+
+import org.slc.sli.api.security.SLIPrincipal;
+import org.slc.sli.api.security.SecurityEventBuilder;
+
+/**
+ * Handler for catching access denied exceptions.
+ *
+ * @author shalka
+ */
+@Provider
+@Component
+public class AccessDeniedExceptionHandler implements ExceptionMapper<AccessDeniedException> {
+
+    private static final Logger LOG = LoggerFactory.getLogger(AccessDeniedExceptionHandler.class);
+
+    public static final String ED_ORG_START = "<" ;
+    public static final String ED_ORG_END = ">" ;
+    public static final String NO_EDORG = "UNAVAILABLE";
+
+    @Autowired
+    private SecurityEventBuilder securityEventBuilder;
+
+    @Context
+    UriInfo uriInfo;
+
+    @Context
+    private HttpHeaders headers;
+
+    @Context
+    private HttpServletResponse response;
+
+    @Override
+    public Response toResponse(AccessDeniedException e) {
+
+        //There are a few jax-rs resources that generate HTML content, and we want the
+        //default web-container error handler pages to get used in those cases.
+        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
+            try {
+                response.sendError(403, e.getMessage());
+                return null;    //the error page handles the response, so no need to return a response
+            } catch (IOException ex) {
+                LOG.error("Error displaying error page", ex);
+            }
+        }
+
+        Response.Status errorStatus = Response.Status.FORBIDDEN;
+        SLIPrincipal principal = null ;
+        String message = e.getMessage();
+        if (SecurityContextHolder.getContext().getAuthentication() != null) {
+            principal = (SLIPrincipal)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
+            LOG.warn("Access has been denied to user: {}",principal );
+        } else {
+            LOG.warn("Access has been denied to user for being incorrectly associated");
+        }
+        LOG.warn("Cause: {}", e.getMessage());
+
+        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
+        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
+            errorType = MediaType.APPLICATION_XML_TYPE;
+        }
+        
+        return Response.status(errorStatus).entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), "Access DENIED: " + e.getMessage())).type(errorType).build();
+    }
+
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ContextInferrenceFailedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ContextInferrenceFailedExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..54779bf2dd0e62ecdeb6da211bf6d48d6446f85d
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ContextInferrenceFailedExceptionHandler.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import java.util.Collections;
+
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+import javax.xml.bind.annotation.XmlRootElement;
+
+import org.slc.sli.api.security.pdp.ContextInferrenceFailedException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.stereotype.Component;
+
+/**
+ * Handles empty contexts
+ * 
+ * @author dkornishev
+ * 
+ */
+@Provider
+@Component
+public class ContextInferrenceFailedExceptionHandler implements ExceptionMapper<ContextInferrenceFailedException> {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ContextInferrenceFailedExceptionHandler.class);
+
+    @Context
+    private HttpHeaders headers;
+    
+    @Override
+    public Response toResponse(ContextInferrenceFailedException exception) {
+        LOG.warn("Failed Context Inferrence");
+        Object entity = Collections.EMPTY_LIST;
+        if (headers.getAcceptableMediaTypes().contains(MediaType.APPLICATION_XML_TYPE)) {
+            entity = new EmptyResponse();
+        }
+        
+        return Response.status(Status.NOT_FOUND).entity(entity).header("TotalCount", 0).build();
+    }
+    
+    /**
+     * Represents an empty document to be returned to the API user (no fields, no data).
+     * 
+     * 
+     * @author kmyers
+     *
+     */
+    @XmlRootElement(name = "emptyList")
+    public static class EmptyResponse {
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EOFExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EOFExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..43fcce3174ddefa063432dc1bf89e7d1e6acb329
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EOFExceptionHandler.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import java.io.EOFException;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.springframework.stereotype.Component;
+
+/**
+ * Exception handler to catch cases where an EOF exception is thrown. This can be the case if a user
+ * tries to post a null body
+ *
+ * @author nbrown
+ *
+ */
+@Provider
+@Component
+public class EOFExceptionHandler implements ExceptionMapper<EOFException> {
+
+    @Override
+    public Response toResponse(EOFException exception) {
+        return Response.status(Response.Status.BAD_REQUEST).build();
+    }
+
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EmbeddedDocumentLimitExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EmbeddedDocumentLimitExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..85ca0370a40e0a72bb1000065357bd404a4634b3
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EmbeddedDocumentLimitExceptionHandler.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.CustomStatus;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.selectors.doc.EmbeddedDocumentLimitException;
+import org.springframework.stereotype.Component;
+
+/**
+ * @author jstokes
+ */
+@Provider
+@Component
+public class EmbeddedDocumentLimitExceptionHandler implements ExceptionMapper<EmbeddedDocumentLimitException> {
+
+    @Override
+    public Response toResponse(EmbeddedDocumentLimitException e) {
+        return Response
+                .status(CustomStatus.ENTITY_TOO_LARGE)
+                .entity(new ErrorResponse(CustomStatus.ENTITY_TOO_LARGE.getStatusCode(), CustomStatus.ENTITY_TOO_LARGE.getReasonPhrase(),
+                        e.getMessage())).build();
+    }
+}
+
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityNotFoundHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityNotFoundHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..2bf4379bdfa63618389e0981c3c258c321d4c5d8
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityNotFoundHandler.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.springframework.stereotype.Component;
+
+import org.slc.sli.api.service.EntityNotFoundException;
+
+/**
+ * Hander for entity not found errors
+ */
+@Provider
+@Component
+public class EntityNotFoundHandler implements ExceptionMapper<EntityNotFoundException> {
+
+    public Response toResponse(EntityNotFoundException e) {
+        Response.Status errorStatus = Response.Status.NOT_FOUND;
+        return Response
+                .status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                        "Entity not found: " + e.getId())).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityTypeNotFoundHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityTypeNotFoundHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..499be4935f6bd07cdd1832205c90e583957d4b9a
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityTypeNotFoundHandler.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.slc.sli.api.exceptions.EntityTypeNotFoundException;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.service.EntityNotFoundException;
+import org.springframework.stereotype.Component;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * Handler for entity type not found errors
+ */
+@Provider
+@Component
+public class EntityTypeNotFoundHandler implements ExceptionMapper<EntityTypeNotFoundException> {
+
+    public Response toResponse(EntityTypeNotFoundException e) {
+        String message = "entity type not found";
+        if (e.getMessage() != null) {
+            message += ": " + e.getMessage();
+        }
+        Response.Status errorStatus = Response.Status.NOT_FOUND;
+        return Response
+                .status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                        message)).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/GenericExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/GenericExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ec96925e260d657fd5ffb4dbb108f59ea5dfb23
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/GenericExceptionHandler.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import java.io.IOException;
+
+import javax.servlet.http.HttpServletResponse;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.HttpHeaders;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.stereotype.Component;
+
+/**
+ * Hander for uncaught errors
+ */
+@Provider
+@Component
+public class GenericExceptionHandler implements ExceptionMapper<Throwable> {
+
+    private static final Logger LOG = LoggerFactory.getLogger(GenericExceptionHandler.class);
+    
+    @Context
+    private HttpHeaders headers;
+    
+    @Context
+    private HttpServletResponse response;
+
+    @Override
+    public Response toResponse(Throwable e) {
+
+        //There are a few jax-rs resources that generate HTML content, and we want the
+        //default web-container error handler pages to get used in those cases.
+        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
+            try {
+                LOG.error(e.getMessage(), e);
+                response.sendError(500, e.getMessage());
+                return null;    //the error page handles the response, so no need to return a response
+            } catch (IOException ex) {
+                LOG.error("Error displaying error page", ex);
+            }
+        }
+        Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;
+        
+        LOG.error("Caught exception thrown by ReST handler", e);
+        return Response
+                .status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                        "Internal Server Error: " + e.getMessage())).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/IllegalArgumentExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/IllegalArgumentExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..66c47648efaf814bddc608a4f23d4e7e99c2c987
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/IllegalArgumentExceptionHandler.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.springframework.stereotype.Component;
+
+/**
+ * Handles bad requests
+  */
+@Provider
+@Component
+public class IllegalArgumentExceptionHandler implements ExceptionMapper<IllegalArgumentException> {
+
+    @Override
+    public Response toResponse(IllegalArgumentException e) {
+        return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/InsufficientAuthenticationHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/InsufficientAuthenticationHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a237e251291b2032021f847b8953d82198fdb54
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/InsufficientAuthenticationHandler.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.*;
+import javax.ws.rs.core.Response.Status;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.security.SecurityEventBuilder;
+import org.slc.sli.api.security.oauth.OAuthAccessException;
+import org.slc.sli.api.security.service.AuditLogger;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Value;
+import org.springframework.security.authentication.InsufficientAuthenticationException;
+import org.springframework.stereotype.Component;
+
+import java.net.URI;
+
+/**
+ * Translates InsufficientAuthenticationException to 401
+ *
+ * @author dkornishev
+ *
+ */
+@Component
+@Provider
+public class InsufficientAuthenticationHandler implements ExceptionMapper<InsufficientAuthenticationException> {
+
+    @Value("${sli.security.noSession.landing.url}")
+    private String authUrl;
+
+    @Autowired
+    private SecurityEventBuilder securityEventBuilder;
+
+    @Autowired
+    private AuditLogger auditLogger;
+
+    @Context
+    UriInfo uriInfo;
+
+    @Context
+    private HttpHeaders headers;
+
+    @Override
+    public Response toResponse(InsufficientAuthenticationException exception) {
+        Status status = Response.Status.UNAUTHORIZED;
+        String wwwAuthHeader = this.authUrl;
+        URI requestUri = (uriInfo == null) ? null : uriInfo.getRequestUri();
+
+        //If we have an embedded OAuth exception, then put the error information in the www-auth header per oauth spec 
+        //http://tools.ietf.org/html/rfc6750 see sec 3
+        //Otherwise put the auth url in the header
+        if (exception.getCause() != null && exception.getCause() instanceof OAuthAccessException) {
+            OAuthAccessException oauthEx = (OAuthAccessException) exception.getCause();
+            wwwAuthHeader = "Bearer error=\"" + oauthEx.getType().toString() + "\", error_description=\"" + oauthEx.getMessage() + "\"";
+        }
+        
+        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
+        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
+            errorType = MediaType.APPLICATION_XML_TYPE;
+        }
+
+        auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(exception), requestUri, "Access Denied: "
+                + exception.getMessage(), false));
+
+        return Response.status(status).entity(new ErrorResponse(status.getStatusCode(), status.getReasonPhrase(),
+                "Access DENIED: " + exception.getMessage())).header(HttpHeaders.WWW_AUTHENTICATE, wwwAuthHeader).type(errorType).build();
+    }
+
+    private String getThrowingClassName(Exception e) {
+        if (e != null && e.getStackTrace() != null) {
+            StackTraceElement ste = e.getStackTrace()[0];
+            if (ste != null) {
+                return ste.getClassName();
+            }
+        }
+        return null;
+    }
+
+    public void setSecurityEventBuilder(SecurityEventBuilder securityEventBuilder) {
+        this.securityEventBuilder = securityEventBuilder;
+    }
+
+    public void setAuditLogger(AuditLogger auditLogger) {
+        this.auditLogger = auditLogger;
+    }
+
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/JsonParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/JsonParseExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..0de45ddd8208339f077b4401798a793ab23f4729
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/JsonParseExceptionHandler.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.codehaus.jackson.JsonParseException;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.springframework.stereotype.Component;
+
+/**
+ * Exception handler for SortingExceptions
+ * 
+ * @author Ryan Farris <rfarris@wgen.net>
+ * 
+ */
+@Provider
+@Component
+public class JsonParseExceptionHandler implements ExceptionMapper<JsonParseException> {
+    
+    @Override
+    public Response toResponse(JsonParseException e) {
+        Response.Status errorStatus = Response.Status.BAD_REQUEST;
+        return Response.status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), e.getMessage()))
+                .build();
+    }
+    
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/MethodNotAllowedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/MethodNotAllowedExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..ebac3799e048a7963e9fe16d28269faaf508d10b
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/MethodNotAllowedExceptionHandler.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.resources.generic.MethodNotAllowedException;
+import org.springframework.stereotype.Component;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * Exception mapper for dis allowed methods
+ *
+ * @author srupasinghe
+ */
+
+@Provider
+@Component
+public class MethodNotAllowedExceptionHandler implements ExceptionMapper<MethodNotAllowedException> {
+
+    public Response toResponse(MethodNotAllowedException e) {
+        String message = "Method Not Allowed [" + e.getAllowedMethods() + "]";
+
+        Response.ResponseBuilder builder =  Response
+                .status(405)
+                .entity(new ErrorResponse(405, "Method Not Allowed",
+                        message));
+
+        builder.header("Allow", "Allow: " + e.getAllowedMethods());
+
+        return builder.build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/NaturalKeyValidationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/NaturalKeyValidationExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..640d70295d91c36e97ff16f8b344b4c8c3f76592
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/NaturalKeyValidationExceptionHandler.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.apache.commons.lang3.StringUtils;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.validation.NaturalKeyValidationException;
+import org.springframework.stereotype.Component;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * Exception mapper NaturalKeyValidationExceptions
+ *
+ * @author srupasinghe
+ */
+@Provider
+@Component
+public class NaturalKeyValidationExceptionHandler implements ExceptionMapper<NaturalKeyValidationException> {
+
+    public Response toResponse(NaturalKeyValidationException e) {
+        String exceptionMessage = "Natural Key Validation failed: " + e.getEntityType() + " " + StringUtils.join(e.getNaturalKeys());
+        return Response
+                .status(Response.Status.CONFLICT)
+                .entity(new ErrorResponse(Response.Status.CONFLICT.getStatusCode(), Response.Status.CONFLICT.getReasonPhrase(),
+                        exceptionMessage)).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/OAuthAccessExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/OAuthAccessExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..3450058f95ba77389b4aca53b1e307b1563af055
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/OAuthAccessExceptionHandler.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.springframework.stereotype.Component;
+
+import org.slc.sli.api.security.oauth.OAuthAccessException;
+import org.slc.sli.api.security.oauth.OAuthAccessException.OAuthError;
+
+/**
+ *
+ * Handle oauth access exceptions as described in 5.2
+ */
+@Component
+@Provider
+public class OAuthAccessExceptionHandler implements ExceptionMapper<OAuthAccessException>  {
+
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public Response toResponse(OAuthAccessException ex) {
+
+        Response.Status errorStatus = null;
+
+        if (ex.getType() == OAuthError.UNAUTHORIZED_CLIENT) {
+            errorStatus = Response.Status.FORBIDDEN;
+        } else {
+            errorStatus = Response.Status.BAD_REQUEST;
+        }
+
+        @SuppressWarnings("rawtypes")
+        Map data = new HashMap();
+        data.put("error", ex.getType().toString());
+        data.put("error_description", ex.getMessage());
+        if (ex.getState() != null) {
+            data.put("state", ex.getState());
+        }
+        return Response.status(errorStatus).entity(data).build();
+
+    }
+
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/PreConditionExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/PreConditionExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..670f1b5658c62d2294bf6f7b0150c66c37652154
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/PreConditionExceptionHandler.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.resources.generic.PreConditionFailedException;
+import org.springframework.stereotype.Component;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * Exception mapper for precondition failures
+ *
+ * @author srupasinghe
+ */
+
+@Provider
+@Component
+public class PreConditionExceptionHandler implements ExceptionMapper<PreConditionFailedException> {
+
+    public Response toResponse(PreConditionFailedException e) {
+
+        return Response
+                .status(Response.Status.PRECONDITION_FAILED)
+                .entity(new ErrorResponse(Response.Status.PRECONDITION_FAILED.getStatusCode(), Response.Status.PRECONDITION_FAILED.getReasonPhrase(),
+                        e.getMessage())).build();
+
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/QueryParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/QueryParseExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..58d60cdab6ce6701bd2494e9d46fca2fb44f7f50
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/QueryParseExceptionHandler.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.springframework.stereotype.Component;
+
+import org.slc.sli.domain.QueryParseException;
+
+/**
+ * Handler for Query Parsing errors
+ */
+@Provider
+@Component
+public class QueryParseExceptionHandler implements ExceptionMapper<QueryParseException> {
+    
+    public Response toResponse(QueryParseException e) {
+        Response.Status errorStatus = Response.Status.BAD_REQUEST;
+        return Response
+                .status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                        "Error Parsing the Query: " + e.getMessage())).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/RequestBlockedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/RequestBlockedExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..b40f777c8499d7a68d672dc7dac9f1afaaa3ed25
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/RequestBlockedExceptionHandler.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.slc.sli.api.exceptions.RequestBlockedException;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.service.EntityNotFoundException;
+import org.springframework.stereotype.Component;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * Handler for RequestBlockedException
+ *
+ * We don't necessarily want to let the user know that their request is blocked, so
+ * we'll return an HTTP 404 (not found) error code.
+ */
+@Provider
+@Component
+public class RequestBlockedExceptionHandler implements ExceptionMapper<RequestBlockedException> {
+
+    public Response toResponse(RequestBlockedException e) {
+        String message = "not found";
+        if (e.getMessage() != null) {
+            message += ": " + e.getMessage();
+        }
+
+        Response.Status errorStatus = Response.Status.NOT_FOUND;
+        return Response
+                .status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                        message)).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ResponseTooLargeExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ResponseTooLargeExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..c770468846fadfe2fcb0dedc1efbe431481331de
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ResponseTooLargeExceptionHandler.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.CustomStatus;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.security.context.ResponseTooLargeException;
+import org.springframework.stereotype.Component;
+
+/**
+ * Handler for when the response is too large to manage
+ */
+@Provider
+@Component
+public class ResponseTooLargeExceptionHandler implements ExceptionMapper<ResponseTooLargeException> {
+    
+    @Override
+    public Response toResponse(ResponseTooLargeException exception) {
+        
+        return Response
+                .status(CustomStatus.ENTITY_TOO_LARGE)
+                .entity(new ErrorResponse(CustomStatus.ENTITY_TOO_LARGE.getStatusCode(), CustomStatus.ENTITY_TOO_LARGE.getReasonPhrase(),
+                        "The response is too large to process. The request should be modified to return a smaller response.")).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SelectorParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SelectorParseExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..b91c82dde753ec0480dba739e5d6052fb6b653c6
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SelectorParseExceptionHandler.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.selectors.model.SelectorParseException;
+import org.springframework.stereotype.Component;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * @author jstokes
+ */
+@Provider
+@Component
+public class SelectorParseExceptionHandler implements ExceptionMapper<SelectorParseException> {
+
+    public Response toResponse(SelectorParseException e) {
+        return Response
+                .status(Response.Status.BAD_REQUEST)
+                .entity(new ErrorResponse(Status.BAD_REQUEST.getStatusCode(), Status.BAD_REQUEST.getReasonPhrase(),
+                        e.getMessage())).build();
+    }
+}
+
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SortingExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SortingExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..801ecc84b57f69a8ea4d8251bf9784cdc590ee42
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SortingExceptionHandler.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.springframework.stereotype.Component;
+
+import org.slc.sli.api.service.query.SortingException;
+
+/**
+ * Exception handler for SortingExceptions
+ * 
+ * @author Ryan Farris <rfarris@wgen.net>
+ * 
+ */
+@Provider
+@Component
+public class SortingExceptionHandler implements ExceptionMapper<SortingException> {
+    
+    @Override
+    public Response toResponse(SortingException e) {
+        Response.Status errorStatus = Response.Status.BAD_REQUEST;
+        return Response.status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), e.getMessage()))
+                .build();
+    }
+    
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/URITranslationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/URITranslationExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..17a6c42f11a07de8291d7ebd78d799f9645b4851
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/URITranslationExceptionHandler.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.slc.sli.api.exceptions.URITranslationException;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slc.sli.api.service.EntityNotFoundException;
+import org.springframework.stereotype.Component;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * Handler for URI translation errors (gives an HTTP 404 not found response)
+ */
+@Provider
+@Component
+public class URITranslationExceptionHandler implements ExceptionMapper<URITranslationException> {
+
+    public Response toResponse(URITranslationException e) {
+        String message = "URI translation failed";
+        if (e.getMessage() != null) {
+            message += ": " + e.getMessage();
+        }
+        Response.Status errorStatus = Response.Status.NOT_FOUND;
+        return Response
+                .status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                        message)).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UncategorizedMongoExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UncategorizedMongoExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e4552b7b566908b3a80df5e3ca7e22b3cfe2303
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UncategorizedMongoExceptionHandler.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.data.mongodb.UncategorizedMongoDbException;
+import org.springframework.stereotype.Component;
+
+/**
+ * Handle connection issues to mongo
+ *
+ * @author nbrown
+ *
+ */
+@Provider
+@Component
+public class UncategorizedMongoExceptionHandler implements ExceptionMapper<UncategorizedMongoDbException> {
+
+    private static final Logger LOG = LoggerFactory.getLogger(UncategorizedMongoExceptionHandler.class);
+
+    @Override
+    public Response toResponse(UncategorizedMongoDbException exception) {
+        Status errorStatus = Status.SERVICE_UNAVAILABLE;
+        LOG.error("Could not access database", exception);
+        return Response
+                .status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                        "Could not access database:" + exception.getMessage())).build();
+    }
+
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UriMutationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UriMutationExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..cda5415aff46f925be0af5969b5c8f7631d542a3
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UriMutationExceptionHandler.java
@@ -0,0 +1,30 @@
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import org.slc.sli.api.exceptions.UriMutationException;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.springframework.stereotype.Component;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+/**
+ * Handler for UriMutationExceptions, which should result in an HTTP 404 not found
+ */
+@Provider
+@Component
+public class UriMutationExceptionHandler implements ExceptionMapper<UriMutationException> {
+
+    public Response toResponse(UriMutationException e) {
+        String message = "URI mutation error";
+        if (e.getMessage() != null) {
+            message += ": " + e.getMessage();
+        }
+
+        Response.Status errorStatus = Response.Status.NOT_FOUND;
+        return Response
+                .status(errorStatus)
+                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                        message)).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ValidationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ValidationExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..c99ff4576576855b6951f5009410683da7bbd29e
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ValidationExceptionHandler.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.Response.Status;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.apache.commons.lang3.StringUtils;
+import org.slc.sli.api.representation.ErrorResponse;
+import org.springframework.stereotype.Component;
+
+import org.slc.sli.validation.EntityValidationException;
+
+/**
+ * Hander for validation errors
+ */
+@Provider
+@Component
+public class ValidationExceptionHandler implements ExceptionMapper<EntityValidationException> {
+
+    public Response toResponse(EntityValidationException e) {
+        String exceptionMessage = "Validation failed: " + StringUtils.join(e.getValidationErrors(), "\n");
+        return Response
+                .status(Response.Status.BAD_REQUEST)
+                .entity(new ErrorResponse(Status.BAD_REQUEST.getStatusCode(), Status.BAD_REQUEST.getReasonPhrase(),
+                        exceptionMessage)).build();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/WebApplicationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/WebApplicationExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e30078c6a5524551db8a28911d91c06492fc42a
--- /dev/null
+++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/WebApplicationExceptionHandler.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.slc.sli.api.jersey.exceptionhandlers;
+
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import javax.ws.rs.ext.Provider;
+
+import org.slc.sli.api.representation.ErrorResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.stereotype.Component;
+
+/**
+ * Hander for jax-rs web application exceptions
+ */
+@Provider
+@Component
+public class WebApplicationExceptionHandler implements ExceptionMapper<WebApplicationException> {
+
+    public static final Logger LOG = LoggerFactory.getLogger(WebApplicationExceptionHandler.class);
+    
+    @Override
+    public Response toResponse(WebApplicationException e) {
+        if (e.getResponse().getStatus() == 500) {
+            LOG.error("Caught exception thrown by ReST handler", e);
+            Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;
+            
+            return Response
+                    .status(errorStatus)
+                    .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+                            "Internal Server Error: " + e.getMessage())).build();
+        }
+        return e.getResponse();
+    }
+}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/APIAccessDeniedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/APIAccessDeniedExceptionHandler.java
deleted file mode 100644
index 6bfd4f527216eef19f11952c79730a379285cdfc..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/APIAccessDeniedExceptionHandler.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import org.slc.sli.api.config.EntityDefinitionStore;
-import org.slc.sli.api.resources.security.RealmResource;
-import org.slc.sli.api.security.SLIPrincipal;
-import org.slc.sli.api.security.SecurityEventBuilder;
-import org.slc.sli.api.security.context.APIAccessDeniedException;
-import org.slc.sli.api.security.context.EdOrgOwnershipArbiter;
-import org.slc.sli.api.security.context.PagingRepositoryDelegate;
-import org.slc.sli.api.security.service.AuditLogger;
-import org.slc.sli.common.constants.EntityNames;
-import org.slc.sli.domain.Entity;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.security.core.context.SecurityContextHolder;
-import org.springframework.stereotype.Component;
-
-import javax.servlet.http.HttpServletResponse;
-import javax.ws.rs.core.*;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-import java.io.IOException;
-import java.util.*;
-
-/**
- * Handler for catching API access denied exceptions that log security events.
- *
- * @author bsuzuki
- */
-@Provider
-@Component
-public class APIAccessDeniedExceptionHandler implements ExceptionMapper<APIAccessDeniedException> {
-
-    private static final Logger LOG = LoggerFactory.getLogger(APIAccessDeniedExceptionHandler.class);
-
-    @Autowired
-    private SecurityEventBuilder securityEventBuilder;
-
-    @Autowired
-    private AuditLogger auditLogger;
-
-    @Context
-    UriInfo uriInfo;
-
-    @Context
-    private HttpHeaders headers;
-
-    @Context
-    private HttpServletResponse response;
-
-    @Override
-    public Response toResponse(APIAccessDeniedException e) {
-        //There are a few jax-rs resources that generate HTML content, and we want the
-        //default web-container error handler pages to get used in those cases.
-        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
-            try {
-                response.sendError(403, e.getMessage());
-                logSecurityEvent(e);
-                return null;    //the error page handles the response, so no need to return a response
-            } catch (IOException ex) {
-                LOG.error("Error displaying error page", ex);
-            }
-        }
-
-        Response.Status errorStatus = Response.Status.FORBIDDEN;
-        SLIPrincipal principal = null ;
-        if (SecurityContextHolder.getContext().getAuthentication() != null) {
-            principal = (SLIPrincipal)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
-            LOG.warn("Access has been denied to user: {}",principal );
-        } else {
-            LOG.warn("Access has been denied to user for being incorrectly associated");
-        }
-        LOG.warn("Cause: {}", e.getMessage());
-
-        logSecurityEvent(e);
-
-        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
-        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
-            errorType = MediaType.APPLICATION_XML_TYPE;
-        }
-        
-        return Response.status(errorStatus).entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), "Access DENIED: " + e.getMessage())).type(errorType).build();
-    }
-
-    private void logSecurityEvent(APIAccessDeniedException e) {
-
-        if (e.getTargetEdOrgIds() != null) {
-            // if we already have the target edOrgs - good to go
-            auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
-                    + e.getMessage(), e.getRealm(), EntityNames.EDUCATION_ORGANIZATION, e.getTargetEdOrgIds().toArray(new String[0])));
-
-        } else if (e.getEntityType() != null) {
-
-            if (e.getEntities() != null && !e.getEntities().isEmpty()) {
-                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
-                        + e.getMessage(), e.getRealm(), e.getEntityType(), e.getEntities()));
-
-            } else if (e.getEntityIds() != null && !e.getEntityIds().isEmpty()) {
-                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
-                        + e.getMessage(), e.getRealm(), e.getEntityType(), e.getEntityIds().toArray(new String[0])));
-            } else {
-                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
-                        + e.getMessage(), e.getPrincipal(), e.getClientId(), e.getRealm(), null, e.isTargetIsUserEdOrg()));
-            }
-        } else {
-            auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
-                    + e.getMessage(), e.getPrincipal(), e.getClientId(), e.getRealm(), null, e.isTargetIsUserEdOrg()));
-        }
-    }
-
-    private String getThrowingClassName(Exception e) {
-        if (e != null && e.getStackTrace() != null) {
-            StackTraceElement ste = e.getStackTrace()[0];
-            if (ste != null) {
-                return ste.getClassName();
-            }
-        }
-        return null;
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/AccessDeniedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/AccessDeniedExceptionHandler.java
deleted file mode 100644
index bdd22b67a3ac2c07aebba2ed6b7877d371430bf6..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/AccessDeniedExceptionHandler.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Set;
-
-import javax.servlet.http.HttpServletResponse;
-import javax.ws.rs.core.Context;
-import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.Response;
-import javax.ws.rs.core.UriInfo;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.security.access.AccessDeniedException;
-import org.springframework.security.core.context.SecurityContextHolder;
-import org.springframework.stereotype.Component;
-
-import org.slc.sli.api.resources.security.RealmResource;
-import org.slc.sli.api.security.SLIPrincipal;
-import org.slc.sli.api.security.SecurityEventBuilder;
-
-/**
- * Handler for catching access denied exceptions.
- *
- * @author shalka
- */
-@Provider
-@Component
-public class AccessDeniedExceptionHandler implements ExceptionMapper<AccessDeniedException> {
-
-    private static final Logger LOG = LoggerFactory.getLogger(AccessDeniedExceptionHandler.class);
-
-    public static final String ED_ORG_START = "<" ;
-    public static final String ED_ORG_END = ">" ;
-    public static final String NO_EDORG = "UNAVAILABLE";
-
-    @Autowired
-    private SecurityEventBuilder securityEventBuilder;
-
-    @Context
-    UriInfo uriInfo;
-
-    @Context
-    private HttpHeaders headers;
-
-    @Context
-    private HttpServletResponse response;
-
-    @Override
-    public Response toResponse(AccessDeniedException e) {
-
-        //There are a few jax-rs resources that generate HTML content, and we want the
-        //default web-container error handler pages to get used in those cases.
-        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
-            try {
-                response.sendError(403, e.getMessage());
-                return null;    //the error page handles the response, so no need to return a response
-            } catch (IOException ex) {
-                LOG.error("Error displaying error page", ex);
-            }
-        }
-
-        Response.Status errorStatus = Response.Status.FORBIDDEN;
-        SLIPrincipal principal = null ;
-        String message = e.getMessage();
-        if (SecurityContextHolder.getContext().getAuthentication() != null) {
-            principal = (SLIPrincipal)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
-            LOG.warn("Access has been denied to user: {}",principal );
-        } else {
-            LOG.warn("Access has been denied to user for being incorrectly associated");
-        }
-        LOG.warn("Cause: {}", e.getMessage());
-
-        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
-        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
-            errorType = MediaType.APPLICATION_XML_TYPE;
-        }
-        
-        return Response.status(errorStatus).entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), "Access DENIED: " + e.getMessage())).type(errorType).build();
-    }
-
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/ContextInferrenceFailedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/ContextInferrenceFailedExceptionHandler.java
deleted file mode 100644
index c9870ad462f3a3ae496413794d8daf8d07c6ee31..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/ContextInferrenceFailedExceptionHandler.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.slc.sli.api.representation;
-
-import java.util.Collections;
-
-import javax.ws.rs.core.Context;
-import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.Response;
-import javax.ws.rs.core.Response.Status;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-import javax.xml.bind.annotation.XmlRootElement;
-
-import org.slc.sli.api.security.pdp.ContextInferrenceFailedException;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.springframework.stereotype.Component;
-
-/**
- * Handles empty contexts
- * 
- * @author dkornishev
- * 
- */
-@Provider
-@Component
-public class ContextInferrenceFailedExceptionHandler implements ExceptionMapper<ContextInferrenceFailedException> {
-
-    private static final Logger LOG = LoggerFactory.getLogger(ContextInferrenceFailedExceptionHandler.class);
-
-    @Context
-    private HttpHeaders headers;
-    
-    @Override
-    public Response toResponse(ContextInferrenceFailedException exception) {
-        LOG.warn("Failed Context Inferrence");
-        Object entity = Collections.EMPTY_LIST;
-        if (headers.getAcceptableMediaTypes().contains(MediaType.APPLICATION_XML_TYPE)) {
-            entity = new EmptyResponse();
-        }
-        
-        return Response.status(Status.NOT_FOUND).entity(entity).header("TotalCount", 0).build();
-    }
-    
-    /**
-     * Represents an empty document to be returned to the API user (no fields, no data).
-     * 
-     * 
-     * @author kmyers
-     *
-     */
-    @XmlRootElement(name = "emptyList")
-    public static class EmptyResponse {
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/EOFExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/EOFExceptionHandler.java
deleted file mode 100644
index 08d53c6ba1a5114281ba0d1edb7f2767c01756f1..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/EOFExceptionHandler.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.slc.sli.api.representation;
-
-import java.io.EOFException;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.springframework.stereotype.Component;
-
-/**
- * Exception handler to catch cases where an EOF exception is thrown. This can be the case if a user
- * tries to post a null body
- *
- * @author nbrown
- *
- */
-@Provider
-@Component
-public class EOFExceptionHandler implements ExceptionMapper<EOFException> {
-
-    @Override
-    public Response toResponse(EOFException exception) {
-        return Response.status(Response.Status.BAD_REQUEST).build();
-    }
-
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/EmbeddedDocumentLimitExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/EmbeddedDocumentLimitExceptionHandler.java
deleted file mode 100644
index 70226ff318fd84407ed58889d03ee07489d9b231..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/EmbeddedDocumentLimitExceptionHandler.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.slc.sli.api.selectors.doc.EmbeddedDocumentLimitException;
-import org.springframework.stereotype.Component;
-
-/**
- * @author jstokes
- */
-@Provider
-@Component
-public class EmbeddedDocumentLimitExceptionHandler implements ExceptionMapper<EmbeddedDocumentLimitException> {
-
-    @Override
-    public Response toResponse(EmbeddedDocumentLimitException e) {
-        return Response
-                .status(CustomStatus.ENTITY_TOO_LARGE)
-                .entity(new ErrorResponse(CustomStatus.ENTITY_TOO_LARGE.getStatusCode(), CustomStatus.ENTITY_TOO_LARGE.getReasonPhrase(),
-                        e.getMessage())).build();
-    }
-}
-
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/EntityNotFoundHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/EntityNotFoundHandler.java
deleted file mode 100644
index e75f6d063d066c785eba22c8c554749e90a7492e..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/EntityNotFoundHandler.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.springframework.stereotype.Component;
-
-import org.slc.sli.api.service.EntityNotFoundException;
-
-/**
- * Hander for entity not found errors
- */
-@Provider
-@Component
-public class EntityNotFoundHandler implements ExceptionMapper<EntityNotFoundException> {
-
-    public Response toResponse(EntityNotFoundException e) {
-        Response.Status errorStatus = Response.Status.NOT_FOUND;
-        return Response
-                .status(errorStatus)
-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
-                        "Entity not found: " + e.getId())).build();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/GenericExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/GenericExceptionHandler.java
deleted file mode 100644
index f0d4f30ec8609b42267f54ac8b594c27506a3b94..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/GenericExceptionHandler.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import java.io.IOException;
-
-import javax.servlet.http.HttpServletResponse;
-import javax.ws.rs.core.Context;
-import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.springframework.stereotype.Component;
-
-/**
- * Hander for uncaught errors
- */
-@Provider
-@Component
-public class GenericExceptionHandler implements ExceptionMapper<Throwable> {
-
-    private static final Logger LOG = LoggerFactory.getLogger(GenericExceptionHandler.class);
-    
-    @Context
-    private HttpHeaders headers;
-    
-    @Context
-    private HttpServletResponse response;
-
-    @Override
-    public Response toResponse(Throwable e) {
-
-        //There are a few jax-rs resources that generate HTML content, and we want the
-        //default web-container error handler pages to get used in those cases.
-        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
-            try {
-                LOG.error(e.getMessage(), e);
-                response.sendError(500, e.getMessage());
-                return null;    //the error page handles the response, so no need to return a response
-            } catch (IOException ex) {
-                LOG.error("Error displaying error page", ex);
-            }
-        }
-        Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;
-        
-        LOG.error("Caught exception thrown by ReST handler", e);
-        return Response
-                .status(errorStatus)
-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
-                        "Internal Server Error: " + e.getMessage())).build();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/IllegalArgumentExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/IllegalArgumentExceptionHandler.java
deleted file mode 100644
index d19651eea8f3b5aad8de1c09f4689b59c72c7183..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/IllegalArgumentExceptionHandler.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.core.Response.Status;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.springframework.stereotype.Component;
-
-/**
- * Handles bad requests
-  */
-@Provider
-@Component
-public class IllegalArgumentExceptionHandler implements ExceptionMapper<IllegalArgumentException> {
-
-    @Override
-    public Response toResponse(IllegalArgumentException e) {
-        return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/InsufficientAuthenticationHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/InsufficientAuthenticationHandler.java
deleted file mode 100644
index 6ad4696871e92747ece0dd4037949423e1d4ad73..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/InsufficientAuthenticationHandler.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.*;
-import javax.ws.rs.core.Response.Status;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.slc.sli.api.security.SecurityEventBuilder;
-import org.slc.sli.api.security.oauth.OAuthAccessException;
-import org.slc.sli.api.security.service.AuditLogger;
-import org.springframework.beans.factory.annotation.Autowired;
-import org.springframework.beans.factory.annotation.Value;
-import org.springframework.security.authentication.InsufficientAuthenticationException;
-import org.springframework.stereotype.Component;
-
-import java.net.URI;
-
-/**
- * Translates InsufficientAuthenticationException to 401
- *
- * @author dkornishev
- *
- */
-@Component
-@Provider
-public class InsufficientAuthenticationHandler implements ExceptionMapper<InsufficientAuthenticationException> {
-
-    @Value("${sli.security.noSession.landing.url}")
-    private String authUrl;
-
-    @Autowired
-    private SecurityEventBuilder securityEventBuilder;
-
-    @Autowired
-    private AuditLogger auditLogger;
-
-    @Context
-    UriInfo uriInfo;
-
-    @Context
-    private HttpHeaders headers;
-
-    @Override
-    public Response toResponse(InsufficientAuthenticationException exception) {
-        Status status = Response.Status.UNAUTHORIZED;
-        String wwwAuthHeader = this.authUrl;
-        URI requestUri = (uriInfo == null) ? null : uriInfo.getRequestUri();
-
-        //If we have an embedded OAuth exception, then put the error information in the www-auth header per oauth spec 
-        //http://tools.ietf.org/html/rfc6750 see sec 3
-        //Otherwise put the auth url in the header
-        if (exception.getCause() != null && exception.getCause() instanceof OAuthAccessException) {
-            OAuthAccessException oauthEx = (OAuthAccessException) exception.getCause();
-            wwwAuthHeader = "Bearer error=\"" + oauthEx.getType().toString() + "\", error_description=\"" + oauthEx.getMessage() + "\"";
-        }
-        
-        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
-        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
-            errorType = MediaType.APPLICATION_XML_TYPE;
-        }
-
-        auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(exception), requestUri, "Access Denied: "
-                + exception.getMessage(), false));
-
-        return Response.status(status).entity(new ErrorResponse(status.getStatusCode(), status.getReasonPhrase(),
-                "Access DENIED: " + exception.getMessage())).header(HttpHeaders.WWW_AUTHENTICATE, wwwAuthHeader).type(errorType).build();
-    }
-
-    private String getThrowingClassName(Exception e) {
-        if (e != null && e.getStackTrace() != null) {
-            StackTraceElement ste = e.getStackTrace()[0];
-            if (ste != null) {
-                return ste.getClassName();
-            }
-        }
-        return null;
-    }
-
-    public void setSecurityEventBuilder(SecurityEventBuilder securityEventBuilder) {
-        this.securityEventBuilder = securityEventBuilder;
-    }
-
-    public void setAuditLogger(AuditLogger auditLogger) {
-        this.auditLogger = auditLogger;
-    }
-
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/JsonParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/JsonParseExceptionHandler.java
deleted file mode 100644
index 39de01c743477a87bac40bd5d4fa7649cfd8087e..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/JsonParseExceptionHandler.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.codehaus.jackson.JsonParseException;
-import org.springframework.stereotype.Component;
-
-/**
- * Exception handler for SortingExceptions
- * 
- * @author Ryan Farris <rfarris@wgen.net>
- * 
- */
-@Provider
-@Component
-public class JsonParseExceptionHandler implements ExceptionMapper<JsonParseException> {
-    
-    @Override
-    public Response toResponse(JsonParseException e) {
-        Response.Status errorStatus = Response.Status.BAD_REQUEST;
-        return Response.status(errorStatus)
-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), e.getMessage()))
-                .build();
-    }
-    
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/MethodNotAllowedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/MethodNotAllowedExceptionHandler.java
deleted file mode 100644
index efa954be4f2565051ac9dd8ddeef75b3714e79cf..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/MethodNotAllowedExceptionHandler.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.slc.sli.api.representation;
-
-import org.slc.sli.api.resources.generic.MethodNotAllowedException;
-import org.springframework.stereotype.Component;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-/**
- * Exception mapper for dis allowed methods
- *
- * @author srupasinghe
- */
-
-@Provider
-@Component
-public class MethodNotAllowedExceptionHandler implements ExceptionMapper<MethodNotAllowedException> {
-
-    public Response toResponse(MethodNotAllowedException e) {
-        String message = "Method Not Allowed [" + e.getAllowedMethods() + "]";
-
-        Response.ResponseBuilder builder =  Response
-                .status(405)
-                .entity(new ErrorResponse(405, "Method Not Allowed",
-                        message));
-
-        builder.header("Allow", "Allow: " + e.getAllowedMethods());
-
-        return builder.build();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/NaturalKeyValidationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/NaturalKeyValidationExceptionHandler.java
deleted file mode 100644
index 09afc945ee2e920f894ed727bc4bf87c122a47bb..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/NaturalKeyValidationExceptionHandler.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.slc.sli.api.representation;
-
-import org.apache.commons.lang3.StringUtils;
-import org.slc.sli.validation.NaturalKeyValidationException;
-import org.springframework.stereotype.Component;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-/**
- * Exception mapper NaturalKeyValidationExceptions
- *
- * @author srupasinghe
- */
-@Provider
-@Component
-public class NaturalKeyValidationExceptionHandler implements ExceptionMapper<NaturalKeyValidationException> {
-
-    public Response toResponse(NaturalKeyValidationException e) {
-        String exceptionMessage = "Natural Key Validation failed: " + e.getEntityType() + " " + StringUtils.join(e.getNaturalKeys());
-        return Response
-                .status(Response.Status.CONFLICT)
-                .entity(new ErrorResponse(Response.Status.CONFLICT.getStatusCode(), Response.Status.CONFLICT.getReasonPhrase(),
-                        exceptionMessage)).build();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/OAuthAccessExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/OAuthAccessExceptionHandler.java
deleted file mode 100644
index ac8836cd54f4ed617780a10d8d9346e4418499f6..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/OAuthAccessExceptionHandler.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.springframework.stereotype.Component;
-import org.springframework.stereotype.Repository;
-
-import org.slc.sli.api.security.oauth.OAuthAccessException;
-import org.slc.sli.api.security.oauth.OAuthAccessException.OAuthError;
-
-/**
- *
- * Handle oauth access exceptions as described in 5.2
- */
-@Component
-@Provider
-@Repository
-public class OAuthAccessExceptionHandler implements ExceptionMapper<OAuthAccessException>  {
-
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public Response toResponse(OAuthAccessException ex) {
-
-        Response.Status errorStatus = null;
-
-        if (ex.getType() == OAuthError.UNAUTHORIZED_CLIENT) {
-            errorStatus = Response.Status.FORBIDDEN;
-        } else {
-            errorStatus = Response.Status.BAD_REQUEST;
-        }
-
-        @SuppressWarnings("rawtypes")
-        Map data = new HashMap();
-        data.put("error", ex.getType().toString());
-        data.put("error_description", ex.getMessage());
-        if (ex.getState() != null) {
-            data.put("state", ex.getState());
-        }
-        return Response.status(errorStatus).entity(data).build();
-
-    }
-
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/PreConditionExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/PreConditionExceptionHandler.java
deleted file mode 100644
index 56aaaad517568a491576510d84d5cc455b5baded..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/PreConditionExceptionHandler.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.slc.sli.api.representation;
-
-import org.slc.sli.api.resources.generic.PreConditionFailedException;
-import org.springframework.stereotype.Component;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-/**
- * Exception mapper for precondition failures
- *
- * @author srupasinghe
- */
-
-@Provider
-@Component
-public class PreConditionExceptionHandler implements ExceptionMapper<PreConditionFailedException> {
-
-    public Response toResponse(PreConditionFailedException e) {
-
-        return Response
-                .status(Response.Status.PRECONDITION_FAILED)
-                .entity(new ErrorResponse(Response.Status.PRECONDITION_FAILED.getStatusCode(), Response.Status.PRECONDITION_FAILED.getReasonPhrase(),
-                        e.getMessage())).build();
-
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/QueryParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/QueryParseExceptionHandler.java
deleted file mode 100644
index ab9459c40597aed5b6f7c7a6ec8878ef1975577f..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/QueryParseExceptionHandler.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.springframework.stereotype.Component;
-
-import org.slc.sli.domain.QueryParseException;
-
-/**
- * Handler for Query Parsing errors
- */
-@Provider
-@Component
-public class QueryParseExceptionHandler implements ExceptionMapper<QueryParseException> {
-    
-    public Response toResponse(QueryParseException e) {
-        Response.Status errorStatus = Response.Status.BAD_REQUEST;
-        return Response
-                .status(errorStatus)
-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
-                        "Error Parsing the Query: " + e.getMessage())).build();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/ResponseTooLargeExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/ResponseTooLargeExceptionHandler.java
deleted file mode 100644
index fac30131a8864868303cf3e09ff6531179d88147..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/ResponseTooLargeExceptionHandler.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.slc.sli.api.security.context.ResponseTooLargeException;
-import org.springframework.stereotype.Component;
-
-/**
- * Hander for when the request is too large to manage
- */
-@Provider
-@Component
-public class ResponseTooLargeExceptionHandler implements ExceptionMapper<ResponseTooLargeException> {
-    
-    @Override
-    public Response toResponse(ResponseTooLargeException exception) {
-        
-        return Response
-                .status(CustomStatus.ENTITY_TOO_LARGE)
-                .entity(new ErrorResponse(CustomStatus.ENTITY_TOO_LARGE.getStatusCode(), CustomStatus.ENTITY_TOO_LARGE.getReasonPhrase(),
-                        "The request is too large to resolve.")).build();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/SelectorParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/SelectorParseExceptionHandler.java
deleted file mode 100644
index 45cb7fafe018494c884df52484fb81344f8ac73d..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/SelectorParseExceptionHandler.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.slc.sli.api.representation;
-
-import org.slc.sli.api.selectors.model.SelectorParseException;
-import org.springframework.stereotype.Component;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.core.Response.Status;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-/**
- * @author jstokes
- */
-@Provider
-@Component
-public class SelectorParseExceptionHandler implements ExceptionMapper<SelectorParseException> {
-
-    public Response toResponse(SelectorParseException e) {
-        return Response
-                .status(Response.Status.BAD_REQUEST)
-                .entity(new ErrorResponse(Status.BAD_REQUEST.getStatusCode(), Status.BAD_REQUEST.getReasonPhrase(),
-                        e.getMessage())).build();
-    }
-}
-
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/SortingExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/SortingExceptionHandler.java
deleted file mode 100644
index 7fb9abb8f3b9630110e8d88303e0a969f8b67729..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/SortingExceptionHandler.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.springframework.stereotype.Component;
-
-import org.slc.sli.api.service.query.SortingException;
-
-/**
- * Exception handler for SortingExceptions
- * 
- * @author Ryan Farris <rfarris@wgen.net>
- * 
- */
-@Provider
-@Component
-public class SortingExceptionHandler implements ExceptionMapper<SortingException> {
-    
-    @Override
-    public Response toResponse(SortingException e) {
-        Response.Status errorStatus = Response.Status.BAD_REQUEST;
-        return Response.status(errorStatus)
-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), e.getMessage()))
-                .build();
-    }
-    
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/UncategorizedMongoExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/UncategorizedMongoExceptionHandler.java
deleted file mode 100644
index 4c39d623298ae71cfc1f11a4398b628cac9c93be..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/UncategorizedMongoExceptionHandler.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.core.Response.Status;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.springframework.data.mongodb.UncategorizedMongoDbException;
-import org.springframework.stereotype.Component;
-
-/**
- * Handle connection issues to mongo
- *
- * @author nbrown
- *
- */
-@Provider
-@Component
-public class UncategorizedMongoExceptionHandler implements ExceptionMapper<UncategorizedMongoDbException> {
-
-    private static final Logger LOG = LoggerFactory.getLogger(UncategorizedMongoExceptionHandler.class);
-
-    @Override
-    public Response toResponse(UncategorizedMongoDbException exception) {
-        Status errorStatus = Status.SERVICE_UNAVAILABLE;
-        LOG.error("Could not access database", exception);
-        return Response
-                .status(errorStatus)
-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
-                        "Could not access database:" + exception.getMessage())).build();
-    }
-
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/ValidationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/ValidationExceptionHandler.java
deleted file mode 100644
index 41203772c8243a1ed9b74d8c804f96e3ec8ab0ee..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/ValidationExceptionHandler.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.core.Response;
-import javax.ws.rs.core.Response.Status;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.apache.commons.lang3.StringUtils;
-import org.springframework.stereotype.Component;
-
-import org.slc.sli.validation.EntityValidationException;
-
-/**
- * Hander for validation errors
- */
-@Provider
-@Component
-public class ValidationExceptionHandler implements ExceptionMapper<EntityValidationException> {
-
-    public Response toResponse(EntityValidationException e) {
-        String exceptionMessage = "Validation failed: " + StringUtils.join(e.getValidationErrors(), "\n");
-        return Response
-                .status(Response.Status.BAD_REQUEST)
-                .entity(new ErrorResponse(Status.BAD_REQUEST.getStatusCode(), Status.BAD_REQUEST.getReasonPhrase(),
-                        exceptionMessage)).build();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/WebApplicationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/WebApplicationExceptionHandler.java
deleted file mode 100644
index bfb6b24db615d51597c3b262d3fa4270bf144602..0000000000000000000000000000000000000000
--- a/sli/api/src/main/java/org/slc/sli/api/representation/WebApplicationExceptionHandler.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.slc.sli.api.representation;
-
-import javax.ws.rs.WebApplicationException;
-import javax.ws.rs.core.Response;
-import javax.ws.rs.ext.ExceptionMapper;
-import javax.ws.rs.ext.Provider;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.springframework.stereotype.Component;
-
-/**
- * Hander for jax-rs web application exceptions
- */
-@Provider
-@Component
-public class WebApplicationExceptionHandler implements ExceptionMapper<WebApplicationException> {
-
-    public static final Logger LOG = LoggerFactory.getLogger(WebApplicationExceptionHandler.class);
-    
-    @Override
-    public Response toResponse(WebApplicationException e) {
-        if (e.getResponse().getStatus() == 500) {
-            LOG.error("Caught exception thrown by ReST handler", e);
-            Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;
-            
-            return Response
-                    .status(errorStatus)
-                    .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
-                            "Internal Server Error: " + e.getMessage())).build();
-        }
-        return e.getResponse();
-    }
-}
diff --git a/sli/api/src/main/java/org/slc/sli/api/resources/security/AdminDelegationResource.java b/sli/api/src/main/java/org/slc/sli/api/resources/security/AdminDelegationResource.java
index 2edc43fd6c25d7c142eef71dd6db5c7a07f0965e..516f40c4b3cddab4228ede44cde7961242b7d6aa 100644
--- a/sli/api/src/main/java/org/slc/sli/api/resources/security/AdminDelegationResource.java
+++ b/sli/api/src/main/java/org/slc/sli/api/resources/security/AdminDelegationResource.java
@@ -23,8 +23,8 @@ import org.slc.sli.api.representation.EntityBody;
 import org.slc.sli.api.resources.v1.HypermediaType;
 import org.slc.sli.api.security.RightsAllowed;
 import org.slc.sli.api.security.SecurityEventBuilder;
+import org.slc.sli.api.security.context.APIAccessDeniedException;
 import org.slc.sli.api.security.service.AuditLogger;
-import org.slc.sli.api.service.EntityNotFoundException;
 import org.slc.sli.api.service.EntityService;
 import org.slc.sli.api.util.SecurityUtil;
 import org.slc.sli.common.util.logging.SecurityEvent;
@@ -108,7 +108,7 @@ public class AdminDelegationResource {
 
             String edOrg = SecurityUtil.getEdOrg();
             if (edOrg == null) {
-                throw new EntityNotFoundException("No edorg exists on principal.");
+                throw new APIAccessDeniedException("Can not grant access because no edOrg exists on principal.");
             }
 
             List<Map<String, Object>> results = new ArrayList<Map<String, Object>>();
@@ -205,14 +205,14 @@ public class AdminDelegationResource {
     private EntityBody getDelegationRecordForPrincipal() {
         String edOrgId = SecurityUtil.getEdOrgId();
         if (edOrgId == null) {
-            throw new EntityNotFoundException("No edorg exists on principal.");
+            throw new APIAccessDeniedException("Can not grant access because no edOrg exists on principal.");
         }
 
         NeutralQuery query = new NeutralQuery();
         query.addCriteria(new NeutralCriteria(LEA_ID, "=", edOrgId));
         Iterator<EntityBody> it = service.list(query).iterator();
         //Iterator<String> it = service.listIds(query).iterator();
-        if (it.hasNext()){
+        if (it.hasNext()) {
             return it.next();
         } else {
             return null;
diff --git a/sli/api/src/main/java/org/slc/sli/api/resources/security/RealmResource.java b/sli/api/src/main/java/org/slc/sli/api/resources/security/RealmResource.java
index 7b606b4f8c5d67a5017049ae3355b87d994525c3..fc357e7409daaa3a3d801b8f794bb915910ebd43 100644
--- a/sli/api/src/main/java/org/slc/sli/api/resources/security/RealmResource.java
+++ b/sli/api/src/main/java/org/slc/sli/api/resources/security/RealmResource.java
@@ -136,7 +136,7 @@ public class RealmResource {
             @Context final UriInfo uriInfo) {
 
         if (updatedRealm == null) {
-            throw new EntityNotFoundException("Entity was null");
+            throw new IllegalArgumentException("Updated Realm was null");
         }
 
         EntityBody oldRealm = service.get(realmId);
diff --git a/sli/api/src/main/java/org/slc/sli/api/search/service/SearchResourceService.java b/sli/api/src/main/java/org/slc/sli/api/search/service/SearchResourceService.java
index 78261fa4671787c8f799acbf10723fc420dc58be..cd3ed537f93720187a8fff6b7396ee342667fd88 100644
--- a/sli/api/src/main/java/org/slc/sli/api/search/service/SearchResourceService.java
+++ b/sli/api/src/main/java/org/slc/sli/api/search/service/SearchResourceService.java
@@ -43,6 +43,7 @@ import org.elasticsearch.common.settings.ImmutableSettings;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.node.Node;
 import org.elasticsearch.node.NodeBuilder;
+import org.slc.sli.api.exceptions.EntityTypeNotFoundException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -68,7 +69,6 @@ import org.slc.sli.api.security.SLIPrincipal;
 import org.slc.sli.api.security.context.ContextValidator;
 import org.slc.sli.api.security.context.resolver.EdOrgHelper;
 import org.slc.sli.api.security.context.validator.IContextValidator;
-import org.slc.sli.api.service.EntityNotFoundException;
 import org.slc.sli.api.service.EntityService;
 import org.slc.sli.api.service.query.ApiQuery;
 import org.slc.sli.common.constants.EntityNames;
@@ -393,7 +393,7 @@ public class SearchResourceService {
       for (String resourceName : resourceNames.split(",")) {
          def = resourceHelper.getEntityDefinition(resourceName);
          if (def == null || !searchEntityDefinition.getService().collectionExists(def.getType())) {
-            throw new EntityNotFoundException(resourceName);
+            throw new EntityTypeNotFoundException(resourceName);
          }
          entityTypes.add(def.getType());
       }
diff --git a/sli/api/src/main/java/org/slc/sli/api/security/context/ContextValidator.java b/sli/api/src/main/java/org/slc/sli/api/security/context/ContextValidator.java
index c54678087f96c7389dda14651c7e57e07e58cc80..843abf25180c7fc516c0f7848521ba2f6ed7eba2 100644
--- a/sli/api/src/main/java/org/slc/sli/api/security/context/ContextValidator.java
+++ b/sli/api/src/main/java/org/slc/sli/api/security/context/ContextValidator.java
@@ -393,36 +393,47 @@ public class ContextValidator implements ApplicationContextAware {
     */
     protected Set<String> getEntityIdsToValidate(EntityDefinition def, Collection<Entity> entities, boolean isTransitive, Collection<String> ids)
                           throws APIAccessDeniedException, EntityNotFoundException {
-         int found = 0;
-         Set<String> entityIdsToValidate = new HashSet<String>();
-            for (Entity ent : entities) {
-                found++;
-                Collection<String> userEdOrgs = edOrgHelper.getDirectEdorgs(ent);
-                if (isOrphanCreatedByUser(ent)) {
-                    LOG.debug("Entity is orphaned: id {} of type {}", ent.getEntityId(), ent.getType());
-                } else if (SecurityUtil.getSLIPrincipal().getEntity() != null
+        Set<String> entityIdsToValidate = new HashSet<String>();
+        for (Entity ent : entities) {
+            Collection<String> userEdOrgs = edOrgHelper.getDirectEdorgs(ent);
+            if (isOrphanCreatedByUser(ent)) {
+                LOG.debug("Entity is orphaned: id {} of type {}", ent.getEntityId(), ent.getType());
+            } else if (SecurityUtil.getSLIPrincipal().getEntity() != null
                         && SecurityUtil.getSLIPrincipal().getEntity().getEntityId().equals(ent.getEntityId())) {
-                    LOG.debug("Entity is themselves: id {} of type {}", ent.getEntityId(), ent.getType());
+                LOG.debug("Entity is themselves: id {} of type {}", ent.getEntityId(), ent.getType());
+            } else {
+                if (ownership.canAccess(ent, isTransitive)) {
+                    entityIdsToValidate.add(ent.getEntityId());
                 } else {
-                    if (ownership.canAccess(ent, isTransitive)) {
-                        entityIdsToValidate.add(ent.getEntityId());
-                    } else {
-                        throw new APIAccessDeniedException("Access to " + ent.getEntityId() + " is not authorized", userEdOrgs);
-                    }
+                    throw new APIAccessDeniedException("Access to " + ent.getEntityId() + " is not authorized", userEdOrgs);
                 }
             }
+        }
 
-            if (found != ids.size()) {
-                LOG.debug("Invalid reference, an entity does not exist. collection: {} entities: {}",
-                        def.getStoredCollectionName(), entities);
-                throw new EntityNotFoundException("Could not locate " + def.getType() + " with ids " + ids);
+        // report an EntityNotFoundException on the id we find without a corresponding entity
+        // so that we don't use the constructor for EntityNotFoundException incorrectly
+        if (entities.size() != ids.size()) {
+            for (String id : ids ) {
+                boolean foundentity = false;
+                for (Entity ent : entities) {
+                    if (ent.getEntityId().contains(id)){
+                    	foundentity = true;
+                    	break;
+                    }
+                }
+                if (!foundentity) {
+                    LOG.debug("Invalid reference, an entity does not exist. collection: {} entities: {}",
+                            def.getStoredCollectionName(), entities);
+                    throw new EntityNotFoundException(id);
+                }
             }
+        }
 
-         return entityIdsToValidate;
-       }
+        return entityIdsToValidate;
+    }
 
     /**
-     * Returns true is the entity is an orphan that is created by the user, false otherwise
+     * Returns true if the entity is an orphan that is created by the user, false otherwise
      *
      * @param entity - Collection of entities to filter for validation
      *
diff --git a/sli/api/src/main/java/org/slc/sli/api/security/oauth/AuthController.java b/sli/api/src/main/java/org/slc/sli/api/security/oauth/AuthController.java
index 9dfc519dd359f2fc8df11edb584b335acc72764f..6ec4b13a21353fc4af89088662a0a59e6148368b 100644
--- a/sli/api/src/main/java/org/slc/sli/api/security/oauth/AuthController.java
+++ b/sli/api/src/main/java/org/slc/sli/api/security/oauth/AuthController.java
@@ -28,7 +28,7 @@ import javax.ws.rs.core.Response;
 import org.apache.commons.lang3.tuple.Pair;
 import org.codehaus.jackson.map.ObjectMapper;
 import org.slc.sli.api.init.RealmInitializer;
-import org.slc.sli.api.representation.OAuthAccessExceptionHandler;
+import org.slc.sli.api.jersey.exceptionhandlers.OAuthAccessExceptionHandler;
 import org.slc.sli.api.security.OauthSessionManager;
 import org.slc.sli.api.security.saml.SamlHelper;
 import org.slc.sli.api.util.SecurityUtil;
diff --git a/sli/api/src/main/java/org/slc/sli/api/security/pdp/MutatedContainer.java b/sli/api/src/main/java/org/slc/sli/api/security/pdp/MutatedContainer.java
index 01f1085df74a629008e5650ad6a57891bbcca202..ed1f89fc6d25a2e8adf8576e39b2de1edf002514 100644
--- a/sli/api/src/main/java/org/slc/sli/api/security/pdp/MutatedContainer.java
+++ b/sli/api/src/main/java/org/slc/sli/api/security/pdp/MutatedContainer.java
@@ -23,63 +23,79 @@ import org.apache.commons.lang.builder.HashCodeBuilder;
 
 public class MutatedContainer {
 
-    private String path = null;
-    private String queryParameters = null;
-    private Map<String, String> headers = null;
-    private boolean isModified = false;
-
-    public String getPath() {
-        return path;
-    }
-    public void setPath(String path) {
-        this.path = path;
-        isModified = true;
-    }
-    public String getQueryParameters() {
-        return queryParameters;
-    }
-    public void setQueryParameters(String queryParameters) {
-        this.queryParameters = queryParameters;
-        isModified = true;
-    }
-    public Map<String, String> getHeaders() {
-        return headers;
-    }
-    public void setHeaders(Map<String, String> headers) {
-        this.headers = headers;
-        isModified = true;
-    }
-
-    public boolean isModified() {
-        return isModified;
-    }
-
-    @Override
-    public int hashCode() {
-        return new HashCodeBuilder(17, 31). // two randomly chosen prime numbers
-            append(path).
-            append(queryParameters).
-            append(headers).
-            toHashCode();
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (obj == this) {
-            return true;
-        }
-        if (obj.getClass() != getClass()) {
-            return false;
-        }
-
-        MutatedContainer rhs = (MutatedContainer) obj;
-        return new EqualsBuilder().
-            append(path, rhs.path).
-            append(queryParameters, rhs.queryParameters).
-            append(headers, rhs.headers).
-            isEquals();
-    }
+	private String path = null;
+	private String queryParameters = null;
+	private Map<String, String> headers = null;
+	private boolean isModified = false;
+
+	public String getPath() {
+		return path;
+	}
+
+	public void setPath(String path) {
+		this.path = path;
+		isModified = true;
+	}
+
+	public String getQueryParameters() {
+		return queryParameters;
+	}
+
+	public void setQueryParameters(String queryParameters) {
+		this.queryParameters = queryParameters;
+		isModified = true;
+	}
+
+	public Map<String, String> getHeaders() {
+		return headers;
+	}
+
+	public void setHeaders(Map<String, String> headers) {
+		this.headers = headers;
+		isModified = true;
+	}
+
+	public boolean isModified() {
+		return isModified;
+	}
+
+	@Override
+	public int hashCode() {
+		return new HashCodeBuilder(17, 31)
+				. // two randomly chosen prime numbers
+				append(path).append(queryParameters).append(headers)
+				.toHashCode();
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (obj == null) {
+			return false;
+		}
+		if (obj == this) {
+			return true;
+		}
+		if (obj.getClass() != getClass()) {
+			return false;
+		}
+
+		MutatedContainer rhs = (MutatedContainer) obj;
+		return new EqualsBuilder().append(path, rhs.path)
+				.append(queryParameters, rhs.queryParameters)
+				.append(headers, rhs.headers).isEquals();
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder builder = new StringBuilder();
+		if (path == null) {
+			builder.append("/home");
+		} else {
+			builder.append(path);
+		}
+		builder.append("/" + queryParameters);
+		builder.append(headers);
+		return builder.toString();
+	}
+
 }
diff --git a/sli/api/src/main/java/org/slc/sli/api/security/pdp/UriMutator.java b/sli/api/src/main/java/org/slc/sli/api/security/pdp/UriMutator.java
index ea70732cea4de231e8078033ad855a9b617d9cec..bba9c49f8b01378f7a43f717aaaad7ab1f60a133 100644
--- a/sli/api/src/main/java/org/slc/sli/api/security/pdp/UriMutator.java
+++ b/sli/api/src/main/java/org/slc/sli/api/security/pdp/UriMutator.java
@@ -33,6 +33,7 @@ import javax.ws.rs.core.PathSegment;
 
 import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.lang3.tuple.Pair;
+import org.slc.sli.api.exceptions.UriMutationException;
 import org.slc.sli.api.resources.security.ApplicationResource;
 import org.slc.sli.api.security.RightsAllowed;
 import org.slc.sli.domain.enums.Right;
@@ -50,11 +51,9 @@ import org.slc.sli.api.constants.PathConstants;
 import org.slc.sli.api.constants.ResourceNames;
 import org.slc.sli.api.security.SLIPrincipal;
 import org.slc.sli.api.security.context.APIAccessDeniedException;
-import org.slc.sli.api.security.context.ResponseTooLargeException;
 import org.slc.sli.api.security.context.resolver.EdOrgHelper;
 import org.slc.sli.api.security.context.resolver.GradingPeriodHelper;
 import org.slc.sli.api.security.context.resolver.SectionHelper;
-import org.slc.sli.api.service.EntityNotFoundException;
 import org.slc.sli.api.util.SecurityUtil;
 import org.slc.sli.api.util.SessionUtil;
 import org.slc.sli.common.constants.EntityNames;
@@ -66,1294 +65,1711 @@ import org.slc.sli.domain.NeutralQuery;
 import org.slc.sli.domain.Repository;
 
 /**
- * Infers context about the {user,requested resource} pair, and restricts blanket API calls to
- * smaller (and generally more manageable) scope.
+ * Infers context about the {user,requested resource} pair, and restricts
+ * blanket API calls to smaller (and generally more manageable) scope.
  */
 @Component
 public class UriMutator {
-    
-    private static final Logger LOG = LoggerFactory.getLogger(UriMutator.class);
-
-    public static final int NUM_SEGMENTS_IN_TWO_PART_REQUEST = 3;
-    public static final int NUM_SEGMENTS_IN_ONE_PART_REQUEST = 2;
-
-    @Resource
-    private EdOrgHelper edOrgHelper;
-
-    @Resource
-    private SectionHelper sectionHelper;
-
-    @Resource
-    private RootSearchMutator rootSearchMutator;
-
-    @Autowired
-    @Qualifier("validationRepo")
-    private Repository<Entity> repo;
-
-    @Autowired
-    private BasicDefinitionStore definitionStore;
-
-    @Autowired
-    private DateHelper dateHelper;
-
-    private Map<String, MutateInfo> teacherSectionMutations;
-
-    @Autowired
-    private GradingPeriodHelper gradingPeriodHelper;
-
-    @SuppressWarnings("unchecked")
-    private static final List<Pair<String, String>> PARAMETER_RESOURCE_PAIRS = Arrays.asList(
-            Pair.of(ParameterConstants.STUDENT_UNIQUE_STATE_ID, ResourceNames.STUDENTS),
-            Pair.of(ParameterConstants.STAFF_UNIQUE_STATE_ID, ResourceNames.STAFF),
-            Pair.of(ParameterConstants.PARENT_UNIQUE_STATE_ID, ResourceNames.PARENTS),
-            Pair.of(ParameterConstants.STATE_ORGANIZATION_ID, ResourceNames.EDUCATION_ORGANIZATIONS));
-
-    /**
-     * Acts as a filter to determine if the requested resource, given knowledge of the user
-     * requesting it, should be rewritten. Returning null indicates that the URI should NOT be
-     * rewritten.
-     *
-     * @param segments
-     *            List of Path Segments representing request URI.
-     * @param queryParameters
-     *            String containing query parameters.
-     * @param user
-     *            User requesting resource.
-     * @return MutatedContainer representing {mutated path (if necessary), mutated
-     *         parameters (if necessary)}, where path will be null or parameters the empty string if they didn't need
-     *         to be rewritten.
-     */
-    public MutatedContainer mutate(List<PathSegment> segments, String queryParameters, SLIPrincipal principal, String clientId) {
-        Entity user = principal.getEntity();
-        MutatedContainer mutated = new MutatedContainer();
-        mutated.setQueryParameters(queryParameters);
-        if (mutated.getQueryParameters() == null) {
-            mutated.setQueryParameters("");
-        }
-
-        Map<String, String> parameters = MutatorUtil.getParameterMap(mutated.getQueryParameters());
-        for (Pair<String, String> parameterResourcePair : PARAMETER_RESOURCE_PAIRS) {
-            String parameter = parameterResourcePair.getLeft();
-            String resource = parameterResourcePair.getRight();
-            if (parameters.containsKey(parameter)) {
-                EntityDefinition definition = definitionStore.lookupByResourceName(resource);
-                if (definition != null) {
-                    NeutralQuery query = new NeutralQuery(new NeutralCriteria(parameter,
-                            NeutralCriteria.OPERATOR_EQUAL, parameters.get(parameter)));
-                    Entity e = repo.findOne(definition.getType(), query);
-                    if (e != null) {
-                        MutatedContainer newMutated = new MutatedContainer();
-                        String path = String.format("/%s/%s", resource, e.getEntityId());
-                        if (EntityNames.TEACHER.equals(e.getType())) {
-                            path = String.format("/teachers/%s", e.getEntityId());
-                        } else if (EntityNames.STAFF.equals(e.getType())) {
-                            path = String.format("/staff/%s", e.getEntityId());
-                        }
-                        newMutated.setPath(path);
-
-                        LOG.info("Rewriting URI to {} based on natural keys", newMutated.getPath());
-                        return newMutated;
-                    }
-                }
-            }
-        }
-
-        mutated.setPath(null);
-        mutated.setQueryParameters(queryParameters);
-        MutatedContainer generalMutation = doGeneralMutations(stringifyPathSegments(segments), queryParameters, user);
-
-        if( generalMutation != null) {
-          mutated = generalMutation;
-        }
-        else if (segments.size() < NUM_SEGMENTS_IN_TWO_PART_REQUEST) {
-
-            if (!shouldSkipMutation(segments, mutated.getQueryParameters(), principal, clientId)) {
-                if (segments.size() == 1) {
-                    // api/v1
-                    mutated = mutateBaseUri(segments.get(0).getPath(), ResourceNames.HOME,
-                            mutated.getQueryParameters(), user);
-                } else {
-                    mutated = mutateBaseUri(segments.get(0).getPath(), segments.get(1).getPath(),
-                            mutated.getQueryParameters(), user);
-                }
-            }
-        } else {
-            mutated = mutateUriAsNecessary(segments, mutated.getQueryParameters(), user);
-        }
-
-        return mutated;
-    }
-
-    private Set<String> publicResourcesThatAllowSearch;
-
-    @PostConstruct
-    void init() {
-        publicResourcesThatAllowSearch = new HashSet<String>(Arrays.asList(ResourceNames.EDUCATION_ORGANIZATIONS,
-                ResourceNames.SCHOOLS));
-
-        teacherSectionMutations = new HashMap<String, MutateInfo>() {
-            {
-                // TWO TYPE
-                put(joinPathSegments(PathConstants.ASSESSMENTS, PathConstants.STUDENT_ASSESSMENTS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentAssessments", "assessmentId"));
-                put(joinPathSegments(PathConstants.COURSES, PathConstants.COURSE_TRANSCRIPTS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
-                        "courseId"));
-                put(joinPathSegments(PathConstants.COURSE_OFFERINGS, PathConstants.SECTIONS), new MutateInfo(
-                        "/sections/%s/", "courseOfferingId"));
-                put(joinPathSegments(PathConstants.SESSIONS, PathConstants.SECTIONS), new MutateInfo("/sections/%s/",
-                        "sessionId"));
-                put(joinPathSegments(PathConstants.LEARNING_OBJECTIVES, PathConstants.STUDENT_COMPETENCIES),
-                        new MutateInfo("/sections/%s/studentSectionAssociations/studentCompetencies",
-                                "objectiveId.learningObjectiveId"));
-                put(joinPathSegments(PathConstants.GRADING_PERIODS, PathConstants.REPORT_CARDS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/reportCards", "gradingPeriodId"));
-                put(joinPathSegments(PathConstants.GRADING_PERIODS, PathConstants.GRADES), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/grades", "gradingPeriodId"));
-                put(joinPathSegments(PathConstants.SESSIONS, PathConstants.STUDENT_ACADEMIC_RECORDS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords", "sessionId"));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentSchoolAssociations", null));
-                put(joinPathSegments(PathConstants.EDUCATION_ORGANIZATIONS, PathConstants.COHORTS), new MutateInfo(
-                        "/teachers/%s/staffCohortAssociations/cohorts", "educationOrgId", true));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.SECTIONS), new MutateInfo(
-                        "/teachers/%s/teacherSectionAssociations/sections", null, true));
-                put(joinPathSegments(PathConstants.EDUCATION_ORGANIZATIONS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS),
-                        new MutateInfo("/sections/%s/studentSectionAssociations/students/studentSchoolAssociations",
-                                null));
-
-                // THREE TYPE
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.SECTIONS, PathConstants.GRADEBOOK_ENTRIES),
-                        new MutateInfo("/sections/%s/gradebookEntries", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.SECTIONS,
-                        PathConstants.STUDENT_SECTION_ASSOCIATIONS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS), new MutateInfo("/sections/%s/studentSectionAssociations/students",
-                        null));
-                put(joinPathSegments(PathConstants.EDUCATION_ORGANIZATIONS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS), new MutateInfo("/sections/%s/studentSectionAssociations/students",
-                        null));
-
-                // FOUR TYPE
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.SECTIONS,
-                        PathConstants.STUDENT_SECTION_ASSOCIATIONS, PathConstants.GRADES), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/grades", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.SECTIONS,
-                        PathConstants.STUDENT_SECTION_ASSOCIATIONS, PathConstants.STUDENT_COMPETENCIES),
-                        new MutateInfo("/sections/%s/studentSectionAssociations/studentCompetencies", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.ATTENDANCES), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/attendances", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.COURSE_TRANSCRIPTS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
-                        null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.REPORT_CARDS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/reportCards", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.STUDENT_ACADEMIC_RECORDS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.STUDENT_ASSESSMENTS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentAssessments", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.STUDENT_GRADEBOOK_ENTRIES), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentGradebookEntries", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.STUDENT_PARENT_ASSOCIATIONS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentParentAssociations", null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.TEACHER_SCHOOL_ASSOCIATIONS,
-                        PathConstants.TEACHERS, PathConstants.TEACHER_SECTION_ASSOCIATIONS), new MutateInfo(
-                        "/teachers/%s/teacherSectionAssociations", null, true));
-
-                // FIVE TYPE
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.STUDENT_PARENT_ASSOCIATIONS, PathConstants.PARENTS),
-                        new MutateInfo(
-                                "/sections/%s/studentSectionAssociations/students/studentParentAssociations/parents",
-                                null));
-                put(joinPathSegments(PathConstants.SCHOOLS, PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
-                        PathConstants.STUDENTS, PathConstants.STUDENT_ACADEMIC_RECORDS,
-                        PathConstants.COURSE_TRANSCRIPTS), new MutateInfo(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
-                        null));
-            }
-        };
-
-    }
-
-    private boolean shouldSkipMutation(List<PathSegment> segments, String queryParameters, SLIPrincipal principal, String clientId) {
-        return shouldSkipMutationToEnableSearch(segments, queryParameters) ||
-                ( SessionUtil.isAdminApp(clientId,repo) && hasAppAuthRight(principal) && isEducationOrganizationsEndPoint(segments) );
-    }
-
-
-
-    // Check whether the principal has the 'APP_AUTHORIZE' right for any of its roles in any edorg
-    private boolean hasAppAuthRight(SLIPrincipal principal) {
-        return principal.getAllRights(true).contains(Right.APP_AUTHORIZE);
-    }
-
-    // Check whether the 'educationOrganizations' endpoint is hit directly
-    private boolean isEducationOrganizationsEndPoint(List<PathSegment> segments) {
-        boolean skipMutation = false;
-        if (segments.size() == NUM_SEGMENTS_IN_ONE_PART_REQUEST) {
-            final int baseResourceIndex = 1;
-            if (ResourceNames.EDUCATION_ORGANIZATIONS.equals(segments.get(baseResourceIndex).getPath())) {
-                skipMutation = true;
-            }
-        }
-        return skipMutation;
-    }
-
-    private boolean shouldSkipMutationToEnableSearch(List<PathSegment> segments, String queryParameters) {
-        boolean skipMutation = false;
-        if (segments.size() == NUM_SEGMENTS_IN_ONE_PART_REQUEST) {
-            String[] queries = queryParameters != null ? queryParameters.split("&") : new String[0];
-            for (String query : queries) {
-                if (!query
-                        .matches("(limit|offset|expandDepth|includeFields|excludeFields|sortBy|sortOrder|optionalFields|views|includeCustom|selector)=.+")) {
-                    final int baseResourceIndex = 1;
-                    if (publicResourcesThatAllowSearch.contains(segments.get(baseResourceIndex).getPath())) {
-                        skipMutation = true;
-                        break;
-                    }
-                }
-            }
-
-        }
-        return skipMutation;
-    }
-
-    private class MutateInfo {
-        String mutatedPathFormat;
-        String mutatedParameter;
-        boolean usePrincipleId;
-
-        private MutateInfo(String mutatedPathFormat, String mutatedParameter, boolean usePrincipleId) {
-            this.mutatedPathFormat = mutatedPathFormat;
-            this.mutatedParameter = mutatedParameter;
-            this.usePrincipleId = usePrincipleId;
-        }
-
-        private MutateInfo(String mutatedPathFormat, String mutatedParameter) {
-            this(mutatedPathFormat, mutatedParameter, false);
-        }
-
-        public String getMutatedPathFormat() {
-            return mutatedPathFormat;
-        }
-
-        public String getMutatedParameter() {
-            return mutatedParameter;
-        }
-
-        public boolean isUsePrincipleId() {
-            return usePrincipleId;
-        }
-    }
-
-    /**
-     * Mutates the API call (not to a base entity) to a more-specific (and generally more
-     * constrained) URI.
-     *
-     * @param segments
-     *            List of Path Segments representing request URI.
-     * @param queryParameters
-     *            String containing query parameters.
-     * @param user
-     *            User requesting resource.
-     * @return MutatedContainer representing {mutated path (if necessary), mutated
-     *         parameters (if necessary)}, where path or parameters will be null if they didn't need
-     *         to be rewritten.
-     */
-    private MutatedContainer mutateUriAsNecessary(List<PathSegment> segments, String queryParameters, Entity user)
-            throws ResponseTooLargeException {
-        MutatedContainer mutatedPathAndParameters = null;
-        if (mutateToTeacher()) {
-            mutatedPathAndParameters = mutateTeacherRequest(segments, queryParameters, user);
-        } else if (mutateToStaff()) {
-            mutatedPathAndParameters = mutateStaffRequest(segments, queryParameters, user);
-        } else if (isStudent(user) || isParent(user)) {
-            mutatedPathAndParameters = mutateStudentParentRequest(stringifyPathSegments(segments), queryParameters,
-                    user);
-        }
-
-        return mutatedPathAndParameters;
-    }
-
-    private MutatedContainer generateMutatedUrl(String queryParameters, String format, String... args) {
-        MutatedContainer mutated = new MutatedContainer();
-        mutated.setQueryParameters(queryParameters != null ? queryParameters : "");
-        String mutatedURL = String.format(format, args);
-        mutated.setPath(mutatedURL);
-        return mutated;
-    }
-
-    private MutatedContainer doGeneralMutations(List<String> segmentStrings, String queryParameters, Entity user) {
-        MutatedContainer mutated = null;
-        int segmentSize = segmentStrings.size();
-
-        if(segmentSize == 2) {
-            String baseEntity = segmentStrings.get(1);
-            //does following mutation
-            //v1.2/calendarDates   ->   v1.2/calendarDates/<user's edOrg Ids>
-            if (baseEntity.equals("calendarDates")) {
-                mutated = generateMutatedUrl(queryParameters, "/educationOrganizations/%s/calendarDates", StringUtils.join(edOrgHelper.getDirectEdorgs(user), ","));
-            } else if (baseEntity.equals(PathConstants.CLASS_PERIODS)) {
-                mutated = generateMutatedUrl(queryParameters, "/educationOrganizations/%s/classPeriods", StringUtils.join(edOrgHelper.getDirectEdorgs(user), ","));
-            } else if (baseEntity.equals(PathConstants.BELL_SCHEDULES)) {
-                mutated = generateMutatedUrl(queryParameters, "/educationOrganizations/%s/bellSchedules", StringUtils.join(edOrgHelper.getDirectEdorgs(user), ","));
-            }
-        }
-        else if (segmentSize == 4) {
-            String baseEntity = segmentStrings.get(1);
-            String resourceEntity = segmentStrings.get(3);
-            //does following mutation
-            //v1.2/gradingPeriods/b62056a2f0463864ed2d81dd6ce121c1b7b8d950_id/calendarDates   ->   v1.2/calendarDates/521570eb6dc0e988c4553b91c6c4dadc2a02c487_id
-            //where 521570eb6dc0e988c4553b91c6c4dadc2a02c487_id is the calendarDateReference inside gradingPeriod b62056a2f0463864ed2d81dd6ce121c1b7b8d950_id
-            //The ThreePartResource.java does not work for this relationship because it wrongly assumes that calendarDate contains a reference to gradingPeriod.
-            if(baseEntity.equals("gradingPeriods") && resourceEntity.equals("calendarDates")) {
-                String [] gradingPeriodIds = segmentStrings.get(2).split(",");
-                List<String> gradingPeriodCalendarDates = gradingPeriodHelper.getCalendarDatesForGradingPeriods(queryParameters, gradingPeriodIds);
-
-                if(gradingPeriodCalendarDates.size() > 0) {
-                    mutated = new MutatedContainer();
-                    mutated.setQueryParameters(queryParameters != null ? queryParameters : "");
-                    String mutatedURL = String.format("/calendarDates/%s", StringUtils.join(gradingPeriodCalendarDates.toArray(), ","));
-                    mutated.setPath(mutatedURL);
-                }   else {    //no calendarDates associated with this grading Period
-                    LOG.info("Cannot find any calendarDates associated with gradingPeriods [{}]", Arrays.asList(gradingPeriodIds));
-                }
-            }
-        }
-        return mutated;
-    }
-
-
-    private MutatedContainer mutateStudentParentRequest(List<String> segmentStrings, String queryParameters, Entity user) {
-        MutatedContainer mutated = new MutatedContainer();
-        mutated.setQueryParameters(queryParameters != null ? queryParameters : "");
-        SLIPrincipal principal = SecurityUtil.getSLIPrincipal();
-
-        if (segmentStrings.size() == 2) {
-            String baseEntity = segmentStrings.get(1);
-
-            if (PathConstants.COURSES.equals(baseEntity)) {
-                mutated.setPath(String.format("/schools/%s/courses",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (Arrays.asList(PathConstants.SCHOOLS, PathConstants.EDUCATION_ORGANIZATIONS).contains(baseEntity)) {
-                mutated.setPath(String.format("/schools/%s", StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (PathConstants.COURSE_OFFERINGS.equals(baseEntity)) {
-                mutated.setPath(String.format("/schools/%s/courseOfferings",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (PathConstants.SESSIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/schools/%s/sessions",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (PathConstants.GRADING_PERIODS.equals(baseEntity)) {
-                mutated.setPath(String.format("/schools/%s/sessions/gradingPeriods",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (PathConstants.GRADUATION_PLANS.equals(baseEntity)) {
-                mutated.setPath(String.format("/schools/%s/graduationPlans",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (Arrays.asList(PathConstants.LEARNING_STANDARDS, PathConstants.LEARNING_OBJECTIVES).contains(
-                    baseEntity)) {
-                mutated.setPath(String.format("/search/%s", baseEntity));
-            } else if (PathConstants.STUDENT_COMPETENCY_OBJECTIVES.equals(baseEntity)) {
-                mutated.setPath(String.format("/educationOrganizations/%s/studentCompetencyObjectives",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (PathConstants.ASSESSMENTS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentAssessments/assessments", getStudentIds(principal)));
-            } else if (PathConstants.ATTENDANCES.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/attendances", getStudentIds(principal)));
-            } else if (PathConstants.COHORTS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentCohortAssociations/cohorts",
-                        getStudentIds(principal)));
-            } else if (PathConstants.COURSE_TRANSCRIPTS.equals(baseEntity)) {
-                mutated.setPath(String.format("/studentAcademicRecords/%s/courseTranscripts",
-                        getStudentAcademicRecordsIds(user)));
-            } else if (PathConstants.GRADES.equals(baseEntity)) {
-                mutated.setPath(String.format("/studentSectionAssociations/%s/grades",
-                        getStudentSectionAssocIds(principal)));
-            } else if (PathConstants.GRADEBOOK_ENTRIES.equals(baseEntity)) {
-                mutated.setPath(String.format("/sections/%s/gradebookEntries", getSectionIds(principal)));
-            } else if (PathConstants.PARENTS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentParentAssociations/parents",
-                        getStudentIds(principal)));
-            } else if (PathConstants.PROGRAMS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentProgramAssociations/programs",
-                        getStudentIds(principal)));
-            } else if (PathConstants.SECTIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentSectionAssociations/sections",
-                        getStudentIds(principal)));
-            } else if (PathConstants.REPORT_CARDS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/reportCards", getStudentIds(principal)));
-            } else if (PathConstants.TEACHERS.equals(baseEntity)) {
-                mutated.setPath(String.format("/sections/%s/teacherSectionAssociations/teachers",
-                        getSectionIds(principal)));
-            } else if (PathConstants.TEACHER_SECTION_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/sections/%s/teacherSectionAssociations", getSectionIds(principal)));
-            } else if (PathConstants.TEACHER_SCHOOL_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/schools/%s/teacherSchoolAssociations",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (PathConstants.STAFF.equals(baseEntity)) {
-                mutated.setPath(String.format(
-                        "/educationOrganizations/%s/staffEducationOrgAssignmentAssociations/staff",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (PathConstants.STAFF_COHORT_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/cohorts/%s/staffCohortAssociations", getCohortIds(principal)));
-            } else if (PathConstants.STAFF_EDUCATION_ORGANIZATION_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-            } else if (PathConstants.STAFF_PROGRAM_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/programs/%s/staffProgramAssociations", getProgramIds(principal)));
-            } else if (PathConstants.STUDENTS.equals(baseEntity)) {
-                if (isStudent(user)) {
-                    mutated.setPath(String.format("/sections/%s/studentSectionAssociations/students",
-                            getSectionIds(principal)));
-                } else if (isParent(user)) {
-                    mutated.setPath(String.format("/parents/%s/studentParentAssociations/students", user.getEntityId()));
-                }
-            } else if (PathConstants.STUDENT_ACADEMIC_RECORDS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentAcademicRecords", getStudentIds(principal)));
-            } else if (PathConstants.STUDENT_ASSESSMENTS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentAssessments", getStudentIds(principal)));
-            } else if (PathConstants.STUDENT_COHORT_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentCohortAssociations", getStudentIds(principal)));
-            } else if (PathConstants.STUDENT_COMPETENCIES.equals(baseEntity)) {
-                mutated.setPath(String.format("/studentSectionAssociations/%s/studentCompetencies",
-                        getStudentSectionAssocIds(principal)));
-            } else if (PathConstants.STUDENT_GRADEBOOK_ENTRIES.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentGradebookEntries",
-                        StringUtils.join(getStudentIds(principal))));
-            } else if (PathConstants.STUDENT_PARENT_ASSOCIATIONS.equals(baseEntity)) {
-                if (isStudent(user)) {
-                    mutated.setPath(String.format("/students/%s/studentParentAssociations",
-                            StringUtils.join(getStudentIds(principal))));
-                } else if (isParent(user)) {
-                    mutated.setPath(String.format("/parents/%s/studentParentAssociations", user.getEntityId()));
-                }
-            } else if (PathConstants.STUDENT_PROGRAM_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentProgramAssociations",
-                        StringUtils.join(getStudentIds(principal))));
-            } else if (PathConstants.STUDENT_SCHOOL_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentSchoolAssociations",
-                        StringUtils.join(getStudentIds(principal))));
-            } else if (PathConstants.STUDENT_SECTION_ASSOCIATIONS.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/studentSectionAssociations",
-                        StringUtils.join(getStudentIds(principal))));
-            } else if (PathConstants.YEARLY_ATTENDANCES.equals(baseEntity)) {
-                mutated.setPath(String.format("/students/%s/yearlyAttendances",
-                        StringUtils.join(getStudentIds(principal))));
-            } else if (PathConstants.DISCIPLINE_ACTIONS.equals(baseEntity)) {
-                throw new APIAccessDeniedException("Students do not have access to discipline actions.", true);
-            } else if (PathConstants.DISCIPLINE_INCIDENTS.equals(baseEntity)) {
-                throw new APIAccessDeniedException("Students do not have access to discipline incidents.", true);
-            } else if (PathConstants.STUDENT_DISCIPLINE_INCIDENT_ASSOCIATIONS.equals(baseEntity)) {
-                throw new APIAccessDeniedException("Students do not have access to discipline incident associations.", true);
-            } else if (ResourceNames.HOME.equals(baseEntity)) {
-                mutated.setPath("/home");
-            } else if (ResourceNames.COMPETENCY_LEVEL_DESCRIPTORS.equals(baseEntity)) {
-                mutated.setPath("/search/" + baseEntity);
-            } else {
-                throw new IllegalArgumentException("Not supported yet...");
-            }
-        } else if (segmentStrings.size() >= 4) {
-            String baseEntity = segmentStrings.get(1);
-            String secondEntity = segmentStrings.get(3);
-            if (ResourceNames.STUDENT_SECTION_ASSOCIATIONS.equals(segmentStrings.get(1))) {
-                // /studentSectionAssociation/{id}/students and
-                // /studentSectionAssociation/{id}/sections
-                // have to be re-written to /section/{id}/*
-                if (ResourceNames.STUDENTS.equals(secondEntity) || ResourceNames.SECTIONS.equals(secondEntity)) {
-                    List<String> sections = sectionHelper.getSectionsFromStudentSectionAssociation(segmentStrings.get(2)
-                            .split(","));
-                    String sectionUri = String.format("/sections/%s",
-                            StringUtils.join(sections.toArray(new String[0]), ","));
-                    if (ResourceNames.STUDENTS.equals(secondEntity)) {
-                        sectionUri = sectionUri + "/studentSectionAssociations/students";
-                    }
-                    mutated.setPath(sectionUri);
-                }
-            } else if (ResourceNames.LEARNINGOBJECTIVES.equals(baseEntity) && ResourceNames.STUDENT_COMPETENCIES.equals(secondEntity)) {
-                throw new APIAccessDeniedException("url is not accessible to students or parents", true);
-            }
-        }
-        return mutated;
-    }
-
-    private MutatedContainer mutateTeacherRequest(List<PathSegment> segments, String queryParameters, Entity user) {
-        MutatedContainer mutated = new MutatedContainer();
-        mutated.setQueryParameters(queryParameters);
-
-        List<String> segmentStrings = stringifyPathSegments(segments);
-        String joinedSegments = null;
-        String baseEntityIds = null;
-
-        if (segmentStrings.size() > NUM_SEGMENTS_IN_TWO_PART_REQUEST) {
-
-            int ENTITY_IDS_SEGMENT_INDEX = 2;
-            int API_VERSION_SEGMENT_INDEX = 0;
-            baseEntityIds = segmentStrings.get(ENTITY_IDS_SEGMENT_INDEX);
-            segmentStrings.remove(ENTITY_IDS_SEGMENT_INDEX);
-            segmentStrings.remove(API_VERSION_SEGMENT_INDEX);
-            joinedSegments = joinPathSegments(segmentStrings);
-        }
-
-        if (joinedSegments != null) {
-            MutateInfo mutateInfo = teacherSectionMutations.get(joinedSegments);
-            if (mutateInfo != null) {
-                String ids;
-                if (mutateInfo.usePrincipleId) {
-                    ids = user.getEntityId();
-                } else {
-                    ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                }
-                mutated.setPath(String.format(mutateInfo.getMutatedPathFormat(), ids));
-
-                if (mutateInfo.getMutatedParameter() != null) {
-                    verifySingleTransitiveId(baseEntityIds);
-                    mutated.setQueryParameters(mutuateQueryParameterString(mutateInfo.getMutatedParameter(),
-                            baseEntityIds, queryParameters));
-                }
-            }
-        }
-        return mutated;
-    }
-
-    private MutatedContainer mutateStaffRequest(List<PathSegment> segments, String queryParameters, Entity user) {
-
-        MutatedContainer mutated = new MutatedContainer();
-        mutated.setQueryParameters(queryParameters != null ? queryParameters : "");
-
-        List<String> segmentStrings = stringifyPathSegments(segments);
-        if (segmentStrings.size() == 4) {
-            String baseEntity = segmentStrings.get(1);
-            String transitiveEntityId = segmentStrings.get(2);
-            String requestedEntity = segmentStrings.get(3);
-
-            String modifiedRequest = reconnectPathSegments(Arrays.asList(baseEntity, requestedEntity));
-            if (modifiedRequest.equals(PathConstants.ASSESSMENTS + ";" + PathConstants.STUDENT_ASSESSMENTS + ";")) {
-                verifySingleTransitiveId(transitiveEntityId);
-                mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students/studentAssessments",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-                mutated.setQueryParameters(mutuateQueryParameterString("assessmentId", transitiveEntityId,
-                        mutated.getQueryParameters()));
-            } else if (modifiedRequest.equals(PathConstants.COURSES + ";" + PathConstants.COURSE_TRANSCRIPTS + ";")) {
-                verifySingleTransitiveId(transitiveEntityId);
-                mutated.setPath(String.format(
-                        "/schools/%s/studentSchoolAssociations/students/studentAcademicRecords/courseTranscripts",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-                mutated.setQueryParameters(mutuateQueryParameterString("courseId", transitiveEntityId,
-                        mutated.getQueryParameters()));
-            } else if (modifiedRequest.equals(PathConstants.COURSE_OFFERINGS + ";" + PathConstants.SECTIONS + ";")) {
-                verifySingleTransitiveId(transitiveEntityId);
-                mutated.setPath(String.format("/schools/%s/sections",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-                mutated.setQueryParameters(mutuateQueryParameterString("courseOfferingId", transitiveEntityId,
-                        mutated.getQueryParameters()));
-            } else if (modifiedRequest.equals(PathConstants.GRADING_PERIODS + ";" + PathConstants.GRADES + ";")) {
-                verifySingleTransitiveId(transitiveEntityId);
-                mutated.setPath(String.format("/schools/%s/sections/studentSectionAssociations/grades",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-                mutated.setQueryParameters(mutuateQueryParameterString("gradingPeriodId", transitiveEntityId,
-                        mutated.getQueryParameters()));
-            } else if (modifiedRequest.equals(PathConstants.GRADING_PERIODS + ";" + PathConstants.REPORT_CARDS + ";")) {
-                verifySingleTransitiveId(transitiveEntityId);
-                mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students/reportCards",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-                mutated.setQueryParameters(mutuateQueryParameterString("gradingPeriodId", transitiveEntityId,
-                        mutated.getQueryParameters()));
-            } else if (modifiedRequest.equals(PathConstants.SESSIONS + ";" + PathConstants.SECTIONS + ";")) {
-                verifySingleTransitiveId(transitiveEntityId);
-                mutated.setPath(String.format("/schools/%s/sections",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-                mutated.setQueryParameters(mutuateQueryParameterString("sessionId", transitiveEntityId,
-                        mutated.getQueryParameters()));
-            } else if (modifiedRequest.equals(PathConstants.SESSIONS + ";" + PathConstants.STUDENT_ACADEMIC_RECORDS
-                    + ";")) {
-                verifySingleTransitiveId(transitiveEntityId);
-                mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students/studentAcademicRecords",
-                        StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-                mutated.setQueryParameters(mutuateQueryParameterString("sessionId", transitiveEntityId,
-                        mutated.getQueryParameters()));
-            } else if (modifiedRequest.equals(PathConstants.LEARNING_OBJECTIVES + ";"
-                    + PathConstants.STUDENT_COMPETENCIES + ";")) {
-                verifySingleTransitiveId(transitiveEntityId);
-                mutated.setPath(String.format("/schools/%s/sections/studentSectionAssociations/studentCompetencies",
-                        StringUtils.join(edOrgHelper.getStaffEdOrgsAndChildren(), ",")));
-                mutated.setQueryParameters(mutuateQueryParameterString("learningObjectiveId", transitiveEntityId,
-                        mutated.getQueryParameters()));
-            }
-        }
-        return mutated;
-    }
-
-    /**
-     * Joins a list of path segments and returns a string representing the path traversed.
-     *
-     * @param segments
-     *            List of Strings representing Path Segments.
-     * @return String representing the list of Path Segments.
-     */
-    protected String joinPathSegments(String... segments) {
-        return joinPathSegments(Arrays.asList(segments));
-    }
-
-    /**
-     * Joins a list of path segments and returns a string representing the path traversed.
-     *
-     * @param segments
-     *            List of Strings representing Path Segments.
-     * @return String representing the list of Path Segments.
-     */
-    protected String joinPathSegments(List<String> segments) {
-        StringBuilder builder = new StringBuilder();
-        boolean firstSegment = true;
-        for (String segment : segments) {
-            if (firstSegment) {
-                firstSegment = false;
-            } else {
-                builder.append(";");
-            }
-            builder.append(segment);
-        }
-        return builder.toString();
-    }
-
-    /**
-     * Reconnects a list of path segments and returns a string representing the path traversed.
-     *
-     * @param segments
-     *            List of Strings representing Path Segments.
-     * @return String representing the list of Path Segments.
-     */
-    protected String reconnectPathSegments(List<String> segments) {
-        StringBuilder builder = new StringBuilder();
-        for (String segment : segments) {
-            builder.append(segment).append(";");
-        }
-        return builder.toString();
-    }
-
-    /**
-     * Mutates the existing query parameter string by pre-pending the _id of the transitive entity
-     * that's part of the rewritten URI.
-     *
-     * @param transitiveEntityField
-     *            Field used to identify transitive entity.
-     * @param transitiveEntityId
-     *            UUID of the transitive entity.
-     * @param existingParameters
-     *            Existing query parameter string.
-     * @return String representing new query parameter string.
-     */
-    protected String mutuateQueryParameterString(String transitiveEntityField, String transitiveEntityId,
-            String existingParameters) {
-        if (existingParameters != null) {
-            return transitiveEntityField + "=" + transitiveEntityId + "&" + existingParameters;
-        } else {
-            return transitiveEntityField + "=" + transitiveEntityId;
-        }
-    }
-
-    /**
-     * Throws Response Too Large exception if there are multiple _id's specified in the transitive
-     * _id path segment.
-     *
-     * @param id
-     *            String representing transitive _id path segment.
-     * @throws ResponseTooLargeException
-     *             Thrown if multiple _id's are specified (only one should be specified).
-     */
-    protected void verifySingleTransitiveId(String id) throws ResponseTooLargeException {
-        if (id.split(",").length > 1) {
-            throw new ResponseTooLargeException();
-        }
-    }
-
-    /**
-     * Stringifies the specified list of path segments into a list of strings.
-     *
-     * @param segments
-     *            List of Path Segments.
-     * @return List of Strings representing the input list of Path Segments.
-     */
-    protected List<String> stringifyPathSegments(List<PathSegment> segments) {
-        List<String> stringified = new ArrayList<String>();
-        if (segments != null && !segments.isEmpty()) {
-            for (PathSegment segment : segments) {
-                stringified.add(segment.getPath());
-            }
-        }
-        return stringified;
-    }
-
-    private MutatedContainer mutateBaseUriForTeacher(String resource, String mutatedParameters, Entity user) {
-
-        MutatedContainer mutated = new MutatedContainer();
-        mutated.setQueryParameters(mutatedParameters);
-        if (ResourceNames.LEARNINGOBJECTIVES.equals(resource) || ResourceNames.LEARNINGSTANDARDS.equals(resource)
-                || ResourceNames.ASSESSMENTS.equals(resource)
-                || ResourceNames.COMPETENCY_LEVEL_DESCRIPTORS.equals(resource)
-                || ResourceNames.STUDENT_COMPETENCY_OBJECTIVES.equals(resource)
-                || ResourceNames.SESSIONS.equals(resource) || ResourceNames.COURSES.equals(resource)
-                || ResourceNames.COURSE_OFFERINGS.equals(resource) || ResourceNames.GRADING_PERIODS.equals(resource)) {
-            mutated.setPath("/" + ResourceNames.SEARCH + "/" + resource);
-            Map<String, String> mutatedHeaders = new HashMap<String, String>();
-            mutatedHeaders.put("Content-Type", "application/vnd.slc.search.full+json");
-            mutated.setHeaders(mutatedHeaders);
-        } else if (ResourceNames.HOME.equals(resource)) {
-            mutated.setPath("/" + resource);
-        } else if (ResourceNames.ATTENDANCES.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter("/sections/%s/studentSectionAssociations/students/attendances",
-                        mutatedParameters, ParameterConstants.SECTION_ID);
-            } else {
-                mutated.setPath(String.format("/sections/%s/studentSectionAssociations/students/attendances",
-                        StringUtils.join(sectionHelper.getTeachersSections(user), ",")));
-            }
-        } else if (ResourceNames.COHORTS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffCohortAssociations/cohorts", user.getEntityId()));
-        } else if (ResourceNames.COURSE_TRANSCRIPTS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
-                        mutatedParameters, ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
-                        ids));
-            }
-        } else if (ResourceNames.DISCIPLINE_ACTIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/disciplineActions", user.getEntityId()));
-        } else if (ResourceNames.DISCIPLINE_INCIDENTS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/disciplineIncidents", user.getEntityId()));
-        } else if (ResourceNames.EDUCATION_ORGANIZATIONS.equals(resource)) {
-            mutated.setPath(String.format("/teachers/%s/teacherSchoolAssociations/schools", user.getEntityId()));
-        } else if (ResourceNames.GRADES.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter("/sections/%s/studentSectionAssociations/grades", mutatedParameters,
-                        ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format("/sections/%s/studentSectionAssociations/grades", ids));
-            }
-        } else if (ResourceNames.GRADEBOOK_ENTRIES.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter("/sections/%s/gradebookEntries", mutatedParameters,
-                        ParameterConstants.SECTION_ID);
-            } else {
-                mutated.setPath(String.format("/sections/%s/gradebookEntries",
-                        StringUtils.join(sectionHelper.getTeachersSections(user), ",")));
-            }
-        } else if (ResourceNames.PARENTS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter(
-                        "/sections/%s/studentSectionAssociations/students/studentParentAssociations/parents",
-                        mutatedParameters, ParameterConstants.SECTION_ID);
-            } else {
-                mutated.setPath(String.format(
-                        "/sections/%s/studentSectionAssociations/students/studentParentAssociations/parents",
-                        StringUtils.join(sectionHelper.getTeachersSections(user), ",")));
-            }
-        } else if (ResourceNames.PROGRAMS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffProgramAssociations/programs", user.getEntityId()));
-        } else if (ResourceNames.REPORT_CARDS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter("/sections/%s/studentSectionAssociations/students/reportCards",
-                        mutatedParameters, ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format("/sections/%s/studentSectionAssociations/students/reportCards", ids));
-            }
-        } else if (ResourceNames.SECTIONS.equals(resource)) {
-            mutated.setPath(String.format("/teachers/%s/teacherSectionAssociations/sections", user.getEntityId()));
-        } else if (ResourceNames.SCHOOLS.equals(resource)) {
-            mutated.setPath(String.format("/teachers/%s/teacherSchoolAssociations/schools", user.getEntityId())); // teachers/id/teacherschoolassociations/schools
-        } else if (ResourceNames.STAFF.equals(resource)) {
-            mutated.setPath(String.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations/staff",
-                    StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-        } else if (ResourceNames.STAFF_COHORT_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffCohortAssociations", user.getEntityId()));
-        } else if (ResourceNames.STAFF_EDUCATION_ORGANIZATION_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations",
-                    StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-        } else if (ResourceNames.STAFF_PROGRAM_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffProgramAssociations", user.getEntityId()));
-        } else if (ResourceNames.STUDENTS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter("/sections/%s/studentSectionAssociations/students", mutatedParameters,
-                        ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format("/sections/%s/studentSectionAssociations/students", ids));
-            }
-        } else if (ResourceNames.STUDENT_ACADEMIC_RECORDS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords", mutatedParameters,
-                        ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format(
-                        "/sections/%s/studentSectionAssociations/students/studentAcademicRecords", ids));
-            }
-        } else if (ResourceNames.STUDENT_ASSESSMENTS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter("/sections/%s/studentSectionAssociations/students/studentAssessments",
-                        mutatedParameters, ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format("/sections/%s/studentSectionAssociations/students/studentAssessments",
-                        ids));
-            }
-        } else if (ResourceNames.STUDENT_COHORT_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffCohortAssociations/cohorts/studentCohortAssociations",
-                    user.getEntityId()));
-        } else if (ResourceNames.STUDENT_DISCIPLINE_INCIDENT_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/disciplineIncidents/studentDisciplineIncidentAssociations",
-                    user.getEntityId()));
-        } else if (ResourceNames.STUDENT_COMPETENCIES.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter("/sections/%s/studentSectionAssociations/studentCompetencies",
-                        mutatedParameters, ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format("/sections/%s/studentSectionAssociations/studentCompetencies", ids));
-            }
-        } else if (ResourceNames.STUDENT_COMPETENCY_OBJECTIVES.equals(resource)) {
-            mutated.setPath(String.format("/educationOrganizations/%s/studentCompetencyObjectives",
-                    StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-        } else if (ResourceNames.STUDENT_GRADEBOOK_ENTRIES.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter(
-                        "/sections/%s/studentSectionAssociations/students/studentGradebookEntries", mutatedParameters,
-                        ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format(
-                        "/sections/%s/studentSectionAssociations/students/studentGradebookEntries", ids));
-            }
-        } else if (ResourceNames.STUDENT_PARENT_ASSOCIATIONS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter(
-                        "/sections/%s/studentSectionAssociations/students/studentParentAssociations",
-                        mutatedParameters, ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format(
-                        "/sections/%s/studentSectionAssociations/students/studentParentAssociations", ids));
-            }
-        } else if (ResourceNames.STUDENT_PROGRAM_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffProgramAssociations/programs/studentProgramAssociations",
-                    user.getEntityId()));
-        } else if (ResourceNames.STUDENT_SCHOOL_ASSOCIATIONS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter(
-                        "/sections/%s/studentSectionAssociations/students/studentSchoolAssociations",
-                        mutatedParameters, ParameterConstants.SECTION_ID);
-            } else {
-                String ids = StringUtils.join(sectionHelper.getTeachersSections(user), ",");
-                mutated.setPath(String.format(
-                        "sections/%s/studentSectionAssociations/students/studentSchoolAssociations", ids));
-            }
-        } else if (ResourceNames.STUDENT_SECTION_ASSOCIATIONS.equals(resource)) {
-            if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
-                return formQueryBasedOnParameter("/sections/%s/studentSectionAssociations", mutatedParameters,
-                        ParameterConstants.SECTION_ID);
-            } else {
-                mutated.setPath(String.format("/sections/%s/studentSectionAssociations",
-                        StringUtils.join(sectionHelper.getTeachersSections(user), ",")));
-            }
-        } else if (ResourceNames.TEACHERS.equals(resource)) {
-            mutated.setPath(String.format("/schools/%s/teacherSchoolAssociations/teachers",
-                    StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-        } else if (ResourceNames.TEACHER_SCHOOL_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/teachers/%s/teacherSchoolAssociations", user.getEntityId()));
-        } else if (ResourceNames.TEACHER_SECTION_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/teachers/%s/teacherSectionAssociations", user.getEntityId()));
-        }
-
-        return mutated;
-    }
-
-    private MutatedContainer mutateBaseUriForStaff(String resource, final String mutatedParameters, Entity user,
-            String queryParameters) {
-
-        MutatedContainer mutated = new MutatedContainer();
-        mutated.setQueryParameters(mutatedParameters);
-
-        if (ResourceNames.LEARNINGOBJECTIVES.equals(resource) || ResourceNames.LEARNINGSTANDARDS.equals(resource)
-                || ResourceNames.ASSESSMENTS.equals(resource)
-                || ResourceNames.COMPETENCY_LEVEL_DESCRIPTORS.equals(resource)
-                || ResourceNames.STUDENT_COMPETENCY_OBJECTIVES.equals(resource)
-                || ResourceNames.SESSIONS.equals(resource) || ResourceNames.COURSES.equals(resource)
-                || ResourceNames.COURSE_OFFERINGS.equals(resource) || ResourceNames.GRADING_PERIODS.equals(resource)) {
-            mutated.setPath("/" + ResourceNames.SEARCH + "/" + resource);
-            Map<String, String> mutatedHeaders = new HashMap<String, String>();
-            mutatedHeaders.put("Content-Type", "application/vnd.slc.search.full+json");
-            mutated.setHeaders(mutatedHeaders);
-        } else if (ResourceNames.HOME.equals(resource)) {
-            mutated.setPath("/" + resource);
-        } else if (ResourceNames.ATTENDANCES.equals(resource)) {
-            String ids = getQueryValueForQueryParameters(ParameterConstants.STUDENT_ID, queryParameters);
-            if (ids != null) {
-                mutated.setQueryParameters(removeQueryFromQueryParameters(ParameterConstants.STUDENT_ID,
-                        queryParameters));
-                mutated.setPath(String.format("/students/%s/attendances", ids));
-            } else {
-                ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-                mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students/attendances", ids));
-            }
-
-        } else if (ResourceNames.COHORTS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffCohortAssociations/cohorts", user.getEntityId()));
-        } else if (ResourceNames.COURSE_TRANSCRIPTS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format(
-                    "/schools/%s/studentSchoolAssociations/students/studentAcademicRecords/courseTranscripts", ids));
-        } else if (ResourceNames.DISCIPLINE_ACTIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/disciplineActions", user.getEntityId()));
-        } else if (ResourceNames.DISCIPLINE_INCIDENTS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/disciplineIncidents", user.getEntityId()));
-        } else if (ResourceNames.EDUCATION_ORGANIZATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffEducationOrgAssignmentAssociations/educationOrganizations",
-                    user.getEntityId()));
-        } else if (ResourceNames.GRADES.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/sections/studentSectionAssociations/grades", ids));
-        } else if (ResourceNames.GRADEBOOK_ENTRIES.equals(resource)) {
-            mutated.setPath(String.format("/schools/%s/sections/gradebookEntries",
-                    StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-        } else if (ResourceNames.PARENTS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format(
-                    "/schools/%s/studentSchoolAssociations/students/studentParentAssociations/parents", ids));
-        } else if (ResourceNames.PROGRAMS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffProgramAssociations/programs", user.getEntityId()));
-        } else if (ResourceNames.REPORT_CARDS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students/reportCards", ids));
-        } else if (ResourceNames.SCHOOLS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffEducationOrgAssignmentAssociations/schools",
-                    user.getEntityId()));
-        } else if (ResourceNames.SECTIONS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/sections", ids));
-        } else if (ResourceNames.STAFF.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations/staff",
-                    ids));
-        } else if (ResourceNames.STAFF_COHORT_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffCohortAssociations", user.getEntityId()));
-        } else if (ResourceNames.STAFF_EDUCATION_ORGANIZATION_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffEducationOrgAssignmentAssociations", user.getEntityId()));
-        } else if (ResourceNames.STAFF_PROGRAM_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffProgramAssociations", user.getEntityId()));
-        } else if (ResourceNames.STUDENTS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students", ids));
-        } else if (ResourceNames.STUDENT_ACADEMIC_RECORDS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students/studentAcademicRecords", ids));
-        } else if (ResourceNames.STUDENT_ASSESSMENTS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students/studentAssessments", ids));
-        } else if (ResourceNames.STUDENT_COHORT_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffCohortAssociations/cohorts/studentCohortAssociations",
-                    user.getEntityId()));
-        } else if (ResourceNames.STUDENT_COMPETENCIES.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/sections/studentSectionAssociations/studentCompetencies", ids));
-        } else if (ResourceNames.STUDENT_COMPETENCY_OBJECTIVES.equals(resource)) {
-            mutated.setPath(String.format("/educationOrganizations/%s/studentCompetencyObjectives",
-                    StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-        } else if (ResourceNames.STUDENT_DISCIPLINE_INCIDENT_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/disciplineIncidents/studentDisciplineIncidentAssociations",
-                    user.getEntityId()));
-        } else if (ResourceNames.STUDENT_GRADEBOOK_ENTRIES.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String
-                    .format("/schools/%s/studentSchoolAssociations/students/studentGradebookEntries", ids));
-        } else if (ResourceNames.STUDENT_PARENT_ASSOCIATIONS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/studentSchoolAssociations/students/studentParentAssociations",
-                    ids));
-        } else if (ResourceNames.STUDENT_PROGRAM_ASSOCIATIONS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffProgramAssociations/programs/studentProgramAssociations",
-                    user.getEntityId()));
-        } else if (ResourceNames.STUDENT_SCHOOL_ASSOCIATIONS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/studentSchoolAssociations", ids));
-        } else if (ResourceNames.STUDENT_SECTION_ASSOCIATIONS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/sections/studentSectionAssociations", ids));
-        } else if (ResourceNames.TEACHERS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/teacherSchoolAssociations/teachers", ids));
-        } else if (ResourceNames.TEACHER_SCHOOL_ASSOCIATIONS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/teacherSchoolAssociations", ids));
-        } else if (ResourceNames.PROGRAMS.equals(resource)) {
-            mutated.setPath(String.format("/staff/%s/staffProgramAssociations/programs", user.getEntityId()));
-        } else if (ResourceNames.PARENTS.equals(resource)) {
-            mutated.setPath(String.format(
-                    "/schools/%s/studentSchoolAssociations/students/studentParentAssociations/parents",
-                    StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
-        } else if (ResourceNames.TEACHER_SECTION_ASSOCIATIONS.equals(resource)) {
-            String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
-            mutated.setPath(String.format("/schools/%s/teacherSchoolAssociations/teachers/teacherSectionAssociations",
-                    ids));
-        }
-
-        return mutated;
-    }
-
-    /**
-     * Mutates the API call (to a base entity) to a more-specific (and generally more constrained)
-     * URI.
-     *
-     * @param resource - root resource being accessed.
-     * @param version - API version.
-     * @param queryParameters - URI query parameters.
-     * @param user - entity representing user making API call.
-     * @return Mutated String representing new API call, or null if no mutation takes place.
-     */
-    public MutatedContainer mutateBaseUri(String version, String resource, final String queryParameters, Entity user) {
-        MutatedContainer mutated = new MutatedContainer();
-        mutated.setQueryParameters(queryParameters);
-        if (mutated.getQueryParameters() == null) {
-            mutated.setQueryParameters("");
-        }
-
-        mutated.setPath(rootSearchMutator.mutatePath(version, resource, mutated.getQueryParameters()));
-        if (mutated.getPath() == null && mutateToTeacher()) {
-            return this.mutateBaseUriForTeacher(resource, mutated.getQueryParameters(), user);
-        } else if (mutated.getPath() == null && mutateToStaff()) {
-            return this.mutateBaseUriForStaff(resource, mutated.getQueryParameters(), user,
-                    mutated.getQueryParameters());
-        } else if (mutated.getPath() == null && isStudent(user) || isParent(user)) {
-            return this.mutateStudentParentRequest(Arrays.<String> asList(version, resource),
-                    mutated.getQueryParameters(), user);
-        } else {
-            return mutated;
-        }
-    }
-
-    private String getQueryValueForQueryParameters(String queryName, String queryParameters) {
-        String queryValue = null;
-        String[] queries = queryParameters.split("&");
-        String queryRegEx = "^" + Matcher.quoteReplacement(queryName) + "=.+";
-
-        for (String query : queries) {
-            if (query.matches(queryRegEx)) {
-                int indexOfQueryValue = queryRegEx.length() - 3;
-                queryValue = query.substring(indexOfQueryValue);
-                break;
-            }
-        }
-
-        return queryValue;
-    }
-
-    private String removeQueryFromQueryParameters(String queryName, String queryParameters) {
-        String queryRegEx = Matcher.quoteReplacement(queryName) + "=[^&]*&?";
-        return queryParameters.replaceFirst(Matcher.quoteReplacement(queryRegEx), "");
-    }
-
-    private boolean isStudent(Entity principal) {
-        return principal.getType().equals(EntityNames.STUDENT);
-    }
-
-    private boolean isParent(Entity principal) {
-        return principal.getType().equals(EntityNames.PARENT);
-    }
-
-    /**
-     * Determines if the URI should be mutated to a teacher context for a federated user.
-     *
-     * @return - True if the user has teacher context, false otherwise
-     */
-    private boolean mutateToTeacher() {
-        return (SecurityUtil.getUserContext() == SecurityUtil.UserContext.TEACHER_CONTEXT);
-    }
-
-    /**
-     * Determines if the URI should be mutated to a staff context for a federated user.
-     *
-     * @return - True if the user has staff or dual context, false otherwise
-     */
-    private boolean mutateToStaff() {
-        return ((SecurityUtil.getUserContext() == SecurityUtil.UserContext.STAFF_CONTEXT) ||
-                (SecurityUtil.getUserContext() == SecurityUtil.UserContext.DUAL_CONTEXT));
-    }
-
-    private String getStudentIds(SLIPrincipal principal) {
-        Collection<String> studentIds;
-        Entity entity = principal.getEntity();
-        if (isStudent(entity)) {
-            studentIds = Arrays.asList(entity.getEntityId());
-        } else if (isParent(entity)) {
-            // use evil thread local to get the student list
-            studentIds = principal.getOwnedStudentIds();
-        } else {
-            studentIds = Collections.emptyList();
-        }
-        return StringUtils.join(studentIds, ",");
-    }
-
-    private String getStudentAcademicRecordsIds(Entity principal) {
-        return StringUtils.join(getStudentRelatedRecords(principal, EntityNames.STUDENT_ACADEMIC_RECORD), ",");
-    }
-
-    private String getStudentSectionAssocIds(SLIPrincipal principal) {
-        Set<String> assocIds = new HashSet<String>();
-        for (Entity student : principal.getOwnedStudentEntities()) {
-            assocIds.addAll(getStudentRelatedRecords(student, EntityNames.STUDENT_SECTION_ASSOCIATION));
-        }
-        return StringUtils.join(assocIds, ",");
-    }
-
-    private String getSectionIds(SLIPrincipal principal) {
-        Collection<String> sectionIds = new HashSet<String>();
-        for (Entity student : principal.getOwnedStudentEntities()) {
-            sectionIds.addAll(sectionHelper.getStudentsSections(student));
-        }
-        return StringUtils.join(sectionIds, ",");
-    }
-
-    private String getProgramIds(SLIPrincipal principal) {
-        Set<String> programIds = new HashSet<String>();
-        for (Entity student : principal.getOwnedStudentEntities()) {
-            programIds.addAll(getProgramIdsForStudent(student));
-        }
-
-        return StringUtils.join(programIds, ",");
-    }
-
-    private Set<String> getProgramIdsForStudent(Entity student) {
-        Set<String> programsIds = null;
-        if (isStudent(student)) {
-            programsIds = getSubdocIds(student, EntityNames.STUDENT_PROGRAM_ASSOCIATION, ParameterConstants.PROGRAM_ID);
-        }
-
-        if (programsIds == null || programsIds.isEmpty()) {
-            throw new EntityNotFoundException("No association to any programs");
-        }
-
-        return programsIds;
-    }
-
-    private String getCohortIds(SLIPrincipal principal) {
-        Set<String> cohortsIds = new HashSet<String>();
-        for (Entity student : principal.getOwnedStudentEntities()) {
-            cohortsIds.addAll(getCohortIdsForStudent(student));
-        }
-
-        return StringUtils.join(cohortsIds, ",");
-    }
-
-    private Set<String> getCohortIdsForStudent(Entity student) {
-        Set<String> cohortsIds = null;
-        if (isStudent(student)) {
-            cohortsIds = getSubdocIds(student, EntityNames.STUDENT_COHORT_ASSOCIATION, ParameterConstants.COHORT_ID);
-        }
-
-        if (cohortsIds == null || cohortsIds.isEmpty()) {
-            throw new EntityNotFoundException("No association to any cohorts");
-        }
-        return cohortsIds;
-    }
-
-    private Set<String> getSubdocIds(Entity superdoc, String subdocType, String subdocField) {
-        Set<String> subdocFields = new HashSet<String>();
-        Map<String, List<Entity>> myEmbeddedData = superdoc.getEmbeddedData();
-        List<Entity> myAssociations = myEmbeddedData == null ? Collections.<Entity> emptyList() : myEmbeddedData
-                .get(subdocType);
-        if (myAssociations != null && !myAssociations.isEmpty()) {
-            for (Entity association : myAssociations) {
-                if (!dateHelper.isFieldExpired(association.getBody(), ParameterConstants.END_DATE)) {
-                    subdocFields.add((String) association.getBody().get(subdocField));
-                }
-            }
-        }
-
-        return subdocFields;
-    }
-
-    private List<String> getStudentRelatedRecords(Entity principal, String entityType) {
-        NeutralQuery query = new NeutralQuery(new NeutralCriteria(ParameterConstants.STUDENT_ID,
-                NeutralCriteria.CRITERIA_IN, SecurityUtil.getSLIPrincipal().getOwnedStudentIds()));
-        List<String> recordIds = new ArrayList<String>();
-
-        Iterable<String> allIds = repo.findAllIds(entityType, query);
-
-        for (String recordId : allIds) {
-            recordIds.add(recordId);
-        }
-
-        return recordIds;
-    }
-
-    private MutatedContainer formQueryBasedOnParameter(String path, String parameters, String parameter) {
-        MutatedContainer mutated = new MutatedContainer();
-
-        String[] queryParameters = parameters.split("&");
-        for (int i = 0; i < queryParameters.length; i++) {
-            String queryParameter = queryParameters[i];
-            String[] values = queryParameter.split("=");
-            if (values.length == 2) {
-                if (values[0].equals(parameter) && values[1] != null && !values[1].isEmpty()) {
-                    mutated.setPath(String.format(path, values[1]));
-                    mutated.setQueryParameters(removeQueryParameter(parameters, parameter));
-                    break;
-                }
-            }
-        }
-
-        return mutated;
-    }
-
-    private String removeQueryParameter(String parameters, String queryParameterToRemove) {
-        if (parameters == null || parameters.isEmpty()) {
-            return parameters;
-        }
-
-        StringBuilder builder = new StringBuilder();
-        String[] queryParameters = parameters.split("&");
-        for (String queryParameter : queryParameters) {
-            if (!queryParameter.startsWith(queryParameterToRemove)) {
-                builder.append(queryParameter).append("&");
-            }
-        }
-
-        if (builder.length() > 0) {
-            return builder.substring(0, builder.length() - 2);
-        }
-        return "";
-    }
-
-    /**
-     * Inject section helper (for unit testing).
-     *
-     * @param sectionHelper
-     *            resolver for tying entity to sections.
-     */
-    protected void setSectionHelper(SectionHelper sectionHelper) {
-        this.sectionHelper = sectionHelper;
-    }
-
-    /**
-     * Inject education organization helper (for unit testing).
-     *
-     * @param edOrgHelper
-     *            resolver for tying entity to education organizations.
-     */
-    protected void setEdOrgHelper(EdOrgHelper edOrgHelper) {
-        this.edOrgHelper = edOrgHelper;
-    }
+
+	private static final Logger LOG = LoggerFactory.getLogger(UriMutator.class);
+
+	public static final int NUM_SEGMENTS_IN_TWO_PART_REQUEST = 3;
+	public static final int NUM_SEGMENTS_IN_ONE_PART_REQUEST = 2;
+
+	@Resource
+	private EdOrgHelper edOrgHelper;
+
+	@Resource
+	private SectionHelper sectionHelper;
+
+	@Resource
+	private RootSearchMutator rootSearchMutator;
+
+	@Autowired
+	@Qualifier("validationRepo")
+	private Repository<Entity> repo;
+
+	@Autowired
+	private BasicDefinitionStore definitionStore;
+
+	@Autowired
+	private DateHelper dateHelper;
+
+	private Map<String, MutateInfo> teacherSectionMutations;
+
+	@Autowired
+	private GradingPeriodHelper gradingPeriodHelper;
+
+	@SuppressWarnings("unchecked")
+	private static final List<Pair<String, String>> PARAMETER_RESOURCE_PAIRS = Arrays
+			.asList(Pair.of(ParameterConstants.STUDENT_UNIQUE_STATE_ID,
+					ResourceNames.STUDENTS), Pair.of(
+					ParameterConstants.STAFF_UNIQUE_STATE_ID,
+					ResourceNames.STAFF), Pair.of(
+					ParameterConstants.PARENT_UNIQUE_STATE_ID,
+					ResourceNames.PARENTS), Pair.of(
+					ParameterConstants.STATE_ORGANIZATION_ID,
+					ResourceNames.EDUCATION_ORGANIZATIONS));
+
+	/**
+	 * Acts as a filter to determine if the requested resource, given knowledge
+	 * of the user requesting it, should be rewritten. Returning null indicates
+	 * that the URI should NOT be rewritten.
+	 * 
+	 * @param segments
+	 *            List of Path Segments representing request URI.
+	 * @param queryParameters
+	 *            String containing query parameters.
+	 * @param user
+	 *            User requesting resource.
+	 * @return MutatedContainer representing {mutated path (if necessary),
+	 *         mutated parameters (if necessary)}, where path will be null or
+	 *         parameters the empty string if they didn't need to be rewritten.
+	 */
+	public MutatedContainer mutate(List<PathSegment> segments,
+			String queryParameters, SLIPrincipal principal, String clientId) {
+		Entity user = principal.getEntity();
+		MutatedContainer mutated = new MutatedContainer();
+		mutated.setQueryParameters(queryParameters);
+		if (mutated.getQueryParameters() == null) {
+			mutated.setQueryParameters("");
+		}
+
+		Map<String, String> parameters = MutatorUtil.getParameterMap(mutated
+				.getQueryParameters());
+		for (Pair<String, String> parameterResourcePair : PARAMETER_RESOURCE_PAIRS) {
+			String parameter = parameterResourcePair.getLeft();
+			String resource = parameterResourcePair.getRight();
+			if (parameters.containsKey(parameter)) {
+				EntityDefinition definition = definitionStore
+						.lookupByResourceName(resource);
+				if (definition != null) {
+					NeutralQuery query = new NeutralQuery(new NeutralCriteria(
+							parameter, NeutralCriteria.OPERATOR_EQUAL,
+							parameters.get(parameter)));
+					Entity e = repo.findOne(definition.getType(), query);
+					if (e != null) {
+						MutatedContainer newMutated = new MutatedContainer();
+						String path = String.format("/%s/%s", resource,
+								e.getEntityId());
+						if (EntityNames.TEACHER.equals(e.getType())) {
+							path = String.format("/teachers/%s",
+									e.getEntityId());
+						} else if (EntityNames.STAFF.equals(e.getType())) {
+							path = String.format("/staff/%s", e.getEntityId());
+						}
+						newMutated.setPath(path);
+
+						LOG.info("Rewriting URI to {} based on natural keys",
+								newMutated.getPath());
+						return newMutated;
+					}
+				}
+			}
+		}
+
+		mutated.setPath(null);
+		mutated.setQueryParameters(queryParameters);
+		MutatedContainer generalMutation = doGeneralMutations(
+				stringifyPathSegments(segments), queryParameters, user);
+
+		if (generalMutation != null) {
+			mutated = generalMutation;
+		} else if (segments.size() < NUM_SEGMENTS_IN_TWO_PART_REQUEST) {
+
+			if (!shouldSkipMutation(segments, mutated.getQueryParameters(),
+					principal, clientId)) {
+				if (segments.size() == 1) {
+					// api/v1
+					mutated = mutateBaseUri(segments.get(0).getPath(),
+							ResourceNames.HOME, mutated.getQueryParameters(),
+							user);
+				} else {
+					mutated = mutateBaseUri(segments.get(0).getPath(), segments
+							.get(1).getPath(), mutated.getQueryParameters(),
+							user);
+				}
+			}
+		} else {
+			mutated = mutateUriAsNecessary(segments,
+					mutated.getQueryParameters(), user);
+		}
+
+		return mutated;
+	}
+
+	private Set<String> publicResourcesThatAllowSearch;
+
+	@PostConstruct
+	void init() {
+		publicResourcesThatAllowSearch = new HashSet<String>(Arrays.asList(
+				ResourceNames.EDUCATION_ORGANIZATIONS, ResourceNames.SCHOOLS));
+
+		teacherSectionMutations = new HashMap<String, MutateInfo>() {
+			{
+				// TWO TYPE
+				put(joinPathSegments(PathConstants.ASSESSMENTS,
+						PathConstants.STUDENT_ASSESSMENTS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentAssessments",
+								"assessmentId"));
+				put(joinPathSegments(PathConstants.COURSES,
+						PathConstants.COURSE_TRANSCRIPTS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
+								"courseId"));
+				put(joinPathSegments(PathConstants.COURSE_OFFERINGS,
+						PathConstants.SECTIONS), new MutateInfo(
+						"/sections/%s/", "courseOfferingId"));
+				put(joinPathSegments(PathConstants.SESSIONS,
+						PathConstants.SECTIONS), new MutateInfo(
+						"/sections/%s/", "sessionId"));
+				put(joinPathSegments(PathConstants.LEARNING_OBJECTIVES,
+						PathConstants.STUDENT_COMPETENCIES),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/studentCompetencies",
+								"objectiveId.learningObjectiveId"));
+				put(joinPathSegments(PathConstants.GRADING_PERIODS,
+						PathConstants.REPORT_CARDS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/reportCards",
+								"gradingPeriodId"));
+				put(joinPathSegments(PathConstants.GRADING_PERIODS,
+						PathConstants.GRADES), new MutateInfo(
+						"/sections/%s/studentSectionAssociations/grades",
+						"gradingPeriodId"));
+				put(joinPathSegments(PathConstants.SESSIONS,
+						PathConstants.STUDENT_ACADEMIC_RECORDS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentAcademicRecords",
+								"sessionId"));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentSchoolAssociations",
+								null));
+				put(joinPathSegments(PathConstants.EDUCATION_ORGANIZATIONS,
+						PathConstants.COHORTS), new MutateInfo(
+						"/teachers/%s/staffCohortAssociations/cohorts",
+						"educationOrgId", true));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.SECTIONS), new MutateInfo(
+						"/teachers/%s/teacherSectionAssociations/sections",
+						null, true));
+				put(joinPathSegments(PathConstants.EDUCATION_ORGANIZATIONS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentSchoolAssociations",
+								null));
+
+				// THREE TYPE
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.SECTIONS, PathConstants.GRADEBOOK_ENTRIES),
+						new MutateInfo("/sections/%s/gradebookEntries", null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.SECTIONS,
+						PathConstants.STUDENT_SECTION_ASSOCIATIONS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations", null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS), new MutateInfo(
+						"/sections/%s/studentSectionAssociations/students",
+						null));
+				put(joinPathSegments(PathConstants.EDUCATION_ORGANIZATIONS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS), new MutateInfo(
+						"/sections/%s/studentSectionAssociations/students",
+						null));
+
+				// FOUR TYPE
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.SECTIONS,
+						PathConstants.STUDENT_SECTION_ASSOCIATIONS,
+						PathConstants.GRADES), new MutateInfo(
+						"/sections/%s/studentSectionAssociations/grades", null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.SECTIONS,
+						PathConstants.STUDENT_SECTION_ASSOCIATIONS,
+						PathConstants.STUDENT_COMPETENCIES),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/studentCompetencies",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS, PathConstants.ATTENDANCES),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/attendances",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS,
+						PathConstants.COURSE_TRANSCRIPTS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS, PathConstants.REPORT_CARDS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/reportCards",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS,
+						PathConstants.STUDENT_ACADEMIC_RECORDS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentAcademicRecords",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS,
+						PathConstants.STUDENT_ASSESSMENTS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentAssessments",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS,
+						PathConstants.STUDENT_GRADEBOOK_ENTRIES),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentGradebookEntries",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS,
+						PathConstants.STUDENT_PARENT_ASSOCIATIONS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentParentAssociations",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.TEACHER_SCHOOL_ASSOCIATIONS,
+						PathConstants.TEACHERS,
+						PathConstants.TEACHER_SECTION_ASSOCIATIONS),
+						new MutateInfo(
+								"/teachers/%s/teacherSectionAssociations",
+								null, true));
+
+				// FIVE TYPE
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS,
+						PathConstants.STUDENT_PARENT_ASSOCIATIONS,
+						PathConstants.PARENTS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentParentAssociations/parents",
+								null));
+				put(joinPathSegments(PathConstants.SCHOOLS,
+						PathConstants.STUDENT_SCHOOL_ASSOCIATIONS,
+						PathConstants.STUDENTS,
+						PathConstants.STUDENT_ACADEMIC_RECORDS,
+						PathConstants.COURSE_TRANSCRIPTS),
+						new MutateInfo(
+								"/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
+								null));
+			}
+		};
+
+	}
+
+	private boolean shouldSkipMutation(List<PathSegment> segments,
+			String queryParameters, SLIPrincipal principal, String clientId) {
+		return shouldSkipMutationToEnableSearch(segments, queryParameters)
+				|| (SessionUtil.isAdminApp(clientId, repo)
+						&& hasAppAuthRight(principal) && isEducationOrganizationsEndPoint(segments));
+	}
+
+	// Check whether the principal has the 'APP_AUTHORIZE' right for any of its
+	// roles in any edorg
+	private boolean hasAppAuthRight(SLIPrincipal principal) {
+		return principal.getAllRights(true).contains(Right.APP_AUTHORIZE);
+	}
+
+	// Check whether the 'educationOrganizations' endpoint is hit directly
+	private boolean isEducationOrganizationsEndPoint(List<PathSegment> segments) {
+		boolean skipMutation = false;
+		if (segments.size() == NUM_SEGMENTS_IN_ONE_PART_REQUEST) {
+			final int baseResourceIndex = 1;
+			if (ResourceNames.EDUCATION_ORGANIZATIONS.equals(segments.get(
+					baseResourceIndex).getPath())) {
+				skipMutation = true;
+			}
+		}
+		return skipMutation;
+	}
+
+	private boolean shouldSkipMutationToEnableSearch(
+			List<PathSegment> segments, String queryParameters) {
+		boolean skipMutation = false;
+		if (segments.size() == NUM_SEGMENTS_IN_ONE_PART_REQUEST) {
+			String[] queries = queryParameters != null ? queryParameters
+					.split("&") : new String[0];
+			for (String query : queries) {
+				if (!query
+						.matches("(limit|offset|expandDepth|includeFields|excludeFields|sortBy|sortOrder|optionalFields|views|includeCustom|selector)=.+")) {
+					final int baseResourceIndex = 1;
+					if (publicResourcesThatAllowSearch.contains(segments.get(
+							baseResourceIndex).getPath())) {
+						skipMutation = true;
+						break;
+					}
+				}
+			}
+
+		}
+		return skipMutation;
+	}
+
+	private class MutateInfo {
+		String mutatedPathFormat;
+		String mutatedParameter;
+		boolean usePrincipleId;
+
+		private MutateInfo(String mutatedPathFormat, String mutatedParameter,
+				boolean usePrincipleId) {
+			this.mutatedPathFormat = mutatedPathFormat;
+			this.mutatedParameter = mutatedParameter;
+			this.usePrincipleId = usePrincipleId;
+		}
+
+		private MutateInfo(String mutatedPathFormat, String mutatedParameter) {
+			this(mutatedPathFormat, mutatedParameter, false);
+		}
+
+		public String getMutatedPathFormat() {
+			return mutatedPathFormat;
+		}
+
+		public String getMutatedParameter() {
+			return mutatedParameter;
+		}
+
+		public boolean isUsePrincipleId() {
+			return usePrincipleId;
+		}
+	}
+
+	/**
+	 * Mutates the API call (not to a base entity) to a more-specific (and
+	 * generally more constrained) URI.
+	 * 
+	 * @param segments
+	 *            List of Path Segments representing request URI.
+	 * @param queryParameters
+	 *            String containing query parameters.
+	 * @param user
+	 *            User requesting resource.
+	 * @return MutatedContainer representing {mutated path (if necessary),
+	 *         mutated parameters (if necessary)}, where path or parameters will
+	 *         be null if they didn't need to be rewritten.
+	 */
+	private MutatedContainer mutateUriAsNecessary(List<PathSegment> segments,
+			String queryParameters, Entity user)
+			throws IllegalArgumentException {
+		MutatedContainer mutatedPathAndParameters = null;
+		if (mutateToTeacher()) {
+			mutatedPathAndParameters = mutateTeacherRequest(segments,
+					queryParameters, user);
+		} else if (mutateToStaff()) {
+			mutatedPathAndParameters = mutateStaffRequest(segments,
+					queryParameters, user);
+		} else if (isStudent(user) || isParent(user)) {
+			mutatedPathAndParameters = mutateStudentParentRequest(
+					stringifyPathSegments(segments), queryParameters, user);
+		}
+
+		return mutatedPathAndParameters;
+	}
+
+	private MutatedContainer generateMutatedUrl(String queryParameters,
+			String format, String... args) {
+		MutatedContainer mutated = new MutatedContainer();
+		mutated.setQueryParameters(queryParameters != null ? queryParameters
+				: "");
+		String mutatedURL = String.format(format, args);
+		mutated.setPath(mutatedURL);
+		return mutated;
+	}
+
+	private MutatedContainer doGeneralMutations(List<String> segmentStrings,
+			String queryParameters, Entity user) {
+		MutatedContainer mutated = null;
+		int segmentSize = segmentStrings.size();
+
+		if (segmentSize == 2) {
+			String baseEntity = segmentStrings.get(1);
+			// does following mutation
+			// v1.2/calendarDates -> v1.2/calendarDates/<user's edOrg Ids>
+			if (baseEntity.equals("calendarDates")) {
+				mutated = generateMutatedUrl(
+						queryParameters,
+						"/educationOrganizations/%s/calendarDates",
+						StringUtils.join(edOrgHelper.getDirectEdorgs(user), ","));
+			} else if (baseEntity.equals(PathConstants.CLASS_PERIODS)) {
+				mutated = generateMutatedUrl(
+						queryParameters,
+						"/educationOrganizations/%s/classPeriods",
+						StringUtils.join(edOrgHelper.getDirectEdorgs(user), ","));
+			} else if (baseEntity.equals(PathConstants.BELL_SCHEDULES)) {
+				mutated = generateMutatedUrl(
+						queryParameters,
+						"/educationOrganizations/%s/bellSchedules",
+						StringUtils.join(edOrgHelper.getDirectEdorgs(user), ","));
+			}
+		} else if (segmentSize == 4) {
+			String baseEntity = segmentStrings.get(1);
+			String resourceEntity = segmentStrings.get(3);
+			// does following mutation
+			// v1.2/gradingPeriods/b62056a2f0463864ed2d81dd6ce121c1b7b8d950_id/calendarDates
+			// -> v1.2/calendarDates/521570eb6dc0e988c4553b91c6c4dadc2a02c487_id
+			// where 521570eb6dc0e988c4553b91c6c4dadc2a02c487_id is the
+			// calendarDateReference inside gradingPeriod
+			// b62056a2f0463864ed2d81dd6ce121c1b7b8d950_id
+			// The ThreePartResource.java does not work for this relationship
+			// because it wrongly assumes that calendarDate contains a reference
+			// to gradingPeriod.
+			if (baseEntity.equals("gradingPeriods")
+					&& resourceEntity.equals("calendarDates")) {
+				String[] gradingPeriodIds = segmentStrings.get(2).split(",");
+				List<String> gradingPeriodCalendarDates = gradingPeriodHelper
+						.getCalendarDatesForGradingPeriods(queryParameters,
+								gradingPeriodIds);
+
+				if (gradingPeriodCalendarDates.size() > 0) {
+					mutated = new MutatedContainer();
+					mutated.setQueryParameters(queryParameters != null ? queryParameters
+							: "");
+					String mutatedURL = String.format(
+							"/calendarDates/%s",
+							StringUtils.join(
+									gradingPeriodCalendarDates.toArray(), ","));
+					mutated.setPath(mutatedURL);
+				} else { // no calendarDates associated with this grading Period
+					LOG.info(
+							"Cannot find any calendarDates associated with gradingPeriods [{}]",
+							Arrays.asList(gradingPeriodIds));
+				}
+			}
+		}
+		return mutated;
+	}
+
+	private MutatedContainer mutateStudentParentRequest(
+			List<String> segmentStrings, String queryParameters, Entity user) {
+		MutatedContainer mutated = new MutatedContainer();
+		mutated.setQueryParameters(queryParameters != null ? queryParameters
+				: "");
+		SLIPrincipal principal = SecurityUtil.getSLIPrincipal();
+
+		if (segmentStrings.size() == 2) {
+			String baseEntity = segmentStrings.get(1);
+
+			if (PathConstants.COURSES.equals(baseEntity)) {
+				mutated.setPath(String
+						.format("/schools/%s/courses",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (Arrays.asList(PathConstants.SCHOOLS,
+					PathConstants.EDUCATION_ORGANIZATIONS).contains(baseEntity)) {
+				mutated.setPath(String.format("/schools/%s", StringUtils.join(
+						edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (PathConstants.COURSE_OFFERINGS.equals(baseEntity)) {
+				mutated.setPath(String
+						.format("/schools/%s/courseOfferings",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (PathConstants.SESSIONS.equals(baseEntity)) {
+				mutated.setPath(String
+						.format("/schools/%s/sessions",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (PathConstants.GRADING_PERIODS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/schools/%s/sessions/gradingPeriods", StringUtils
+								.join(edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (PathConstants.GRADUATION_PLANS.equals(baseEntity)) {
+				mutated.setPath(String
+						.format("/schools/%s/graduationPlans",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (Arrays.asList(PathConstants.LEARNING_STANDARDS,
+					PathConstants.LEARNING_OBJECTIVES).contains(baseEntity)) {
+				mutated.setPath(String.format("/search/%s", baseEntity));
+			} else if (PathConstants.STUDENT_COMPETENCY_OBJECTIVES
+					.equals(baseEntity)) {
+				mutated.setPath(String
+						.format("/educationOrganizations/%s/studentCompetencyObjectives",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (PathConstants.ASSESSMENTS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentAssessments/assessments",
+						getStudentIds(principal)));
+			} else if (PathConstants.ATTENDANCES.equals(baseEntity)) {
+				mutated.setPath(String.format("/students/%s/attendances",
+						getStudentIds(principal)));
+			} else if (PathConstants.COHORTS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentCohortAssociations/cohorts",
+						getStudentIds(principal)));
+			} else if (PathConstants.COURSE_TRANSCRIPTS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/studentAcademicRecords/%s/courseTranscripts",
+						getStudentAcademicRecordsIds(user)));
+			} else if (PathConstants.GRADES.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/studentSectionAssociations/%s/grades",
+						getStudentSectionAssocIds(principal)));
+			} else if (PathConstants.GRADEBOOK_ENTRIES.equals(baseEntity)) {
+				mutated.setPath(String.format("/sections/%s/gradebookEntries",
+						getSectionIds(principal)));
+			} else if (PathConstants.PARENTS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentParentAssociations/parents",
+						getStudentIds(principal)));
+			} else if (PathConstants.PROGRAMS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentProgramAssociations/programs",
+						getStudentIds(principal)));
+			} else if (PathConstants.SECTIONS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentSectionAssociations/sections",
+						getStudentIds(principal)));
+			} else if (PathConstants.REPORT_CARDS.equals(baseEntity)) {
+				mutated.setPath(String.format("/students/%s/reportCards",
+						getStudentIds(principal)));
+			} else if (PathConstants.TEACHERS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/sections/%s/teacherSectionAssociations/teachers",
+						getSectionIds(principal)));
+			} else if (PathConstants.TEACHER_SECTION_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/sections/%s/teacherSectionAssociations",
+						getSectionIds(principal)));
+			} else if (PathConstants.TEACHER_SCHOOL_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/schools/%s/teacherSchoolAssociations", StringUtils
+								.join(edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (PathConstants.STAFF.equals(baseEntity)) {
+				mutated.setPath(String
+						.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations/staff",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (PathConstants.STAFF_COHORT_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/cohorts/%s/staffCohortAssociations",
+						getCohortIds(principal)));
+			} else if (PathConstants.STAFF_EDUCATION_ORGANIZATION_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String
+						.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+			} else if (PathConstants.STAFF_PROGRAM_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/programs/%s/staffProgramAssociations",
+						getProgramIds(principal)));
+			} else if (PathConstants.STUDENTS.equals(baseEntity)) {
+				if (isStudent(user)) {
+					mutated.setPath(String.format(
+							"/sections/%s/studentSectionAssociations/students",
+							getSectionIds(principal)));
+				} else if (isParent(user)) {
+					mutated.setPath(String.format(
+							"/parents/%s/studentParentAssociations/students",
+							user.getEntityId()));
+				}
+			} else if (PathConstants.STUDENT_ACADEMIC_RECORDS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentAcademicRecords",
+						getStudentIds(principal)));
+			} else if (PathConstants.STUDENT_ASSESSMENTS.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentAssessments",
+						getStudentIds(principal)));
+			} else if (PathConstants.STUDENT_COHORT_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentCohortAssociations",
+						getStudentIds(principal)));
+			} else if (PathConstants.STUDENT_COMPETENCIES.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/studentSectionAssociations/%s/studentCompetencies",
+						getStudentSectionAssocIds(principal)));
+			} else if (PathConstants.STUDENT_GRADEBOOK_ENTRIES
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentGradebookEntries",
+						StringUtils.join(getStudentIds(principal))));
+			} else if (PathConstants.STUDENT_PARENT_ASSOCIATIONS
+					.equals(baseEntity)) {
+				if (isStudent(user)) {
+					mutated.setPath(String.format(
+							"/students/%s/studentParentAssociations",
+							StringUtils.join(getStudentIds(principal))));
+				} else if (isParent(user)) {
+					mutated.setPath(String.format(
+							"/parents/%s/studentParentAssociations",
+							user.getEntityId()));
+				}
+			} else if (PathConstants.STUDENT_PROGRAM_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentProgramAssociations",
+						StringUtils.join(getStudentIds(principal))));
+			} else if (PathConstants.STUDENT_SCHOOL_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentSchoolAssociations",
+						StringUtils.join(getStudentIds(principal))));
+			} else if (PathConstants.STUDENT_SECTION_ASSOCIATIONS
+					.equals(baseEntity)) {
+				mutated.setPath(String.format(
+						"/students/%s/studentSectionAssociations",
+						StringUtils.join(getStudentIds(principal))));
+			} else if (PathConstants.YEARLY_ATTENDANCES.equals(baseEntity)) {
+				mutated.setPath(String.format("/students/%s/yearlyAttendances",
+						StringUtils.join(getStudentIds(principal))));
+			} else if (PathConstants.DISCIPLINE_ACTIONS.equals(baseEntity)) {
+				throw new APIAccessDeniedException(
+						"Students do not have access to discipline actions.",
+						true);
+			} else if (PathConstants.DISCIPLINE_INCIDENTS.equals(baseEntity)) {
+				throw new APIAccessDeniedException(
+						"Students do not have access to discipline incidents.",
+						true);
+			} else if (PathConstants.STUDENT_DISCIPLINE_INCIDENT_ASSOCIATIONS
+					.equals(baseEntity)) {
+				throw new APIAccessDeniedException(
+						"Students do not have access to discipline incident associations.",
+						true);
+			} else if (ResourceNames.HOME.equals(baseEntity)) {
+				mutated.setPath("/home");
+			} else if (ResourceNames.COMPETENCY_LEVEL_DESCRIPTORS
+					.equals(baseEntity)) {
+				mutated.setPath("/search/" + baseEntity);
+			} else {
+				throw new IllegalArgumentException("Not supported yet...");
+			}
+		} else if (segmentStrings.size() >= 4) {
+			String baseEntity = segmentStrings.get(1);
+			String secondEntity = segmentStrings.get(3);
+			if (ResourceNames.STUDENT_SECTION_ASSOCIATIONS
+					.equals(segmentStrings.get(1))) {
+				// /studentSectionAssociation/{id}/students and
+				// /studentSectionAssociation/{id}/sections
+				// have to be re-written to /section/{id}/*
+				if (ResourceNames.STUDENTS.equals(secondEntity)
+						|| ResourceNames.SECTIONS.equals(secondEntity)) {
+					List<String> sections = sectionHelper
+							.getSectionsFromStudentSectionAssociation(segmentStrings
+									.get(2).split(","));
+					String sectionUri = String.format("/sections/%s",
+							StringUtils.join(sections.toArray(new String[0]),
+									","));
+					if (ResourceNames.STUDENTS.equals(secondEntity)) {
+						sectionUri = sectionUri
+								+ "/studentSectionAssociations/students";
+					}
+					mutated.setPath(sectionUri);
+				}
+			} else if (ResourceNames.LEARNINGOBJECTIVES.equals(baseEntity)
+					&& ResourceNames.STUDENT_COMPETENCIES.equals(secondEntity)) {
+				throw new APIAccessDeniedException(
+						"url is not accessible to students or parents", true);
+			}
+		}
+		return mutated;
+	}
+
+	private MutatedContainer mutateTeacherRequest(List<PathSegment> segments,
+			String queryParameters, Entity user) {
+		MutatedContainer mutated = new MutatedContainer();
+		mutated.setQueryParameters(queryParameters);
+
+		List<String> segmentStrings = stringifyPathSegments(segments);
+		String joinedSegments = null;
+		String baseEntityIds = null;
+
+		if (segmentStrings.size() > NUM_SEGMENTS_IN_TWO_PART_REQUEST) {
+
+			int ENTITY_IDS_SEGMENT_INDEX = 2;
+			int API_VERSION_SEGMENT_INDEX = 0;
+			baseEntityIds = segmentStrings.get(ENTITY_IDS_SEGMENT_INDEX);
+			segmentStrings.remove(ENTITY_IDS_SEGMENT_INDEX);
+			segmentStrings.remove(API_VERSION_SEGMENT_INDEX);
+			joinedSegments = joinPathSegments(segmentStrings);
+		}
+
+		if (joinedSegments != null) {
+			MutateInfo mutateInfo = teacherSectionMutations.get(joinedSegments);
+			if (mutateInfo != null) {
+				String ids;
+				if (mutateInfo.usePrincipleId) {
+					ids = user.getEntityId();
+				} else {
+					ids = StringUtils.join(
+							sectionHelper.getTeachersSections(user), ",");
+				}
+				mutated.setPath(String.format(
+						mutateInfo.getMutatedPathFormat(), ids));
+
+				if (mutateInfo.getMutatedParameter() != null) {
+					verifySingleTransitiveId(baseEntityIds);
+					mutated.setQueryParameters(mutuateQueryParameterString(
+							mutateInfo.getMutatedParameter(), baseEntityIds,
+							queryParameters));
+				}
+			}
+		}
+		return mutated;
+	}
+
+	private MutatedContainer mutateStaffRequest(List<PathSegment> segments,
+			String queryParameters, Entity user) {
+
+		MutatedContainer mutated = new MutatedContainer();
+		mutated.setQueryParameters(queryParameters != null ? queryParameters
+				: "");
+
+		List<String> segmentStrings = stringifyPathSegments(segments);
+		if (segmentStrings.size() == 4) {
+			String baseEntity = segmentStrings.get(1);
+			String transitiveEntityId = segmentStrings.get(2);
+			String requestedEntity = segmentStrings.get(3);
+
+			String modifiedRequest = reconnectPathSegments(Arrays.asList(
+					baseEntity, requestedEntity));
+			if (modifiedRequest.equals(PathConstants.ASSESSMENTS + ";"
+					+ PathConstants.STUDENT_ASSESSMENTS + ";")) {
+				verifySingleTransitiveId(transitiveEntityId);
+				mutated.setPath(String
+						.format("/schools/%s/studentSchoolAssociations/students/studentAssessments",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+				mutated.setQueryParameters(mutuateQueryParameterString(
+						"assessmentId", transitiveEntityId,
+						mutated.getQueryParameters()));
+			} else if (modifiedRequest.equals(PathConstants.COURSES + ";"
+					+ PathConstants.COURSE_TRANSCRIPTS + ";")) {
+				verifySingleTransitiveId(transitiveEntityId);
+				mutated.setPath(String
+						.format("/schools/%s/studentSchoolAssociations/students/studentAcademicRecords/courseTranscripts",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+				mutated.setQueryParameters(mutuateQueryParameterString(
+						"courseId", transitiveEntityId,
+						mutated.getQueryParameters()));
+			} else if (modifiedRequest.equals(PathConstants.COURSE_OFFERINGS
+					+ ";" + PathConstants.SECTIONS + ";")) {
+				verifySingleTransitiveId(transitiveEntityId);
+				mutated.setPath(String
+						.format("/schools/%s/sections",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+				mutated.setQueryParameters(mutuateQueryParameterString(
+						"courseOfferingId", transitiveEntityId,
+						mutated.getQueryParameters()));
+			} else if (modifiedRequest.equals(PathConstants.GRADING_PERIODS
+					+ ";" + PathConstants.GRADES + ";")) {
+				verifySingleTransitiveId(transitiveEntityId);
+				mutated.setPath(String
+						.format("/schools/%s/sections/studentSectionAssociations/grades",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+				mutated.setQueryParameters(mutuateQueryParameterString(
+						"gradingPeriodId", transitiveEntityId,
+						mutated.getQueryParameters()));
+			} else if (modifiedRequest.equals(PathConstants.GRADING_PERIODS
+					+ ";" + PathConstants.REPORT_CARDS + ";")) {
+				verifySingleTransitiveId(transitiveEntityId);
+				mutated.setPath(String
+						.format("/schools/%s/studentSchoolAssociations/students/reportCards",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+				mutated.setQueryParameters(mutuateQueryParameterString(
+						"gradingPeriodId", transitiveEntityId,
+						mutated.getQueryParameters()));
+			} else if (modifiedRequest.equals(PathConstants.SESSIONS + ";"
+					+ PathConstants.SECTIONS + ";")) {
+				verifySingleTransitiveId(transitiveEntityId);
+				mutated.setPath(String
+						.format("/schools/%s/sections",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+				mutated.setQueryParameters(mutuateQueryParameterString(
+						"sessionId", transitiveEntityId,
+						mutated.getQueryParameters()));
+			} else if (modifiedRequest.equals(PathConstants.SESSIONS + ";"
+					+ PathConstants.STUDENT_ACADEMIC_RECORDS + ";")) {
+				verifySingleTransitiveId(transitiveEntityId);
+				mutated.setPath(String
+						.format("/schools/%s/studentSchoolAssociations/students/studentAcademicRecords",
+								StringUtils.join(
+										edOrgHelper.getDirectEdorgs(user), ",")));
+				mutated.setQueryParameters(mutuateQueryParameterString(
+						"sessionId", transitiveEntityId,
+						mutated.getQueryParameters()));
+			} else if (modifiedRequest.equals(PathConstants.LEARNING_OBJECTIVES
+					+ ";" + PathConstants.STUDENT_COMPETENCIES + ";")) {
+				verifySingleTransitiveId(transitiveEntityId);
+				mutated.setPath(String
+						.format("/schools/%s/sections/studentSectionAssociations/studentCompetencies",
+								StringUtils.join(
+										edOrgHelper.getStaffEdOrgsAndChildren(),
+										",")));
+				mutated.setQueryParameters(mutuateQueryParameterString(
+						"learningObjectiveId", transitiveEntityId,
+						mutated.getQueryParameters()));
+			}
+		}
+		return mutated;
+	}
+
+	/**
+	 * Joins a list of path segments and returns a string representing the path
+	 * traversed.
+	 * 
+	 * @param segments
+	 *            List of Strings representing Path Segments.
+	 * @return String representing the list of Path Segments.
+	 */
+	protected String joinPathSegments(String... segments) {
+		return joinPathSegments(Arrays.asList(segments));
+	}
+
+	/**
+	 * Joins a list of path segments and returns a string representing the path
+	 * traversed.
+	 * 
+	 * @param segments
+	 *            List of Strings representing Path Segments.
+	 * @return String representing the list of Path Segments.
+	 */
+	protected String joinPathSegments(List<String> segments) {
+		StringBuilder builder = new StringBuilder();
+		boolean firstSegment = true;
+		for (String segment : segments) {
+			if (firstSegment) {
+				firstSegment = false;
+			} else {
+				builder.append(";");
+			}
+			builder.append(segment);
+		}
+		return builder.toString();
+	}
+
+	/**
+	 * Reconnects a list of path segments and returns a string representing the
+	 * path traversed.
+	 * 
+	 * @param segments
+	 *            List of Strings representing Path Segments.
+	 * @return String representing the list of Path Segments.
+	 */
+	protected String reconnectPathSegments(List<String> segments) {
+		StringBuilder builder = new StringBuilder();
+		for (String segment : segments) {
+			builder.append(segment).append(";");
+		}
+		return builder.toString();
+	}
+
+	/**
+	 * Mutates the existing query parameter string by pre-pending the _id of the
+	 * transitive entity that's part of the rewritten URI.
+	 * 
+	 * @param transitiveEntityField
+	 *            Field used to identify transitive entity.
+	 * @param transitiveEntityId
+	 *            UUID of the transitive entity.
+	 * @param existingParameters
+	 *            Existing query parameter string.
+	 * @return String representing new query parameter string.
+	 */
+	protected String mutuateQueryParameterString(String transitiveEntityField,
+			String transitiveEntityId, String existingParameters) {
+		if (existingParameters != null) {
+			return transitiveEntityField + "=" + transitiveEntityId + "&"
+					+ existingParameters;
+		} else {
+			return transitiveEntityField + "=" + transitiveEntityId;
+		}
+	}
+
+	/**
+	 * Throws Illegal Argument exception if there are multiple _id's specified
+	 * in the transitive _id path segment.
+	 * 
+	 * @param id
+	 *            String representing transitive _id path segment.
+	 * @throws IllegalArgumentException
+	 *             Thrown if multiple _id's are specified (only one should be
+	 *             specified).
+	 */
+	protected void verifySingleTransitiveId(String id)
+			throws IllegalArgumentException {
+		if (id.split(",").length > 1) {
+			throw new IllegalArgumentException();
+		}
+	}
+
+	/**
+	 * Stringifies the specified list of path segments into a list of strings.
+	 * 
+	 * @param segments
+	 *            List of Path Segments.
+	 * @return List of Strings representing the input list of Path Segments.
+	 */
+	protected List<String> stringifyPathSegments(List<PathSegment> segments) {
+		List<String> stringified = new ArrayList<String>();
+		if (segments != null && !segments.isEmpty()) {
+			for (PathSegment segment : segments) {
+				stringified.add(segment.getPath());
+			}
+		}
+		return stringified;
+	}
+
+	private MutatedContainer mutateBaseUriForTeacher(String resource,
+			String mutatedParameters, Entity user) {
+
+		MutatedContainer mutated = new MutatedContainer();
+		mutated.setQueryParameters(mutatedParameters);
+		if (ResourceNames.LEARNINGOBJECTIVES.equals(resource)
+				|| ResourceNames.LEARNINGSTANDARDS.equals(resource)
+				|| ResourceNames.ASSESSMENTS.equals(resource)
+				|| ResourceNames.COMPETENCY_LEVEL_DESCRIPTORS.equals(resource)
+				|| ResourceNames.STUDENT_COMPETENCY_OBJECTIVES.equals(resource)
+				|| ResourceNames.SESSIONS.equals(resource)
+				|| ResourceNames.COURSES.equals(resource)
+				|| ResourceNames.COURSE_OFFERINGS.equals(resource)
+				|| ResourceNames.GRADING_PERIODS.equals(resource)) {
+			mutated.setPath("/" + ResourceNames.SEARCH + "/" + resource);
+			Map<String, String> mutatedHeaders = new HashMap<String, String>();
+			mutatedHeaders.put("Content-Type",
+					"application/vnd.slc.search.full+json");
+			mutated.setHeaders(mutatedHeaders);
+		} else if (ResourceNames.HOME.equals(resource)) {
+			mutated.setPath("/" + resource);
+		} else if (ResourceNames.ATTENDANCES.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/attendances",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students/attendances",
+								StringUtils.join(
+										sectionHelper.getTeachersSections(user),
+										",")));
+			}
+		} else if (ResourceNames.COHORTS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/staff/%s/staffCohortAssociations/cohorts",
+					user.getEntityId()));
+		} else if (ResourceNames.COURSE_TRANSCRIPTS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students/studentAcademicRecords/courseTranscripts",
+								ids));
+			}
+		} else if (ResourceNames.DISCIPLINE_ACTIONS.equals(resource)) {
+			mutated.setPath(String.format("/staff/%s/disciplineActions",
+					user.getEntityId()));
+		} else if (ResourceNames.DISCIPLINE_INCIDENTS.equals(resource)) {
+			mutated.setPath(String.format("/staff/%s/disciplineIncidents",
+					user.getEntityId()));
+		} else if (ResourceNames.EDUCATION_ORGANIZATIONS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/teachers/%s/teacherSchoolAssociations/schools",
+					user.getEntityId()));
+		} else if (ResourceNames.GRADES.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/grades",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String.format(
+						"/sections/%s/studentSectionAssociations/grades", ids));
+			}
+		} else if (ResourceNames.GRADEBOOK_ENTRIES.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/gradebookEntries", mutatedParameters,
+						ParameterConstants.SECTION_ID);
+			} else {
+				mutated.setPath(String.format(
+						"/sections/%s/gradebookEntries",
+						StringUtils.join(
+								sectionHelper.getTeachersSections(user), ",")));
+			}
+		} else if (ResourceNames.PARENTS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/studentParentAssociations/parents",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students/studentParentAssociations/parents",
+								StringUtils.join(
+										sectionHelper.getTeachersSections(user),
+										",")));
+			}
+		} else if (ResourceNames.PROGRAMS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/staff/%s/staffProgramAssociations/programs",
+					user.getEntityId()));
+		} else if (ResourceNames.REPORT_CARDS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/reportCards",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students/reportCards",
+								ids));
+			}
+		} else if (ResourceNames.SECTIONS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/teachers/%s/teacherSectionAssociations/sections",
+					user.getEntityId()));
+		} else if (ResourceNames.SCHOOLS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/teachers/%s/teacherSchoolAssociations/schools",
+					user.getEntityId())); // teachers/id/teacherschoolassociations/schools
+		} else if (ResourceNames.STAFF.equals(resource)) {
+			mutated.setPath(String
+					.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations/staff",
+							StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+									",")));
+		} else if (ResourceNames.STAFF_COHORT_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String.format("/staff/%s/staffCohortAssociations",
+					user.getEntityId()));
+		} else if (ResourceNames.STAFF_EDUCATION_ORGANIZATION_ASSOCIATIONS
+				.equals(resource)) {
+			mutated.setPath(String
+					.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations",
+							StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+									",")));
+		} else if (ResourceNames.STAFF_PROGRAM_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String.format("/staff/%s/staffProgramAssociations",
+					user.getEntityId()));
+		} else if (ResourceNames.STUDENTS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students",
+								ids));
+			}
+		} else if (ResourceNames.STUDENT_ACADEMIC_RECORDS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/studentAcademicRecords",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students/studentAcademicRecords",
+								ids));
+			}
+		} else if (ResourceNames.STUDENT_ASSESSMENTS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/studentAssessments",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students/studentAssessments",
+								ids));
+			}
+		} else if (ResourceNames.STUDENT_COHORT_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String
+					.format("/staff/%s/staffCohortAssociations/cohorts/studentCohortAssociations",
+							user.getEntityId()));
+		} else if (ResourceNames.STUDENT_DISCIPLINE_INCIDENT_ASSOCIATIONS
+				.equals(resource)) {
+			mutated.setPath(String
+					.format("/staff/%s/disciplineIncidents/studentDisciplineIncidentAssociations",
+							user.getEntityId()));
+		} else if (ResourceNames.STUDENT_COMPETENCIES.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/studentCompetencies",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/studentCompetencies",
+								ids));
+			}
+		} else if (ResourceNames.STUDENT_COMPETENCY_OBJECTIVES.equals(resource)) {
+			mutated.setPath(String.format(
+					"/educationOrganizations/%s/studentCompetencyObjectives",
+					StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
+		} else if (ResourceNames.STUDENT_GRADEBOOK_ENTRIES.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/studentGradebookEntries",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students/studentGradebookEntries",
+								ids));
+			}
+		} else if (ResourceNames.STUDENT_PARENT_ASSOCIATIONS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/studentParentAssociations",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("/sections/%s/studentSectionAssociations/students/studentParentAssociations",
+								ids));
+			}
+		} else if (ResourceNames.STUDENT_PROGRAM_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String
+					.format("/staff/%s/staffProgramAssociations/programs/studentProgramAssociations",
+							user.getEntityId()));
+		} else if (ResourceNames.STUDENT_SCHOOL_ASSOCIATIONS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations/students/studentSchoolAssociations",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				String ids = StringUtils.join(
+						sectionHelper.getTeachersSections(user), ",");
+				mutated.setPath(String
+						.format("sections/%s/studentSectionAssociations/students/studentSchoolAssociations",
+								ids));
+			}
+		} else if (ResourceNames.STUDENT_SECTION_ASSOCIATIONS.equals(resource)) {
+			if (mutatedParameters.contains(ParameterConstants.SECTION_ID)) {
+				return formQueryBasedOnParameter(
+						"/sections/%s/studentSectionAssociations",
+						mutatedParameters, ParameterConstants.SECTION_ID);
+			} else {
+				mutated.setPath(String.format(
+						"/sections/%s/studentSectionAssociations",
+						StringUtils.join(
+								sectionHelper.getTeachersSections(user), ",")));
+			}
+		} else if (ResourceNames.TEACHERS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/schools/%s/teacherSchoolAssociations/teachers",
+					StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
+		} else if (ResourceNames.TEACHER_SCHOOL_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/teachers/%s/teacherSchoolAssociations",
+					user.getEntityId()));
+		} else if (ResourceNames.TEACHER_SECTION_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/teachers/%s/teacherSectionAssociations",
+					user.getEntityId()));
+		}
+
+		return mutated;
+	}
+
+	private MutatedContainer mutateBaseUriForStaff(String resource,
+			final String mutatedParameters, Entity user, String queryParameters) {
+
+		MutatedContainer mutated = new MutatedContainer();
+		mutated.setQueryParameters(mutatedParameters);
+
+		if (ResourceNames.LEARNINGOBJECTIVES.equals(resource)
+				|| ResourceNames.LEARNINGSTANDARDS.equals(resource)
+				|| ResourceNames.ASSESSMENTS.equals(resource)
+				|| ResourceNames.COMPETENCY_LEVEL_DESCRIPTORS.equals(resource)
+				|| ResourceNames.STUDENT_COMPETENCY_OBJECTIVES.equals(resource)
+				|| ResourceNames.SESSIONS.equals(resource)
+				|| ResourceNames.COURSES.equals(resource)
+				|| ResourceNames.COURSE_OFFERINGS.equals(resource)
+				|| ResourceNames.GRADING_PERIODS.equals(resource)) {
+			mutated.setPath("/" + ResourceNames.SEARCH + "/" + resource);
+			Map<String, String> mutatedHeaders = new HashMap<String, String>();
+			mutatedHeaders.put("Content-Type",
+					"application/vnd.slc.search.full+json");
+			mutated.setHeaders(mutatedHeaders);
+		} else if (ResourceNames.HOME.equals(resource)) {
+			mutated.setPath("/" + resource);
+		} else if (ResourceNames.ATTENDANCES.equals(resource)) {
+			String ids = getQueryValueForQueryParameters(
+					ParameterConstants.STUDENT_ID, queryParameters);
+			if (ids != null) {
+				mutated.setQueryParameters(removeQueryFromQueryParameters(
+						ParameterConstants.STUDENT_ID, queryParameters));
+				mutated.setPath(String.format("/students/%s/attendances", ids));
+			} else {
+				ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",");
+				mutated.setPath(String
+						.format("/schools/%s/studentSchoolAssociations/students/attendances",
+								ids));
+			}
+
+		} else if (ResourceNames.COHORTS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/staff/%s/staffCohortAssociations/cohorts",
+					user.getEntityId()));
+		} else if (ResourceNames.COURSE_TRANSCRIPTS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/studentSchoolAssociations/students/studentAcademicRecords/courseTranscripts",
+							ids));
+		} else if (ResourceNames.DISCIPLINE_ACTIONS.equals(resource)) {
+			mutated.setPath(String.format("/staff/%s/disciplineActions",
+					user.getEntityId()));
+		} else if (ResourceNames.DISCIPLINE_INCIDENTS.equals(resource)) {
+			mutated.setPath(String.format("/staff/%s/disciplineIncidents",
+					user.getEntityId()));
+		} else if (ResourceNames.EDUCATION_ORGANIZATIONS.equals(resource)) {
+			mutated.setPath(String
+					.format("/staff/%s/staffEducationOrgAssignmentAssociations/educationOrganizations",
+							user.getEntityId()));
+		} else if (ResourceNames.GRADES.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String.format(
+					"/schools/%s/sections/studentSectionAssociations/grades",
+					ids));
+		} else if (ResourceNames.GRADEBOOK_ENTRIES.equals(resource)) {
+			mutated.setPath(String.format(
+					"/schools/%s/sections/gradebookEntries",
+					StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
+		} else if (ResourceNames.PARENTS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/studentSchoolAssociations/students/studentParentAssociations/parents",
+							ids));
+		} else if (ResourceNames.PROGRAMS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/staff/%s/staffProgramAssociations/programs",
+					user.getEntityId()));
+		} else if (ResourceNames.REPORT_CARDS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/studentSchoolAssociations/students/reportCards",
+							ids));
+		} else if (ResourceNames.SCHOOLS.equals(resource)) {
+			mutated.setPath(String
+					.format("/staff/%s/staffEducationOrgAssignmentAssociations/schools",
+							user.getEntityId()));
+		} else if (ResourceNames.SECTIONS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String.format("/schools/%s/sections", ids));
+		} else if (ResourceNames.STAFF.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations/staff",
+							ids));
+		} else if (ResourceNames.STAFF_COHORT_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String.format("/staff/%s/staffCohortAssociations",
+					user.getEntityId()));
+		} else if (ResourceNames.STAFF_EDUCATION_ORGANIZATION_ASSOCIATIONS
+				.equals(resource)) {
+			mutated.setPath(String.format(
+					"/staff/%s/staffEducationOrgAssignmentAssociations",
+					user.getEntityId()));
+		} else if (ResourceNames.STAFF_PROGRAM_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String.format("/staff/%s/staffProgramAssociations",
+					user.getEntityId()));
+		} else if (ResourceNames.STUDENTS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String.format(
+					"/schools/%s/studentSchoolAssociations/students", ids));
+		} else if (ResourceNames.STUDENT_ACADEMIC_RECORDS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/studentSchoolAssociations/students/studentAcademicRecords",
+							ids));
+		} else if (ResourceNames.STUDENT_ASSESSMENTS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/studentSchoolAssociations/students/studentAssessments",
+							ids));
+		} else if (ResourceNames.STUDENT_COHORT_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String
+					.format("/staff/%s/staffCohortAssociations/cohorts/studentCohortAssociations",
+							user.getEntityId()));
+		} else if (ResourceNames.STUDENT_COMPETENCIES.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/sections/studentSectionAssociations/studentCompetencies",
+							ids));
+		} else if (ResourceNames.STUDENT_COMPETENCY_OBJECTIVES.equals(resource)) {
+			mutated.setPath(String.format(
+					"/educationOrganizations/%s/studentCompetencyObjectives",
+					StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
+		} else if (ResourceNames.STUDENT_DISCIPLINE_INCIDENT_ASSOCIATIONS
+				.equals(resource)) {
+			mutated.setPath(String
+					.format("/staff/%s/disciplineIncidents/studentDisciplineIncidentAssociations",
+							user.getEntityId()));
+		} else if (ResourceNames.STUDENT_GRADEBOOK_ENTRIES.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/studentSchoolAssociations/students/studentGradebookEntries",
+							ids));
+		} else if (ResourceNames.STUDENT_PARENT_ASSOCIATIONS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/studentSchoolAssociations/students/studentParentAssociations",
+							ids));
+		} else if (ResourceNames.STUDENT_PROGRAM_ASSOCIATIONS.equals(resource)) {
+			mutated.setPath(String
+					.format("/staff/%s/staffProgramAssociations/programs/studentProgramAssociations",
+							user.getEntityId()));
+		} else if (ResourceNames.STUDENT_SCHOOL_ASSOCIATIONS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String.format(
+					"/schools/%s/studentSchoolAssociations", ids));
+		} else if (ResourceNames.STUDENT_SECTION_ASSOCIATIONS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String.format(
+					"/schools/%s/sections/studentSectionAssociations", ids));
+		} else if (ResourceNames.TEACHERS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String.format(
+					"/schools/%s/teacherSchoolAssociations/teachers", ids));
+		} else if (ResourceNames.TEACHER_SCHOOL_ASSOCIATIONS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String.format(
+					"/schools/%s/teacherSchoolAssociations", ids));
+		} else if (ResourceNames.PROGRAMS.equals(resource)) {
+			mutated.setPath(String.format(
+					"/staff/%s/staffProgramAssociations/programs",
+					user.getEntityId()));
+		} else if (ResourceNames.PARENTS.equals(resource)) {
+			mutated.setPath(String
+					.format("/schools/%s/studentSchoolAssociations/students/studentParentAssociations/parents",
+							StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+									",")));
+		} else if (ResourceNames.TEACHER_SECTION_ASSOCIATIONS.equals(resource)) {
+			String ids = StringUtils.join(edOrgHelper.getDirectEdorgs(user),
+					",");
+			mutated.setPath(String
+					.format("/schools/%s/teacherSchoolAssociations/teachers/teacherSectionAssociations",
+							ids));
+		}
+
+		return mutated;
+	}
+
+	/**
+	 * Mutates the API call (to a base entity) to a more-specific (and generally
+	 * more constrained) URI.
+	 * 
+	 * @param resource
+	 *            - root resource being accessed.
+	 * @param version
+	 *            - API version.
+	 * @param queryParameters
+	 *            - URI query parameters.
+	 * @param user
+	 *            - entity representing user making API call.
+	 * @return Mutated String representing new API call, or null if no mutation
+	 *         takes place.
+	 */
+	public MutatedContainer mutateBaseUri(String version, String resource,
+			final String queryParameters, Entity user) {
+		MutatedContainer mutated = new MutatedContainer();
+		mutated.setQueryParameters(queryParameters);
+		if (mutated.getQueryParameters() == null) {
+			mutated.setQueryParameters("");
+		}
+
+		mutated.setPath(rootSearchMutator.mutatePath(version, resource,
+				mutated.getQueryParameters()));
+		if (mutated.getPath() == null && mutateToTeacher()) {
+			return this.mutateBaseUriForTeacher(resource,
+					mutated.getQueryParameters(), user);
+		} else if (mutated.getPath() == null && mutateToStaff()) {
+			return this.mutateBaseUriForStaff(resource,
+					mutated.getQueryParameters(), user,
+					mutated.getQueryParameters());
+		} else if (mutated.getPath() == null && isStudent(user)
+				|| isParent(user)) {
+			return this.mutateStudentParentRequest(
+					Arrays.<String> asList(version, resource),
+					mutated.getQueryParameters(), user);
+		} else {
+			return mutated;
+		}
+	}
+
+	private String getQueryValueForQueryParameters(String queryName,
+			String queryParameters) {
+		String queryValue = null;
+		String[] queries = queryParameters.split("&");
+		String queryRegEx = "^" + Matcher.quoteReplacement(queryName) + "=.+";
+
+		for (String query : queries) {
+			if (query.matches(queryRegEx)) {
+				int indexOfQueryValue = queryRegEx.length() - 3;
+				queryValue = query.substring(indexOfQueryValue);
+				break;
+			}
+		}
+
+		return queryValue;
+	}
+
+	private String removeQueryFromQueryParameters(String queryName,
+			String queryParameters) {
+		String queryRegEx = Matcher.quoteReplacement(queryName) + "=[^&]*&?";
+		return queryParameters.replaceFirst(
+				Matcher.quoteReplacement(queryRegEx), "");
+	}
+
+	private boolean isStudent(Entity principal) {
+		return principal.getType().equals(EntityNames.STUDENT);
+	}
+
+	private boolean isParent(Entity principal) {
+		return principal.getType().equals(EntityNames.PARENT);
+	}
+
+	/**
+	 * Determines if the URI should be mutated to a teacher context for a
+	 * federated user.
+	 * 
+	 * @return - True if the user has teacher context, false otherwise
+	 */
+	private boolean mutateToTeacher() {
+		return (SecurityUtil.getUserContext() == SecurityUtil.UserContext.TEACHER_CONTEXT);
+	}
+
+	/**
+	 * Determines if the URI should be mutated to a staff context for a
+	 * federated user.
+	 * 
+	 * @return - True if the user has staff or dual context, false otherwise
+	 */
+	private boolean mutateToStaff() {
+		return ((SecurityUtil.getUserContext() == SecurityUtil.UserContext.STAFF_CONTEXT) || (SecurityUtil
+				.getUserContext() == SecurityUtil.UserContext.DUAL_CONTEXT));
+	}
+
+	private String getStudentIds(SLIPrincipal principal) {
+		Collection<String> studentIds;
+		Entity entity = principal.getEntity();
+		if (isStudent(entity)) {
+			studentIds = Arrays.asList(entity.getEntityId());
+		} else if (isParent(entity)) {
+			// use evil thread local to get the student list
+			studentIds = principal.getOwnedStudentIds();
+		} else {
+			studentIds = Collections.emptyList();
+		}
+		return StringUtils.join(studentIds, ",");
+	}
+
+	private String getStudentAcademicRecordsIds(Entity principal) {
+		return StringUtils.join(
+				getStudentRelatedRecords(principal,
+						EntityNames.STUDENT_ACADEMIC_RECORD), ",");
+	}
+
+	private String getStudentSectionAssocIds(SLIPrincipal principal) {
+		Set<String> assocIds = new HashSet<String>();
+		for (Entity student : principal.getOwnedStudentEntities()) {
+			assocIds.addAll(getStudentRelatedRecords(student,
+					EntityNames.STUDENT_SECTION_ASSOCIATION));
+		}
+		return StringUtils.join(assocIds, ",");
+	}
+
+	private String getSectionIds(SLIPrincipal principal) {
+		Collection<String> sectionIds = new HashSet<String>();
+		for (Entity student : principal.getOwnedStudentEntities()) {
+			sectionIds.addAll(sectionHelper.getStudentsSections(student));
+		}
+		return StringUtils.join(sectionIds, ",");
+	}
+
+	private String getProgramIds(SLIPrincipal principal) {
+		Set<String> programIds = new HashSet<String>();
+		for (Entity student : principal.getOwnedStudentEntities()) {
+			programIds.addAll(getProgramIdsForStudent(student));
+		}
+
+		return StringUtils.join(programIds, ",");
+	}
+
+	private Set<String> getProgramIdsForStudent(Entity student) {
+		Set<String> programsIds = null;
+		if (isStudent(student)) {
+			programsIds = getSubdocIds(student,
+					EntityNames.STUDENT_PROGRAM_ASSOCIATION,
+					ParameterConstants.PROGRAM_ID);
+		} else {
+			throw new UriMutationException("No student found");
+		}
+
+		return programsIds;
+	}
+
+	private String getCohortIds(SLIPrincipal principal) {
+		Set<String> cohortsIds = new HashSet<String>();
+		for (Entity student : principal.getOwnedStudentEntities()) {
+			cohortsIds.addAll(getCohortIdsForStudent(student));
+		}
+
+		return StringUtils.join(cohortsIds, ",");
+	}
+
+	private Set<String> getCohortIdsForStudent(Entity student) {
+		Set<String> cohortsIds = null;
+		if (isStudent(student)) {
+			cohortsIds = getSubdocIds(student,
+					EntityNames.STUDENT_COHORT_ASSOCIATION,
+					ParameterConstants.COHORT_ID);
+		}
+
+		else {
+			throw new UriMutationException("No student found");
+		}
+		return cohortsIds;
+	}
+
+	private Set<String> getSubdocIds(Entity superdoc, String subdocType,
+			String subdocField) {
+		Set<String> subdocFields = new HashSet<String>();
+		Map<String, List<Entity>> myEmbeddedData = superdoc.getEmbeddedData();
+		List<Entity> myAssociations = myEmbeddedData == null ? Collections
+				.<Entity> emptyList() : myEmbeddedData.get(subdocType);
+		if (myAssociations != null && !myAssociations.isEmpty()) {
+			for (Entity association : myAssociations) {
+				if (!dateHelper.isFieldExpired(association.getBody(),
+						ParameterConstants.END_DATE)) {
+					subdocFields.add((String) association.getBody().get(
+							subdocField));
+				}
+			}
+		}
+
+		return subdocFields;
+	}
+
+	private List<String> getStudentRelatedRecords(Entity principal,
+			String entityType) {
+		NeutralQuery query = new NeutralQuery(new NeutralCriteria(
+				ParameterConstants.STUDENT_ID, NeutralCriteria.CRITERIA_IN,
+				SecurityUtil.getSLIPrincipal().getOwnedStudentIds()));
+		List<String> recordIds = new ArrayList<String>();
+
+		Iterable<String> allIds = repo.findAllIds(entityType, query);
+
+		for (String recordId : allIds) {
+			recordIds.add(recordId);
+		}
+
+		return recordIds;
+	}
+
+	private MutatedContainer formQueryBasedOnParameter(String path,
+			String parameters, String parameter) {
+		MutatedContainer mutated = new MutatedContainer();
+
+		String[] queryParameters = parameters.split("&");
+		for (int i = 0; i < queryParameters.length; i++) {
+			String queryParameter = queryParameters[i];
+			String[] values = queryParameter.split("=");
+			if (values.length == 2) {
+				if (values[0].equals(parameter) && values[1] != null
+						&& !values[1].isEmpty()) {
+					mutated.setPath(String.format(path, values[1]));
+					mutated.setQueryParameters(removeQueryParameter(parameters,
+							parameter));
+					break;
+				}
+			}
+		}
+
+		return mutated;
+	}
+
+	private String removeQueryParameter(String parameters,
+			String queryParameterToRemove) {
+		if (parameters == null || parameters.isEmpty()) {
+			return parameters;
+		}
+
+		StringBuilder builder = new StringBuilder();
+		String[] queryParameters = parameters.split("&");
+		for (String queryParameter : queryParameters) {
+			if (!queryParameter.startsWith(queryParameterToRemove)) {
+				builder.append(queryParameter).append("&");
+			}
+		}
+
+		if (builder.length() > 0) {
+			return builder.substring(0, builder.length() - 2);
+		}
+		return "";
+	}
+
+	/**
+	 * Inject section helper (for unit testing).
+	 * 
+	 * @param sectionHelper
+	 *            resolver for tying entity to sections.
+	 */
+	protected void setSectionHelper(SectionHelper sectionHelper) {
+		this.sectionHelper = sectionHelper;
+	}
+
+	/**
+	 * Inject education organization helper (for unit testing).
+	 * 
+	 * @param edOrgHelper
+	 *            resolver for tying entity to education organizations.
+	 */
+	protected void setEdOrgHelper(EdOrgHelper edOrgHelper) {
+		this.edOrgHelper = edOrgHelper;
+	}
 }
diff --git a/sli/api/src/main/java/org/slc/sli/api/translator/URITranslator.java b/sli/api/src/main/java/org/slc/sli/api/translator/URITranslator.java
index 77dbc2b5ef719d167bd377149aac8bce64722978..4475708553688d679c6b116839b1fe9b0016e0b8 100644
--- a/sli/api/src/main/java/org/slc/sli/api/translator/URITranslator.java
+++ b/sli/api/src/main/java/org/slc/sli/api/translator/URITranslator.java
@@ -27,6 +27,7 @@ import javax.ws.rs.core.PathSegment;
 import com.sun.jersey.spi.container.ContainerRequest;
 
 import org.apache.commons.lang3.StringUtils;
+import org.slc.sli.api.exceptions.URITranslationException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -37,7 +38,6 @@ import org.slc.sli.common.constants.EntityNames;
 import org.slc.sli.api.constants.PathConstants;
 import org.slc.sli.api.constants.ResourceNames;
 import org.slc.sli.api.security.context.PagingRepositoryDelegate;
-import org.slc.sli.api.service.EntityNotFoundException;
 import org.slc.sli.domain.Entity;
 import org.slc.sli.domain.NeutralCriteria;
 import org.slc.sli.domain.NeutralQuery;
@@ -242,7 +242,7 @@ public class URITranslator {
                 }
                 if (translatedIdList.isEmpty()) {
                     LOG.warn("Failed upversioning rewrite {} -> {} due not being able to find intermediate entities", requestPath, this.transformTo);
-                    throw new EntityNotFoundException("Upversioning rewrite failed.  No target entities found.");
+                    throw new URITranslationException("Upversioning rewrite failed.  No target entities found.");
                 }
             }
 
diff --git a/sli/api/src/test/java/org/slc/sli/api/representation/InsufficientAuthenticationHandlerTest.java b/sli/api/src/test/java/org/slc/sli/api/representation/InsufficientAuthenticationHandlerTest.java
index 56eafef35359cf83a912dd34a26509b3218f545f..37c064093c696e9c77a4cef0f00654c4491f95a5 100644
--- a/sli/api/src/test/java/org/slc/sli/api/representation/InsufficientAuthenticationHandlerTest.java
+++ b/sli/api/src/test/java/org/slc/sli/api/representation/InsufficientAuthenticationHandlerTest.java
@@ -27,10 +27,8 @@ import javax.ws.rs.core.Response;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.InjectMocks;
-import org.mockito.Mock;
 import org.mockito.Mockito;
-import org.mockito.stubbing.Answer;
+import org.slc.sli.api.jersey.exceptionhandlers.InsufficientAuthenticationHandler;
 import org.slc.sli.api.security.SecurityEventBuilder;
 import org.slc.sli.api.security.service.AuditLogger;
 import org.slc.sli.api.test.WebContextTestExecutionListener;
diff --git a/sli/api/src/test/java/org/slc/sli/api/representation/QueryParseExceptionHandlerTest.java b/sli/api/src/test/java/org/slc/sli/api/representation/QueryParseExceptionHandlerTest.java
index 1bd5dc8a270b33b325dc1568a85f5ee8b57aa167..d39c0b4642c7c611eb332af13a740142a089395d 100644
--- a/sli/api/src/test/java/org/slc/sli/api/representation/QueryParseExceptionHandlerTest.java
+++ b/sli/api/src/test/java/org/slc/sli/api/representation/QueryParseExceptionHandlerTest.java
@@ -19,6 +19,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
+import org.slc.sli.api.jersey.exceptionhandlers.QueryParseExceptionHandler;
 import org.slc.sli.domain.QueryParseException;
 
 import javax.ws.rs.core.Response;
diff --git a/sli/api/src/test/java/org/slc/sli/api/resources/security/AdminDelegationResourceTest.java b/sli/api/src/test/java/org/slc/sli/api/resources/security/AdminDelegationResourceTest.java
index f4107aca0ced7874c2e86648c1d631ecdf453de2..1e53c51b8ab62501eeeb6bf740548a7fa1438550 100644
--- a/sli/api/src/test/java/org/slc/sli/api/resources/security/AdminDelegationResourceTest.java
+++ b/sli/api/src/test/java/org/slc/sli/api/resources/security/AdminDelegationResourceTest.java
@@ -18,19 +18,14 @@
 package org.slc.sli.api.resources.security;
 
 import javax.ws.rs.core.Response;
-import javax.ws.rs.core.UriInfo;
 
 import junit.framework.Assert;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.slc.sli.api.representation.EntityBody;
 import org.slc.sli.api.resources.SecurityContextInjector;
-import org.slc.sli.api.resources.util.ResourceTestUtil;
 import org.slc.sli.api.security.SLIPrincipal;
-import org.slc.sli.api.security.SecurityEventBuilder;
-import org.slc.sli.api.service.EntityNotFoundException;
+import org.slc.sli.api.security.context.APIAccessDeniedException;
 import org.slc.sli.api.test.WebContextTestExecutionListener;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.security.core.context.SecurityContextHolder;
@@ -58,19 +53,18 @@ public class AdminDelegationResourceTest {
     @Autowired
     private SecurityContextInjector securityContextInjector;
 
-    @Test(expected = EntityNotFoundException.class)
+    @Test(expected = APIAccessDeniedException.class)
     public void testGetDelegationsNoEdOrg() throws Exception {
 
         securityContextInjector.setLeaAdminContext();
         resource.getDelegations();
-
     }
 
     @Test
     public void testGetDelegationsBadRole() throws Exception {
 
         securityContextInjector.setEducatorContext();
-        Assert.assertEquals(resource.getDelegations().getStatus(), Response.Status.FORBIDDEN.getStatusCode());
+        Assert.assertEquals(Response.Status.FORBIDDEN.getStatusCode(), resource.getDelegations().getStatus());
 
     }
 
@@ -82,6 +76,6 @@ public class AdminDelegationResourceTest {
         ((SLIPrincipal) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).setEdOrgId("1234");
 
 
-        Assert.assertEquals(resource.getSingleDelegation().getStatus(), Response.Status.NOT_FOUND.getStatusCode());
+        Assert.assertEquals(Response.Status.NOT_FOUND.getStatusCode(), resource.getSingleDelegation().getStatus());
     }
 }
diff --git a/sli/api/src/test/java/org/slc/sli/api/resources/security/RealmResourceTest.java b/sli/api/src/test/java/org/slc/sli/api/resources/security/RealmResourceTest.java
index 1966135b0b85eae78bcd2e9c606fc009617efd03..43cf45754df1f032165922733979c68dc67e5b16 100644
--- a/sli/api/src/test/java/org/slc/sli/api/resources/security/RealmResourceTest.java
+++ b/sli/api/src/test/java/org/slc/sli/api/resources/security/RealmResourceTest.java
@@ -45,7 +45,6 @@ import org.springframework.test.context.support.DirtiesContextTestExecutionListe
 import org.slc.sli.api.representation.EntityBody;
 import org.slc.sli.api.resources.SecurityContextInjector;
 import org.slc.sli.api.resources.util.ResourceTestUtil;
-import org.slc.sli.api.service.EntityNotFoundException;
 import org.slc.sli.api.service.EntityService;
 import org.slc.sli.api.test.WebContextTestExecutionListener;
 
@@ -117,7 +116,7 @@ public class RealmResourceTest {
 
             resource.updateRealm("-1", null, null);
             assertFalse(false);
-        } catch (EntityNotFoundException e) {
+        } catch (IllegalArgumentException e) {
             assertTrue(true);
         }
         UriInfo uriInfo = ResourceTestUtil.buildMockUriInfo("");
diff --git a/sli/api/src/test/java/org/slc/sli/api/security/context/ContextValidatorTest.java b/sli/api/src/test/java/org/slc/sli/api/security/context/ContextValidatorTest.java
index ee4ccd46bb963b1c3381490bc8c875e4cc027c7c..db41aaefd0aa4bd82217db633f119ad9e5a8d109 100644
--- a/sli/api/src/test/java/org/slc/sli/api/security/context/ContextValidatorTest.java
+++ b/sli/api/src/test/java/org/slc/sli/api/security/context/ContextValidatorTest.java
@@ -252,14 +252,15 @@ public class ContextValidatorTest {
         Mockito.when(edOrgHelper.getDirectEdorgs(Mockito.eq(student1))).thenReturn(new HashSet<String>(Arrays.asList("edOrg1")));
         boolean isTransitive = false;
         Mockito.when(ownership.canAccess(student1, isTransitive)).thenReturn(true);
-
-        Collection<String> ids = new HashSet<String>(Arrays.asList("student1"));
-
+        
+        String id = "student1";
+        Collection<String> ids = new HashSet<String>(Arrays.asList(id));
+        
         try {
             contextValidator.validateContextToEntities(def, ids, isTransitive);
             Assert.fail();
         } catch (EntityNotFoundException ex) {
-            Assert.assertEquals("Could not locate " + def.getType() + " with ids " + ids, ex.getId());
+            Assert.assertEquals(id, ex.getId());
         }
     }
 
diff --git a/sli/api/src/test/java/org/slc/sli/api/security/pdp/UriMutatorTest.java b/sli/api/src/test/java/org/slc/sli/api/security/pdp/UriMutatorTest.java
index 109962b592bd6e7b29c400e8d357459ce24c6573..59a7e504cf2633268be88dd6a961be97b8dcdc50 100644
--- a/sli/api/src/test/java/org/slc/sli/api/security/pdp/UriMutatorTest.java
+++ b/sli/api/src/test/java/org/slc/sli/api/security/pdp/UriMutatorTest.java
@@ -117,11 +117,11 @@ public class UriMutatorTest {
         when(v1.getPath()).thenReturn("v1");
 
         when(principal.getEntity()).thenReturn(staff);
-        Assert.assertEquals("Bad endpoint of /v1 is redirected to v1/home safely", createMutatedContainer("/home", ""),
-                mutator.mutate(Arrays.asList(v1), null, principal, "nonAdminAppId"));
+        Assert.assertEquals("Bad endpoint of /v1 is redirected to v1/home safely", createMutatedContainer("/home", "").toString(),
+                mutator.mutate(Arrays.asList(v1), null, principal, "nonAdminAppId").toString());
         when(principal.getEntity()).thenReturn(teacher);
-        Assert.assertEquals("Bad endpoint of /v1 is redirected to v1/home safely", createMutatedContainer("/home", ""),
-                mutator.mutate(Arrays.asList(v1), null, principal, "nonAdminAppId"));
+        Assert.assertEquals("Bad endpoint of /v1 is redirected to v1/home safely", createMutatedContainer("/home", "").toString(),
+                mutator.mutate(Arrays.asList(v1), null, principal, "nonAdminAppId").toString());
     }
 
     @Test
diff --git a/sli/new.diff b/sli/new.diff
new file mode 100644
index 0000000000000000000000000000000000000000..2fe22ee5e170ff632e5005080378cbcc307a35ea
--- /dev/null
+++ b/sli/new.diff
@@ -0,0 +1,3465 @@
+diff --git a/sli/acceptance-tests/test/features/security/path_checking_security.feature b/sli/acceptance-tests/test/features/security/path_checking_security.feature
+index 64df240..fed8b93 100644
+--- a/sli/acceptance-tests/test/features/security/path_checking_security.feature
++++ b/sli/acceptance-tests/test/features/security/path_checking_security.feature
+@@ -181,7 +181,7 @@ Scenario Outline: Deny multiple IDs in URI if those IDs are rewritten to query p
+ #NOTE: This test will need to be reworked if the API is ever made to support multiple ids in query params
+     Given I am logged in using "rrogers" "rrogers1234" to realm "IL"
+      When I call <Path> using ID <IDs>
+-     Then I should receive a return code of 413
++     Then I should receive a return code of 400
+ 
+ Examples:
+   | Path                                   | IDs                                    |
+diff --git a/sli/api/src/main/java/org/slc/sli/api/exceptions/EntityTypeNotFoundException.java b/sli/api/src/main/java/org/slc/sli/api/exceptions/EntityTypeNotFoundException.java
+new file mode 100644
+index 0000000..9802cf4
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/exceptions/EntityTypeNotFoundException.java
+@@ -0,0 +1,28 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.exceptions;
++
++/**
++ * Indicates that looking up an entity type was unsuccessful.
++ */
++public class EntityTypeNotFoundException extends RuntimeException {
++    private static final long serialVersionUID = 1L;
++
++    public EntityTypeNotFoundException(String message) {
++        super(message);
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/exceptions/RequestBlockedException.java b/sli/api/src/main/java/org/slc/sli/api/exceptions/RequestBlockedException.java
+new file mode 100644
+index 0000000..0563514
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/exceptions/RequestBlockedException.java
+@@ -0,0 +1,28 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.exceptions;
++
++/**
++ * Indicates that a request to the API has been blocked.
++ */
++public class RequestBlockedException extends RuntimeException {
++    private static final long serialVersionUID = 1L;
++
++    public RequestBlockedException(String message) {
++        super(message);
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/exceptions/URITranslationException.java b/sli/api/src/main/java/org/slc/sli/api/exceptions/URITranslationException.java
+new file mode 100644
+index 0000000..f35ee79
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/exceptions/URITranslationException.java
+@@ -0,0 +1,28 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.exceptions;
++
++/**
++ * Indicates a failure of URI translation.
++ */
++public class URITranslationException extends RuntimeException {
++    private static final long serialVersionUID = 1L;
++
++    public URITranslationException(String message) {
++        super(message);
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/exceptions/UriMutationException.java b/sli/api/src/main/java/org/slc/sli/api/exceptions/UriMutationException.java
+new file mode 100644
+index 0000000..8034000
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/exceptions/UriMutationException.java
+@@ -0,0 +1,28 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.exceptions;
++
++/**
++ * Indicates that a student was not in any cohorts or programs.
++ */
++public class UriMutationException extends RuntimeException {
++    private static final long serialVersionUID = 1L;
++
++    public UriMutationException(String message) {
++        super(message);
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/PreProcessFilter.java b/sli/api/src/main/java/org/slc/sli/api/jersey/PreProcessFilter.java
+index f9e86fe..83a3d65 100644
+--- a/sli/api/src/main/java/org/slc/sli/api/jersey/PreProcessFilter.java
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/PreProcessFilter.java
+@@ -23,6 +23,7 @@ import org.slc.sli.api.config.EntityDefinitionStore;
+ import org.slc.sli.api.constants.PathConstants;
+ import org.slc.sli.api.constants.ResourceNames;
+ import org.slc.sli.api.criteriaGenerator.DateFilterCriteriaGenerator;
++import org.slc.sli.api.exceptions.RequestBlockedException;
+ import org.slc.sli.api.resources.generic.MethodNotAllowedException;
+ import org.slc.sli.api.resources.generic.config.ResourceEndPoint;
+ import org.slc.sli.api.resources.generic.util.ResourceMethod;
+@@ -286,7 +287,7 @@ public class PreProcessFilter implements ContainerRequestFilter {
+         }
+ 
+         if (this.resourceEndPoint.getBlockGetRequestEndPoints().contains(requestPath)) {
+-            throw new EntityNotFoundException(request.getPath());
++            throw new RequestBlockedException(request.getPath());
+         }
+     }
+ }
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/APIAccessDeniedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/APIAccessDeniedExceptionHandler.java
+new file mode 100644
+index 0000000..6ed2e17
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/APIAccessDeniedExceptionHandler.java
+@@ -0,0 +1,133 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.security.SLIPrincipal;
++import org.slc.sli.api.security.SecurityEventBuilder;
++import org.slc.sli.api.security.context.APIAccessDeniedException;
++import org.slc.sli.api.security.service.AuditLogger;
++import org.slc.sli.common.constants.EntityNames;
++import org.slf4j.Logger;
++import org.slf4j.LoggerFactory;
++import org.springframework.beans.factory.annotation.Autowired;
++import org.springframework.security.core.context.SecurityContextHolder;
++import org.springframework.stereotype.Component;
++
++import javax.servlet.http.HttpServletResponse;
++import javax.ws.rs.core.*;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++import java.io.IOException;
++
++/**
++ * Handler for catching API access denied exceptions that log security events.
++ *
++ * @author bsuzuki
++ */
++@Provider
++@Component
++public class APIAccessDeniedExceptionHandler implements ExceptionMapper<APIAccessDeniedException> {
++
++    private static final Logger LOG = LoggerFactory.getLogger(APIAccessDeniedExceptionHandler.class);
++
++    @Autowired
++    private SecurityEventBuilder securityEventBuilder;
++
++    @Autowired
++    private AuditLogger auditLogger;
++
++    @Context
++    UriInfo uriInfo;
++
++    @Context
++    private HttpHeaders headers;
++
++    @Context
++    private HttpServletResponse response;
++
++    @Override
++    public Response toResponse(APIAccessDeniedException e) {
++        //There are a few jax-rs resources that generate HTML content, and we want the
++        //default web-container error handler pages to get used in those cases.
++        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
++            try {
++                response.sendError(403, e.getMessage());
++                logSecurityEvent(e);
++                return null;    //the error page handles the response, so no need to return a response
++            } catch (IOException ex) {
++                LOG.error("Error displaying error page", ex);
++            }
++        }
++
++        Response.Status errorStatus = Response.Status.FORBIDDEN;
++        SLIPrincipal principal = null ;
++        if (SecurityContextHolder.getContext().getAuthentication() != null) {
++            principal = (SLIPrincipal)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
++            LOG.warn("Access has been denied to user: {}",principal );
++        } else {
++            LOG.warn("Access has been denied to user for being incorrectly associated");
++        }
++        LOG.warn("Cause: {}", e.getMessage());
++
++        logSecurityEvent(e);
++
++        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
++        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
++            errorType = MediaType.APPLICATION_XML_TYPE;
++        }
++        
++        return Response.status(errorStatus).entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), "Access DENIED: " + e.getMessage())).type(errorType).build();
++    }
++
++    private void logSecurityEvent(APIAccessDeniedException e) {
++
++        if (e.getTargetEdOrgIds() != null) {
++            // if we already have the target edOrgs - good to go
++            auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
++                    + e.getMessage(), e.getRealm(), EntityNames.EDUCATION_ORGANIZATION, e.getTargetEdOrgIds().toArray(new String[0])));
++
++        } else if (e.getEntityType() != null) {
++
++            if (e.getEntities() != null && !e.getEntities().isEmpty()) {
++                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
++                        + e.getMessage(), e.getRealm(), e.getEntityType(), e.getEntities()));
++
++            } else if (e.getEntityIds() != null && !e.getEntityIds().isEmpty()) {
++                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
++                        + e.getMessage(), e.getRealm(), e.getEntityType(), e.getEntityIds().toArray(new String[0])));
++            } else {
++                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
++                        + e.getMessage(), e.getPrincipal(), e.getClientId(), e.getRealm(), null, e.isTargetIsUserEdOrg()));
++            }
++        } else {
++            auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
++                    + e.getMessage(), e.getPrincipal(), e.getClientId(), e.getRealm(), null, e.isTargetIsUserEdOrg()));
++        }
++    }
++
++    private String getThrowingClassName(Exception e) {
++        if (e != null && e.getStackTrace() != null) {
++            StackTraceElement ste = e.getStackTrace()[0];
++            if (ste != null) {
++                return ste.getClassName();
++            }
++        }
++        return null;
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/AccessDeniedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/AccessDeniedExceptionHandler.java
+new file mode 100644
+index 0000000..9b75f17
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/AccessDeniedExceptionHandler.java
+@@ -0,0 +1,102 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import java.io.IOException;
++
++import javax.servlet.http.HttpServletResponse;
++import javax.ws.rs.core.Context;
++import javax.ws.rs.core.HttpHeaders;
++import javax.ws.rs.core.MediaType;
++import javax.ws.rs.core.Response;
++import javax.ws.rs.core.UriInfo;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slf4j.Logger;
++import org.slf4j.LoggerFactory;
++import org.springframework.beans.factory.annotation.Autowired;
++import org.springframework.security.access.AccessDeniedException;
++import org.springframework.security.core.context.SecurityContextHolder;
++import org.springframework.stereotype.Component;
++
++import org.slc.sli.api.security.SLIPrincipal;
++import org.slc.sli.api.security.SecurityEventBuilder;
++
++/**
++ * Handler for catching access denied exceptions.
++ *
++ * @author shalka
++ */
++@Provider
++@Component
++public class AccessDeniedExceptionHandler implements ExceptionMapper<AccessDeniedException> {
++
++    private static final Logger LOG = LoggerFactory.getLogger(AccessDeniedExceptionHandler.class);
++
++    public static final String ED_ORG_START = "<" ;
++    public static final String ED_ORG_END = ">" ;
++    public static final String NO_EDORG = "UNAVAILABLE";
++
++    @Autowired
++    private SecurityEventBuilder securityEventBuilder;
++
++    @Context
++    UriInfo uriInfo;
++
++    @Context
++    private HttpHeaders headers;
++
++    @Context
++    private HttpServletResponse response;
++
++    @Override
++    public Response toResponse(AccessDeniedException e) {
++
++        //There are a few jax-rs resources that generate HTML content, and we want the
++        //default web-container error handler pages to get used in those cases.
++        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
++            try {
++                response.sendError(403, e.getMessage());
++                return null;    //the error page handles the response, so no need to return a response
++            } catch (IOException ex) {
++                LOG.error("Error displaying error page", ex);
++            }
++        }
++
++        Response.Status errorStatus = Response.Status.FORBIDDEN;
++        SLIPrincipal principal = null ;
++        String message = e.getMessage();
++        if (SecurityContextHolder.getContext().getAuthentication() != null) {
++            principal = (SLIPrincipal)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
++            LOG.warn("Access has been denied to user: {}",principal );
++        } else {
++            LOG.warn("Access has been denied to user for being incorrectly associated");
++        }
++        LOG.warn("Cause: {}", e.getMessage());
++
++        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
++        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
++            errorType = MediaType.APPLICATION_XML_TYPE;
++        }
++        
++        return Response.status(errorStatus).entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), "Access DENIED: " + e.getMessage())).type(errorType).build();
++    }
++
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ContextInferrenceFailedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ContextInferrenceFailedExceptionHandler.java
+new file mode 100644
+index 0000000..54779bf
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ContextInferrenceFailedExceptionHandler.java
+@@ -0,0 +1,71 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import java.util.Collections;
++
++import javax.ws.rs.core.Context;
++import javax.ws.rs.core.HttpHeaders;
++import javax.ws.rs.core.MediaType;
++import javax.ws.rs.core.Response;
++import javax.ws.rs.core.Response.Status;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++import javax.xml.bind.annotation.XmlRootElement;
++
++import org.slc.sli.api.security.pdp.ContextInferrenceFailedException;
++import org.slf4j.Logger;
++import org.slf4j.LoggerFactory;
++import org.springframework.stereotype.Component;
++
++/**
++ * Handles empty contexts
++ * 
++ * @author dkornishev
++ * 
++ */
++@Provider
++@Component
++public class ContextInferrenceFailedExceptionHandler implements ExceptionMapper<ContextInferrenceFailedException> {
++
++    private static final Logger LOG = LoggerFactory.getLogger(ContextInferrenceFailedExceptionHandler.class);
++
++    @Context
++    private HttpHeaders headers;
++    
++    @Override
++    public Response toResponse(ContextInferrenceFailedException exception) {
++        LOG.warn("Failed Context Inferrence");
++        Object entity = Collections.EMPTY_LIST;
++        if (headers.getAcceptableMediaTypes().contains(MediaType.APPLICATION_XML_TYPE)) {
++            entity = new EmptyResponse();
++        }
++        
++        return Response.status(Status.NOT_FOUND).entity(entity).header("TotalCount", 0).build();
++    }
++    
++    /**
++     * Represents an empty document to be returned to the API user (no fields, no data).
++     * 
++     * 
++     * @author kmyers
++     *
++     */
++    @XmlRootElement(name = "emptyList")
++    public static class EmptyResponse {
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EOFExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EOFExceptionHandler.java
+new file mode 100644
+index 0000000..43fcce3
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EOFExceptionHandler.java
+@@ -0,0 +1,43 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import java.io.EOFException;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.springframework.stereotype.Component;
++
++/**
++ * Exception handler to catch cases where an EOF exception is thrown. This can be the case if a user
++ * tries to post a null body
++ *
++ * @author nbrown
++ *
++ */
++@Provider
++@Component
++public class EOFExceptionHandler implements ExceptionMapper<EOFException> {
++
++    @Override
++    public Response toResponse(EOFException exception) {
++        return Response.status(Response.Status.BAD_REQUEST).build();
++    }
++
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EmbeddedDocumentLimitExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EmbeddedDocumentLimitExceptionHandler.java
+new file mode 100644
+index 0000000..85ca037
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EmbeddedDocumentLimitExceptionHandler.java
+@@ -0,0 +1,43 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.CustomStatus;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.selectors.doc.EmbeddedDocumentLimitException;
++import org.springframework.stereotype.Component;
++
++/**
++ * @author jstokes
++ */
++@Provider
++@Component
++public class EmbeddedDocumentLimitExceptionHandler implements ExceptionMapper<EmbeddedDocumentLimitException> {
++
++    @Override
++    public Response toResponse(EmbeddedDocumentLimitException e) {
++        return Response
++                .status(CustomStatus.ENTITY_TOO_LARGE)
++                .entity(new ErrorResponse(CustomStatus.ENTITY_TOO_LARGE.getStatusCode(), CustomStatus.ENTITY_TOO_LARGE.getReasonPhrase(),
++                        e.getMessage())).build();
++    }
++}
++
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityNotFoundHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityNotFoundHandler.java
+new file mode 100644
+index 0000000..2bf4379
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityNotFoundHandler.java
+@@ -0,0 +1,43 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.springframework.stereotype.Component;
++
++import org.slc.sli.api.service.EntityNotFoundException;
++
++/**
++ * Hander for entity not found errors
++ */
++@Provider
++@Component
++public class EntityNotFoundHandler implements ExceptionMapper<EntityNotFoundException> {
++
++    public Response toResponse(EntityNotFoundException e) {
++        Response.Status errorStatus = Response.Status.NOT_FOUND;
++        return Response
++                .status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                        "Entity not found: " + e.getId())).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityTypeNotFoundHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityTypeNotFoundHandler.java
+new file mode 100644
+index 0000000..499be49
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/EntityTypeNotFoundHandler.java
+@@ -0,0 +1,47 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.slc.sli.api.exceptions.EntityTypeNotFoundException;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.service.EntityNotFoundException;
++import org.springframework.stereotype.Component;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++/**
++ * Handler for entity type not found errors
++ */
++@Provider
++@Component
++public class EntityTypeNotFoundHandler implements ExceptionMapper<EntityTypeNotFoundException> {
++
++    public Response toResponse(EntityTypeNotFoundException e) {
++        String message = "entity type not found";
++        if (e.getMessage() != null) {
++            message += ": " + e.getMessage();
++        }
++        Response.Status errorStatus = Response.Status.NOT_FOUND;
++        return Response
++                .status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                        message)).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/GenericExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/GenericExceptionHandler.java
+new file mode 100644
+index 0000000..1ec9692
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/GenericExceptionHandler.java
+@@ -0,0 +1,72 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import java.io.IOException;
++
++import javax.servlet.http.HttpServletResponse;
++import javax.ws.rs.core.Context;
++import javax.ws.rs.core.HttpHeaders;
++import javax.ws.rs.core.MediaType;
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slf4j.Logger;
++import org.slf4j.LoggerFactory;
++import org.springframework.stereotype.Component;
++
++/**
++ * Hander for uncaught errors
++ */
++@Provider
++@Component
++public class GenericExceptionHandler implements ExceptionMapper<Throwable> {
++
++    private static final Logger LOG = LoggerFactory.getLogger(GenericExceptionHandler.class);
++    
++    @Context
++    private HttpHeaders headers;
++    
++    @Context
++    private HttpServletResponse response;
++
++    @Override
++    public Response toResponse(Throwable e) {
++
++        //There are a few jax-rs resources that generate HTML content, and we want the
++        //default web-container error handler pages to get used in those cases.
++        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
++            try {
++                LOG.error(e.getMessage(), e);
++                response.sendError(500, e.getMessage());
++                return null;    //the error page handles the response, so no need to return a response
++            } catch (IOException ex) {
++                LOG.error("Error displaying error page", ex);
++            }
++        }
++        Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;
++        
++        LOG.error("Caught exception thrown by ReST handler", e);
++        return Response
++                .status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                        "Internal Server Error: " + e.getMessage())).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/IllegalArgumentExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/IllegalArgumentExceptionHandler.java
+new file mode 100644
+index 0000000..66c4764
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/IllegalArgumentExceptionHandler.java
+@@ -0,0 +1,38 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.core.Response.Status;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.springframework.stereotype.Component;
++
++/**
++ * Handles bad requests
++  */
++@Provider
++@Component
++public class IllegalArgumentExceptionHandler implements ExceptionMapper<IllegalArgumentException> {
++
++    @Override
++    public Response toResponse(IllegalArgumentException e) {
++        return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/InsufficientAuthenticationHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/InsufficientAuthenticationHandler.java
+new file mode 100644
+index 0000000..5a237e2
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/InsufficientAuthenticationHandler.java
+@@ -0,0 +1,105 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.*;
++import javax.ws.rs.core.Response.Status;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.security.SecurityEventBuilder;
++import org.slc.sli.api.security.oauth.OAuthAccessException;
++import org.slc.sli.api.security.service.AuditLogger;
++import org.springframework.beans.factory.annotation.Autowired;
++import org.springframework.beans.factory.annotation.Value;
++import org.springframework.security.authentication.InsufficientAuthenticationException;
++import org.springframework.stereotype.Component;
++
++import java.net.URI;
++
++/**
++ * Translates InsufficientAuthenticationException to 401
++ *
++ * @author dkornishev
++ *
++ */
++@Component
++@Provider
++public class InsufficientAuthenticationHandler implements ExceptionMapper<InsufficientAuthenticationException> {
++
++    @Value("${sli.security.noSession.landing.url}")
++    private String authUrl;
++
++    @Autowired
++    private SecurityEventBuilder securityEventBuilder;
++
++    @Autowired
++    private AuditLogger auditLogger;
++
++    @Context
++    UriInfo uriInfo;
++
++    @Context
++    private HttpHeaders headers;
++
++    @Override
++    public Response toResponse(InsufficientAuthenticationException exception) {
++        Status status = Response.Status.UNAUTHORIZED;
++        String wwwAuthHeader = this.authUrl;
++        URI requestUri = (uriInfo == null) ? null : uriInfo.getRequestUri();
++
++        //If we have an embedded OAuth exception, then put the error information in the www-auth header per oauth spec 
++        //http://tools.ietf.org/html/rfc6750 see sec 3
++        //Otherwise put the auth url in the header
++        if (exception.getCause() != null && exception.getCause() instanceof OAuthAccessException) {
++            OAuthAccessException oauthEx = (OAuthAccessException) exception.getCause();
++            wwwAuthHeader = "Bearer error=\"" + oauthEx.getType().toString() + "\", error_description=\"" + oauthEx.getMessage() + "\"";
++        }
++        
++        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
++        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
++            errorType = MediaType.APPLICATION_XML_TYPE;
++        }
++
++        auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(exception), requestUri, "Access Denied: "
++                + exception.getMessage(), false));
++
++        return Response.status(status).entity(new ErrorResponse(status.getStatusCode(), status.getReasonPhrase(),
++                "Access DENIED: " + exception.getMessage())).header(HttpHeaders.WWW_AUTHENTICATE, wwwAuthHeader).type(errorType).build();
++    }
++
++    private String getThrowingClassName(Exception e) {
++        if (e != null && e.getStackTrace() != null) {
++            StackTraceElement ste = e.getStackTrace()[0];
++            if (ste != null) {
++                return ste.getClassName();
++            }
++        }
++        return null;
++    }
++
++    public void setSecurityEventBuilder(SecurityEventBuilder securityEventBuilder) {
++        this.securityEventBuilder = securityEventBuilder;
++    }
++
++    public void setAuditLogger(AuditLogger auditLogger) {
++        this.auditLogger = auditLogger;
++    }
++
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/JsonParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/JsonParseExceptionHandler.java
+new file mode 100644
+index 0000000..0de45dd
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/JsonParseExceptionHandler.java
+@@ -0,0 +1,46 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.codehaus.jackson.JsonParseException;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.springframework.stereotype.Component;
++
++/**
++ * Exception handler for SortingExceptions
++ * 
++ * @author Ryan Farris <rfarris@wgen.net>
++ * 
++ */
++@Provider
++@Component
++public class JsonParseExceptionHandler implements ExceptionMapper<JsonParseException> {
++    
++    @Override
++    public Response toResponse(JsonParseException e) {
++        Response.Status errorStatus = Response.Status.BAD_REQUEST;
++        return Response.status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), e.getMessage()))
++                .build();
++    }
++    
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/MethodNotAllowedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/MethodNotAllowedExceptionHandler.java
+new file mode 100644
+index 0000000..ebac379
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/MethodNotAllowedExceptionHandler.java
+@@ -0,0 +1,49 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.resources.generic.MethodNotAllowedException;
++import org.springframework.stereotype.Component;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++/**
++ * Exception mapper for dis allowed methods
++ *
++ * @author srupasinghe
++ */
++
++@Provider
++@Component
++public class MethodNotAllowedExceptionHandler implements ExceptionMapper<MethodNotAllowedException> {
++
++    public Response toResponse(MethodNotAllowedException e) {
++        String message = "Method Not Allowed [" + e.getAllowedMethods() + "]";
++
++        Response.ResponseBuilder builder =  Response
++                .status(405)
++                .entity(new ErrorResponse(405, "Method Not Allowed",
++                        message));
++
++        builder.header("Allow", "Allow: " + e.getAllowedMethods());
++
++        return builder.build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/NaturalKeyValidationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/NaturalKeyValidationExceptionHandler.java
+new file mode 100644
+index 0000000..640d702
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/NaturalKeyValidationExceptionHandler.java
+@@ -0,0 +1,44 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.apache.commons.lang3.StringUtils;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.validation.NaturalKeyValidationException;
++import org.springframework.stereotype.Component;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++/**
++ * Exception mapper NaturalKeyValidationExceptions
++ *
++ * @author srupasinghe
++ */
++@Provider
++@Component
++public class NaturalKeyValidationExceptionHandler implements ExceptionMapper<NaturalKeyValidationException> {
++
++    public Response toResponse(NaturalKeyValidationException e) {
++        String exceptionMessage = "Natural Key Validation failed: " + e.getEntityType() + " " + StringUtils.join(e.getNaturalKeys());
++        return Response
++                .status(Response.Status.CONFLICT)
++                .entity(new ErrorResponse(Response.Status.CONFLICT.getStatusCode(), Response.Status.CONFLICT.getReasonPhrase(),
++                        exceptionMessage)).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/OAuthAccessExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/OAuthAccessExceptionHandler.java
+new file mode 100644
+index 0000000..3450058
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/OAuthAccessExceptionHandler.java
+@@ -0,0 +1,64 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import java.util.HashMap;
++import java.util.Map;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.springframework.stereotype.Component;
++
++import org.slc.sli.api.security.oauth.OAuthAccessException;
++import org.slc.sli.api.security.oauth.OAuthAccessException.OAuthError;
++
++/**
++ *
++ * Handle oauth access exceptions as described in 5.2
++ */
++@Component
++@Provider
++public class OAuthAccessExceptionHandler implements ExceptionMapper<OAuthAccessException>  {
++
++
++    @SuppressWarnings("unchecked")
++    @Override
++    public Response toResponse(OAuthAccessException ex) {
++
++        Response.Status errorStatus = null;
++
++        if (ex.getType() == OAuthError.UNAUTHORIZED_CLIENT) {
++            errorStatus = Response.Status.FORBIDDEN;
++        } else {
++            errorStatus = Response.Status.BAD_REQUEST;
++        }
++
++        @SuppressWarnings("rawtypes")
++        Map data = new HashMap();
++        data.put("error", ex.getType().toString());
++        data.put("error_description", ex.getMessage());
++        if (ex.getState() != null) {
++            data.put("state", ex.getState());
++        }
++        return Response.status(errorStatus).entity(data).build();
++
++    }
++
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/PreConditionExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/PreConditionExceptionHandler.java
+new file mode 100644
+index 0000000..670f1b5
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/PreConditionExceptionHandler.java
+@@ -0,0 +1,45 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.resources.generic.PreConditionFailedException;
++import org.springframework.stereotype.Component;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++/**
++ * Exception mapper for precondition failures
++ *
++ * @author srupasinghe
++ */
++
++@Provider
++@Component
++public class PreConditionExceptionHandler implements ExceptionMapper<PreConditionFailedException> {
++
++    public Response toResponse(PreConditionFailedException e) {
++
++        return Response
++                .status(Response.Status.PRECONDITION_FAILED)
++                .entity(new ErrorResponse(Response.Status.PRECONDITION_FAILED.getStatusCode(), Response.Status.PRECONDITION_FAILED.getReasonPhrase(),
++                        e.getMessage())).build();
++
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/QueryParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/QueryParseExceptionHandler.java
+new file mode 100644
+index 0000000..58d60cd
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/QueryParseExceptionHandler.java
+@@ -0,0 +1,43 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.springframework.stereotype.Component;
++
++import org.slc.sli.domain.QueryParseException;
++
++/**
++ * Handler for Query Parsing errors
++ */
++@Provider
++@Component
++public class QueryParseExceptionHandler implements ExceptionMapper<QueryParseException> {
++    
++    public Response toResponse(QueryParseException e) {
++        Response.Status errorStatus = Response.Status.BAD_REQUEST;
++        return Response
++                .status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                        "Error Parsing the Query: " + e.getMessage())).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/RequestBlockedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/RequestBlockedExceptionHandler.java
+new file mode 100644
+index 0000000..b40f777
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/RequestBlockedExceptionHandler.java
+@@ -0,0 +1,51 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.slc.sli.api.exceptions.RequestBlockedException;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.service.EntityNotFoundException;
++import org.springframework.stereotype.Component;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++/**
++ * Handler for RequestBlockedException
++ *
++ * We don't necessarily want to let the user know that their request is blocked, so
++ * we'll return an HTTP 404 (not found) error code.
++ */
++@Provider
++@Component
++public class RequestBlockedExceptionHandler implements ExceptionMapper<RequestBlockedException> {
++
++    public Response toResponse(RequestBlockedException e) {
++        String message = "not found";
++        if (e.getMessage() != null) {
++            message += ": " + e.getMessage();
++        }
++
++        Response.Status errorStatus = Response.Status.NOT_FOUND;
++        return Response
++                .status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                        message)).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ResponseTooLargeExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ResponseTooLargeExceptionHandler.java
+new file mode 100644
+index 0000000..c770468
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ResponseTooLargeExceptionHandler.java
+@@ -0,0 +1,43 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.CustomStatus;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.security.context.ResponseTooLargeException;
++import org.springframework.stereotype.Component;
++
++/**
++ * Handler for when the response is too large to manage
++ */
++@Provider
++@Component
++public class ResponseTooLargeExceptionHandler implements ExceptionMapper<ResponseTooLargeException> {
++    
++    @Override
++    public Response toResponse(ResponseTooLargeException exception) {
++        
++        return Response
++                .status(CustomStatus.ENTITY_TOO_LARGE)
++                .entity(new ErrorResponse(CustomStatus.ENTITY_TOO_LARGE.getStatusCode(), CustomStatus.ENTITY_TOO_LARGE.getReasonPhrase(),
++                        "The response is too large to process. The request should be modified to return a smaller response.")).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SelectorParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SelectorParseExceptionHandler.java
+new file mode 100644
+index 0000000..b91c82d
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SelectorParseExceptionHandler.java
+@@ -0,0 +1,42 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.selectors.model.SelectorParseException;
++import org.springframework.stereotype.Component;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.core.Response.Status;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++/**
++ * @author jstokes
++ */
++@Provider
++@Component
++public class SelectorParseExceptionHandler implements ExceptionMapper<SelectorParseException> {
++
++    public Response toResponse(SelectorParseException e) {
++        return Response
++                .status(Response.Status.BAD_REQUEST)
++                .entity(new ErrorResponse(Status.BAD_REQUEST.getStatusCode(), Status.BAD_REQUEST.getReasonPhrase(),
++                        e.getMessage())).build();
++    }
++}
++
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SortingExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SortingExceptionHandler.java
+new file mode 100644
+index 0000000..801ecc8
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/SortingExceptionHandler.java
+@@ -0,0 +1,47 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.springframework.stereotype.Component;
++
++import org.slc.sli.api.service.query.SortingException;
++
++/**
++ * Exception handler for SortingExceptions
++ * 
++ * @author Ryan Farris <rfarris@wgen.net>
++ * 
++ */
++@Provider
++@Component
++public class SortingExceptionHandler implements ExceptionMapper<SortingException> {
++    
++    @Override
++    public Response toResponse(SortingException e) {
++        Response.Status errorStatus = Response.Status.BAD_REQUEST;
++        return Response.status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), e.getMessage()))
++                .build();
++    }
++    
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/URITranslationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/URITranslationExceptionHandler.java
+new file mode 100644
+index 0000000..17a6c42
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/URITranslationExceptionHandler.java
+@@ -0,0 +1,47 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.slc.sli.api.exceptions.URITranslationException;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slc.sli.api.service.EntityNotFoundException;
++import org.springframework.stereotype.Component;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++/**
++ * Handler for URI translation errors (gives an HTTP 404 not found response)
++ */
++@Provider
++@Component
++public class URITranslationExceptionHandler implements ExceptionMapper<URITranslationException> {
++
++    public Response toResponse(URITranslationException e) {
++        String message = "URI translation failed";
++        if (e.getMessage() != null) {
++            message += ": " + e.getMessage();
++        }
++        Response.Status errorStatus = Response.Status.NOT_FOUND;
++        return Response
++                .status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                        message)).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UncategorizedMongoExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UncategorizedMongoExceptionHandler.java
+new file mode 100644
+index 0000000..5e4552b
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UncategorizedMongoExceptionHandler.java
+@@ -0,0 +1,51 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.core.Response.Status;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slf4j.Logger;
++import org.slf4j.LoggerFactory;
++import org.springframework.data.mongodb.UncategorizedMongoDbException;
++import org.springframework.stereotype.Component;
++
++/**
++ * Handle connection issues to mongo
++ *
++ * @author nbrown
++ *
++ */
++@Provider
++@Component
++public class UncategorizedMongoExceptionHandler implements ExceptionMapper<UncategorizedMongoDbException> {
++
++    private static final Logger LOG = LoggerFactory.getLogger(UncategorizedMongoExceptionHandler.class);
++
++    @Override
++    public Response toResponse(UncategorizedMongoDbException exception) {
++        Status errorStatus = Status.SERVICE_UNAVAILABLE;
++        LOG.error("Could not access database", exception);
++        return Response
++                .status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                        "Could not access database:" + exception.getMessage())).build();
++    }
++
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UriMutationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UriMutationExceptionHandler.java
+new file mode 100644
+index 0000000..cda5415
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/UriMutationExceptionHandler.java
+@@ -0,0 +1,30 @@
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import org.slc.sli.api.exceptions.UriMutationException;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.springframework.stereotype.Component;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++/**
++ * Handler for UriMutationExceptions, which should result in an HTTP 404 not found
++ */
++@Provider
++@Component
++public class UriMutationExceptionHandler implements ExceptionMapper<UriMutationException> {
++
++    public Response toResponse(UriMutationException e) {
++        String message = "URI mutation error";
++        if (e.getMessage() != null) {
++            message += ": " + e.getMessage();
++        }
++
++        Response.Status errorStatus = Response.Status.NOT_FOUND;
++        return Response
++                .status(errorStatus)
++                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                        message)).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ValidationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ValidationExceptionHandler.java
+new file mode 100644
+index 0000000..c99ff45
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/ValidationExceptionHandler.java
+@@ -0,0 +1,45 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.core.Response;
++import javax.ws.rs.core.Response.Status;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.apache.commons.lang3.StringUtils;
++import org.slc.sli.api.representation.ErrorResponse;
++import org.springframework.stereotype.Component;
++
++import org.slc.sli.validation.EntityValidationException;
++
++/**
++ * Hander for validation errors
++ */
++@Provider
++@Component
++public class ValidationExceptionHandler implements ExceptionMapper<EntityValidationException> {
++
++    public Response toResponse(EntityValidationException e) {
++        String exceptionMessage = "Validation failed: " + StringUtils.join(e.getValidationErrors(), "\n");
++        return Response
++                .status(Response.Status.BAD_REQUEST)
++                .entity(new ErrorResponse(Status.BAD_REQUEST.getStatusCode(), Status.BAD_REQUEST.getReasonPhrase(),
++                        exceptionMessage)).build();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/WebApplicationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/WebApplicationExceptionHandler.java
+new file mode 100644
+index 0000000..5e30078
+--- /dev/null
++++ b/sli/api/src/main/java/org/slc/sli/api/jersey/exceptionhandlers/WebApplicationExceptionHandler.java
+@@ -0,0 +1,52 @@
++/*
++ * Copyright 2012-2013 inBloom, Inc. and its affiliates.
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++
++package org.slc.sli.api.jersey.exceptionhandlers;
++
++import javax.ws.rs.WebApplicationException;
++import javax.ws.rs.core.Response;
++import javax.ws.rs.ext.ExceptionMapper;
++import javax.ws.rs.ext.Provider;
++
++import org.slc.sli.api.representation.ErrorResponse;
++import org.slf4j.Logger;
++import org.slf4j.LoggerFactory;
++import org.springframework.stereotype.Component;
++
++/**
++ * Hander for jax-rs web application exceptions
++ */
++@Provider
++@Component
++public class WebApplicationExceptionHandler implements ExceptionMapper<WebApplicationException> {
++
++    public static final Logger LOG = LoggerFactory.getLogger(WebApplicationExceptionHandler.class);
++    
++    @Override
++    public Response toResponse(WebApplicationException e) {
++        if (e.getResponse().getStatus() == 500) {
++            LOG.error("Caught exception thrown by ReST handler", e);
++            Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;
++            
++            return Response
++                    .status(errorStatus)
++                    .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
++                            "Internal Server Error: " + e.getMessage())).build();
++        }
++        return e.getResponse();
++    }
++}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/APIAccessDeniedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/APIAccessDeniedExceptionHandler.java
+deleted file mode 100644
+index 6bfd4f5..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/APIAccessDeniedExceptionHandler.java
++++ /dev/null
+@@ -1,138 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import org.slc.sli.api.config.EntityDefinitionStore;
+-import org.slc.sli.api.resources.security.RealmResource;
+-import org.slc.sli.api.security.SLIPrincipal;
+-import org.slc.sli.api.security.SecurityEventBuilder;
+-import org.slc.sli.api.security.context.APIAccessDeniedException;
+-import org.slc.sli.api.security.context.EdOrgOwnershipArbiter;
+-import org.slc.sli.api.security.context.PagingRepositoryDelegate;
+-import org.slc.sli.api.security.service.AuditLogger;
+-import org.slc.sli.common.constants.EntityNames;
+-import org.slc.sli.domain.Entity;
+-import org.slf4j.Logger;
+-import org.slf4j.LoggerFactory;
+-import org.springframework.beans.factory.annotation.Autowired;
+-import org.springframework.security.core.context.SecurityContextHolder;
+-import org.springframework.stereotype.Component;
+-
+-import javax.servlet.http.HttpServletResponse;
+-import javax.ws.rs.core.*;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-import java.io.IOException;
+-import java.util.*;
+-
+-/**
+- * Handler for catching API access denied exceptions that log security events.
+- *
+- * @author bsuzuki
+- */
+-@Provider
+-@Component
+-public class APIAccessDeniedExceptionHandler implements ExceptionMapper<APIAccessDeniedException> {
+-
+-    private static final Logger LOG = LoggerFactory.getLogger(APIAccessDeniedExceptionHandler.class);
+-
+-    @Autowired
+-    private SecurityEventBuilder securityEventBuilder;
+-
+-    @Autowired
+-    private AuditLogger auditLogger;
+-
+-    @Context
+-    UriInfo uriInfo;
+-
+-    @Context
+-    private HttpHeaders headers;
+-
+-    @Context
+-    private HttpServletResponse response;
+-
+-    @Override
+-    public Response toResponse(APIAccessDeniedException e) {
+-        //There are a few jax-rs resources that generate HTML content, and we want the
+-        //default web-container error handler pages to get used in those cases.
+-        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
+-            try {
+-                response.sendError(403, e.getMessage());
+-                logSecurityEvent(e);
+-                return null;    //the error page handles the response, so no need to return a response
+-            } catch (IOException ex) {
+-                LOG.error("Error displaying error page", ex);
+-            }
+-        }
+-
+-        Response.Status errorStatus = Response.Status.FORBIDDEN;
+-        SLIPrincipal principal = null ;
+-        if (SecurityContextHolder.getContext().getAuthentication() != null) {
+-            principal = (SLIPrincipal)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
+-            LOG.warn("Access has been denied to user: {}",principal );
+-        } else {
+-            LOG.warn("Access has been denied to user for being incorrectly associated");
+-        }
+-        LOG.warn("Cause: {}", e.getMessage());
+-
+-        logSecurityEvent(e);
+-
+-        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
+-        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
+-            errorType = MediaType.APPLICATION_XML_TYPE;
+-        }
+-        
+-        return Response.status(errorStatus).entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), "Access DENIED: " + e.getMessage())).type(errorType).build();
+-    }
+-
+-    private void logSecurityEvent(APIAccessDeniedException e) {
+-
+-        if (e.getTargetEdOrgIds() != null) {
+-            // if we already have the target edOrgs - good to go
+-            auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+-                    + e.getMessage(), e.getRealm(), EntityNames.EDUCATION_ORGANIZATION, e.getTargetEdOrgIds().toArray(new String[0])));
+-
+-        } else if (e.getEntityType() != null) {
+-
+-            if (e.getEntities() != null && !e.getEntities().isEmpty()) {
+-                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+-                        + e.getMessage(), e.getRealm(), e.getEntityType(), e.getEntities()));
+-
+-            } else if (e.getEntityIds() != null && !e.getEntityIds().isEmpty()) {
+-                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+-                        + e.getMessage(), e.getRealm(), e.getEntityType(), e.getEntityIds().toArray(new String[0])));
+-            } else {
+-                auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+-                        + e.getMessage(), e.getPrincipal(), e.getClientId(), e.getRealm(), null, e.isTargetIsUserEdOrg()));
+-            }
+-        } else {
+-            auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(e), uriInfo.getRequestUri(), "Access Denied:"
+-                    + e.getMessage(), e.getPrincipal(), e.getClientId(), e.getRealm(), null, e.isTargetIsUserEdOrg()));
+-        }
+-    }
+-
+-    private String getThrowingClassName(Exception e) {
+-        if (e != null && e.getStackTrace() != null) {
+-            StackTraceElement ste = e.getStackTrace()[0];
+-            if (ste != null) {
+-                return ste.getClassName();
+-            }
+-        }
+-        return null;
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/AccessDeniedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/AccessDeniedExceptionHandler.java
+deleted file mode 100644
+index bdd22b6..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/AccessDeniedExceptionHandler.java
++++ /dev/null
+@@ -1,106 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import java.io.IOException;
+-import java.util.ArrayList;
+-import java.util.Arrays;
+-import java.util.HashSet;
+-import java.util.Set;
+-
+-import javax.servlet.http.HttpServletResponse;
+-import javax.ws.rs.core.Context;
+-import javax.ws.rs.core.HttpHeaders;
+-import javax.ws.rs.core.MediaType;
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.core.UriInfo;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.slf4j.Logger;
+-import org.slf4j.LoggerFactory;
+-import org.springframework.beans.factory.annotation.Autowired;
+-import org.springframework.security.access.AccessDeniedException;
+-import org.springframework.security.core.context.SecurityContextHolder;
+-import org.springframework.stereotype.Component;
+-
+-import org.slc.sli.api.resources.security.RealmResource;
+-import org.slc.sli.api.security.SLIPrincipal;
+-import org.slc.sli.api.security.SecurityEventBuilder;
+-
+-/**
+- * Handler for catching access denied exceptions.
+- *
+- * @author shalka
+- */
+-@Provider
+-@Component
+-public class AccessDeniedExceptionHandler implements ExceptionMapper<AccessDeniedException> {
+-
+-    private static final Logger LOG = LoggerFactory.getLogger(AccessDeniedExceptionHandler.class);
+-
+-    public static final String ED_ORG_START = "<" ;
+-    public static final String ED_ORG_END = ">" ;
+-    public static final String NO_EDORG = "UNAVAILABLE";
+-
+-    @Autowired
+-    private SecurityEventBuilder securityEventBuilder;
+-
+-    @Context
+-    UriInfo uriInfo;
+-
+-    @Context
+-    private HttpHeaders headers;
+-
+-    @Context
+-    private HttpServletResponse response;
+-
+-    @Override
+-    public Response toResponse(AccessDeniedException e) {
+-
+-        //There are a few jax-rs resources that generate HTML content, and we want the
+-        //default web-container error handler pages to get used in those cases.
+-        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
+-            try {
+-                response.sendError(403, e.getMessage());
+-                return null;    //the error page handles the response, so no need to return a response
+-            } catch (IOException ex) {
+-                LOG.error("Error displaying error page", ex);
+-            }
+-        }
+-
+-        Response.Status errorStatus = Response.Status.FORBIDDEN;
+-        SLIPrincipal principal = null ;
+-        String message = e.getMessage();
+-        if (SecurityContextHolder.getContext().getAuthentication() != null) {
+-            principal = (SLIPrincipal)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
+-            LOG.warn("Access has been denied to user: {}",principal );
+-        } else {
+-            LOG.warn("Access has been denied to user for being incorrectly associated");
+-        }
+-        LOG.warn("Cause: {}", e.getMessage());
+-
+-        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
+-        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
+-            errorType = MediaType.APPLICATION_XML_TYPE;
+-        }
+-        
+-        return Response.status(errorStatus).entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), "Access DENIED: " + e.getMessage())).type(errorType).build();
+-    }
+-
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/ContextInferrenceFailedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/ContextInferrenceFailedExceptionHandler.java
+deleted file mode 100644
+index c9870ad..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/ContextInferrenceFailedExceptionHandler.java
++++ /dev/null
+@@ -1,71 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package org.slc.sli.api.representation;
+-
+-import java.util.Collections;
+-
+-import javax.ws.rs.core.Context;
+-import javax.ws.rs.core.HttpHeaders;
+-import javax.ws.rs.core.MediaType;
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.core.Response.Status;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-import javax.xml.bind.annotation.XmlRootElement;
+-
+-import org.slc.sli.api.security.pdp.ContextInferrenceFailedException;
+-import org.slf4j.Logger;
+-import org.slf4j.LoggerFactory;
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * Handles empty contexts
+- * 
+- * @author dkornishev
+- * 
+- */
+-@Provider
+-@Component
+-public class ContextInferrenceFailedExceptionHandler implements ExceptionMapper<ContextInferrenceFailedException> {
+-
+-    private static final Logger LOG = LoggerFactory.getLogger(ContextInferrenceFailedExceptionHandler.class);
+-
+-    @Context
+-    private HttpHeaders headers;
+-    
+-    @Override
+-    public Response toResponse(ContextInferrenceFailedException exception) {
+-        LOG.warn("Failed Context Inferrence");
+-        Object entity = Collections.EMPTY_LIST;
+-        if (headers.getAcceptableMediaTypes().contains(MediaType.APPLICATION_XML_TYPE)) {
+-            entity = new EmptyResponse();
+-        }
+-        
+-        return Response.status(Status.NOT_FOUND).entity(entity).header("TotalCount", 0).build();
+-    }
+-    
+-    /**
+-     * Represents an empty document to be returned to the API user (no fields, no data).
+-     * 
+-     * 
+-     * @author kmyers
+-     *
+-     */
+-    @XmlRootElement(name = "emptyList")
+-    public static class EmptyResponse {
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/EOFExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/EOFExceptionHandler.java
+deleted file mode 100644
+index 08d53c6..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/EOFExceptionHandler.java
++++ /dev/null
+@@ -1,43 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package org.slc.sli.api.representation;
+-
+-import java.io.EOFException;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * Exception handler to catch cases where an EOF exception is thrown. This can be the case if a user
+- * tries to post a null body
+- *
+- * @author nbrown
+- *
+- */
+-@Provider
+-@Component
+-public class EOFExceptionHandler implements ExceptionMapper<EOFException> {
+-
+-    @Override
+-    public Response toResponse(EOFException exception) {
+-        return Response.status(Response.Status.BAD_REQUEST).build();
+-    }
+-
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/EmbeddedDocumentLimitExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/EmbeddedDocumentLimitExceptionHandler.java
+deleted file mode 100644
+index 70226ff..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/EmbeddedDocumentLimitExceptionHandler.java
++++ /dev/null
+@@ -1,41 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.slc.sli.api.selectors.doc.EmbeddedDocumentLimitException;
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * @author jstokes
+- */
+-@Provider
+-@Component
+-public class EmbeddedDocumentLimitExceptionHandler implements ExceptionMapper<EmbeddedDocumentLimitException> {
+-
+-    @Override
+-    public Response toResponse(EmbeddedDocumentLimitException e) {
+-        return Response
+-                .status(CustomStatus.ENTITY_TOO_LARGE)
+-                .entity(new ErrorResponse(CustomStatus.ENTITY_TOO_LARGE.getStatusCode(), CustomStatus.ENTITY_TOO_LARGE.getReasonPhrase(),
+-                        e.getMessage())).build();
+-    }
+-}
+-
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/EntityNotFoundHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/EntityNotFoundHandler.java
+deleted file mode 100644
+index e75f6d0..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/EntityNotFoundHandler.java
++++ /dev/null
+@@ -1,42 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.springframework.stereotype.Component;
+-
+-import org.slc.sli.api.service.EntityNotFoundException;
+-
+-/**
+- * Hander for entity not found errors
+- */
+-@Provider
+-@Component
+-public class EntityNotFoundHandler implements ExceptionMapper<EntityNotFoundException> {
+-
+-    public Response toResponse(EntityNotFoundException e) {
+-        Response.Status errorStatus = Response.Status.NOT_FOUND;
+-        return Response
+-                .status(errorStatus)
+-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+-                        "Entity not found: " + e.getId())).build();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/GenericExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/GenericExceptionHandler.java
+deleted file mode 100644
+index f0d4f30..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/GenericExceptionHandler.java
++++ /dev/null
+@@ -1,71 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import java.io.IOException;
+-
+-import javax.servlet.http.HttpServletResponse;
+-import javax.ws.rs.core.Context;
+-import javax.ws.rs.core.HttpHeaders;
+-import javax.ws.rs.core.MediaType;
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.slf4j.Logger;
+-import org.slf4j.LoggerFactory;
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * Hander for uncaught errors
+- */
+-@Provider
+-@Component
+-public class GenericExceptionHandler implements ExceptionMapper<Throwable> {
+-
+-    private static final Logger LOG = LoggerFactory.getLogger(GenericExceptionHandler.class);
+-    
+-    @Context
+-    private HttpHeaders headers;
+-    
+-    @Context
+-    private HttpServletResponse response;
+-
+-    @Override
+-    public Response toResponse(Throwable e) {
+-
+-        //There are a few jax-rs resources that generate HTML content, and we want the
+-        //default web-container error handler pages to get used in those cases.
+-        if (headers.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE)) {
+-            try {
+-                LOG.error(e.getMessage(), e);
+-                response.sendError(500, e.getMessage());
+-                return null;    //the error page handles the response, so no need to return a response
+-            } catch (IOException ex) {
+-                LOG.error("Error displaying error page", ex);
+-            }
+-        }
+-        Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;
+-        
+-        LOG.error("Caught exception thrown by ReST handler", e);
+-        return Response
+-                .status(errorStatus)
+-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+-                        "Internal Server Error: " + e.getMessage())).build();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/IllegalArgumentExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/IllegalArgumentExceptionHandler.java
+deleted file mode 100644
+index d19651e..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/IllegalArgumentExceptionHandler.java
++++ /dev/null
+@@ -1,38 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.core.Response.Status;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * Handles bad requests
+-  */
+-@Provider
+-@Component
+-public class IllegalArgumentExceptionHandler implements ExceptionMapper<IllegalArgumentException> {
+-
+-    @Override
+-    public Response toResponse(IllegalArgumentException e) {
+-        return Response.status(Status.BAD_REQUEST).entity(e.getMessage()).build();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/InsufficientAuthenticationHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/InsufficientAuthenticationHandler.java
+deleted file mode 100644
+index 6ad4696..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/InsufficientAuthenticationHandler.java
++++ /dev/null
+@@ -1,104 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.*;
+-import javax.ws.rs.core.Response.Status;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.slc.sli.api.security.SecurityEventBuilder;
+-import org.slc.sli.api.security.oauth.OAuthAccessException;
+-import org.slc.sli.api.security.service.AuditLogger;
+-import org.springframework.beans.factory.annotation.Autowired;
+-import org.springframework.beans.factory.annotation.Value;
+-import org.springframework.security.authentication.InsufficientAuthenticationException;
+-import org.springframework.stereotype.Component;
+-
+-import java.net.URI;
+-
+-/**
+- * Translates InsufficientAuthenticationException to 401
+- *
+- * @author dkornishev
+- *
+- */
+-@Component
+-@Provider
+-public class InsufficientAuthenticationHandler implements ExceptionMapper<InsufficientAuthenticationException> {
+-
+-    @Value("${sli.security.noSession.landing.url}")
+-    private String authUrl;
+-
+-    @Autowired
+-    private SecurityEventBuilder securityEventBuilder;
+-
+-    @Autowired
+-    private AuditLogger auditLogger;
+-
+-    @Context
+-    UriInfo uriInfo;
+-
+-    @Context
+-    private HttpHeaders headers;
+-
+-    @Override
+-    public Response toResponse(InsufficientAuthenticationException exception) {
+-        Status status = Response.Status.UNAUTHORIZED;
+-        String wwwAuthHeader = this.authUrl;
+-        URI requestUri = (uriInfo == null) ? null : uriInfo.getRequestUri();
+-
+-        //If we have an embedded OAuth exception, then put the error information in the www-auth header per oauth spec 
+-        //http://tools.ietf.org/html/rfc6750 see sec 3
+-        //Otherwise put the auth url in the header
+-        if (exception.getCause() != null && exception.getCause() instanceof OAuthAccessException) {
+-            OAuthAccessException oauthEx = (OAuthAccessException) exception.getCause();
+-            wwwAuthHeader = "Bearer error=\"" + oauthEx.getType().toString() + "\", error_description=\"" + oauthEx.getMessage() + "\"";
+-        }
+-        
+-        MediaType errorType = MediaType.APPLICATION_JSON_TYPE;
+-        if(this.headers.getMediaType() == MediaType.APPLICATION_XML_TYPE) {
+-            errorType = MediaType.APPLICATION_XML_TYPE;
+-        }
+-
+-        auditLogger.audit(securityEventBuilder.createSecurityEvent(getThrowingClassName(exception), requestUri, "Access Denied: "
+-                + exception.getMessage(), false));
+-
+-        return Response.status(status).entity(new ErrorResponse(status.getStatusCode(), status.getReasonPhrase(),
+-                "Access DENIED: " + exception.getMessage())).header(HttpHeaders.WWW_AUTHENTICATE, wwwAuthHeader).type(errorType).build();
+-    }
+-
+-    private String getThrowingClassName(Exception e) {
+-        if (e != null && e.getStackTrace() != null) {
+-            StackTraceElement ste = e.getStackTrace()[0];
+-            if (ste != null) {
+-                return ste.getClassName();
+-            }
+-        }
+-        return null;
+-    }
+-
+-    public void setSecurityEventBuilder(SecurityEventBuilder securityEventBuilder) {
+-        this.securityEventBuilder = securityEventBuilder;
+-    }
+-
+-    public void setAuditLogger(AuditLogger auditLogger) {
+-        this.auditLogger = auditLogger;
+-    }
+-
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/JsonParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/JsonParseExceptionHandler.java
+deleted file mode 100644
+index 39de01c..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/JsonParseExceptionHandler.java
++++ /dev/null
+@@ -1,45 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.codehaus.jackson.JsonParseException;
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * Exception handler for SortingExceptions
+- * 
+- * @author Ryan Farris <rfarris@wgen.net>
+- * 
+- */
+-@Provider
+-@Component
+-public class JsonParseExceptionHandler implements ExceptionMapper<JsonParseException> {
+-    
+-    @Override
+-    public Response toResponse(JsonParseException e) {
+-        Response.Status errorStatus = Response.Status.BAD_REQUEST;
+-        return Response.status(errorStatus)
+-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), e.getMessage()))
+-                .build();
+-    }
+-    
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/MethodNotAllowedExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/MethodNotAllowedExceptionHandler.java
+deleted file mode 100644
+index efa954b..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/MethodNotAllowedExceptionHandler.java
++++ /dev/null
+@@ -1,48 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package org.slc.sli.api.representation;
+-
+-import org.slc.sli.api.resources.generic.MethodNotAllowedException;
+-import org.springframework.stereotype.Component;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-/**
+- * Exception mapper for dis allowed methods
+- *
+- * @author srupasinghe
+- */
+-
+-@Provider
+-@Component
+-public class MethodNotAllowedExceptionHandler implements ExceptionMapper<MethodNotAllowedException> {
+-
+-    public Response toResponse(MethodNotAllowedException e) {
+-        String message = "Method Not Allowed [" + e.getAllowedMethods() + "]";
+-
+-        Response.ResponseBuilder builder =  Response
+-                .status(405)
+-                .entity(new ErrorResponse(405, "Method Not Allowed",
+-                        message));
+-
+-        builder.header("Allow", "Allow: " + e.getAllowedMethods());
+-
+-        return builder.build();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/NaturalKeyValidationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/NaturalKeyValidationExceptionHandler.java
+deleted file mode 100644
+index 09afc94..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/NaturalKeyValidationExceptionHandler.java
++++ /dev/null
+@@ -1,43 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package org.slc.sli.api.representation;
+-
+-import org.apache.commons.lang3.StringUtils;
+-import org.slc.sli.validation.NaturalKeyValidationException;
+-import org.springframework.stereotype.Component;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-/**
+- * Exception mapper NaturalKeyValidationExceptions
+- *
+- * @author srupasinghe
+- */
+-@Provider
+-@Component
+-public class NaturalKeyValidationExceptionHandler implements ExceptionMapper<NaturalKeyValidationException> {
+-
+-    public Response toResponse(NaturalKeyValidationException e) {
+-        String exceptionMessage = "Natural Key Validation failed: " + e.getEntityType() + " " + StringUtils.join(e.getNaturalKeys());
+-        return Response
+-                .status(Response.Status.CONFLICT)
+-                .entity(new ErrorResponse(Response.Status.CONFLICT.getStatusCode(), Response.Status.CONFLICT.getReasonPhrase(),
+-                        exceptionMessage)).build();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/OAuthAccessExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/OAuthAccessExceptionHandler.java
+deleted file mode 100644
+index ac8836c..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/OAuthAccessExceptionHandler.java
++++ /dev/null
+@@ -1,66 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import java.util.HashMap;
+-import java.util.Map;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.springframework.stereotype.Component;
+-import org.springframework.stereotype.Repository;
+-
+-import org.slc.sli.api.security.oauth.OAuthAccessException;
+-import org.slc.sli.api.security.oauth.OAuthAccessException.OAuthError;
+-
+-/**
+- *
+- * Handle oauth access exceptions as described in 5.2
+- */
+-@Component
+-@Provider
+-@Repository
+-public class OAuthAccessExceptionHandler implements ExceptionMapper<OAuthAccessException>  {
+-
+-
+-    @SuppressWarnings("unchecked")
+-    @Override
+-    public Response toResponse(OAuthAccessException ex) {
+-
+-        Response.Status errorStatus = null;
+-
+-        if (ex.getType() == OAuthError.UNAUTHORIZED_CLIENT) {
+-            errorStatus = Response.Status.FORBIDDEN;
+-        } else {
+-            errorStatus = Response.Status.BAD_REQUEST;
+-        }
+-
+-        @SuppressWarnings("rawtypes")
+-        Map data = new HashMap();
+-        data.put("error", ex.getType().toString());
+-        data.put("error_description", ex.getMessage());
+-        if (ex.getState() != null) {
+-            data.put("state", ex.getState());
+-        }
+-        return Response.status(errorStatus).entity(data).build();
+-
+-    }
+-
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/PreConditionExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/PreConditionExceptionHandler.java
+deleted file mode 100644
+index 56aaaad..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/PreConditionExceptionHandler.java
++++ /dev/null
+@@ -1,44 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package org.slc.sli.api.representation;
+-
+-import org.slc.sli.api.resources.generic.PreConditionFailedException;
+-import org.springframework.stereotype.Component;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-/**
+- * Exception mapper for precondition failures
+- *
+- * @author srupasinghe
+- */
+-
+-@Provider
+-@Component
+-public class PreConditionExceptionHandler implements ExceptionMapper<PreConditionFailedException> {
+-
+-    public Response toResponse(PreConditionFailedException e) {
+-
+-        return Response
+-                .status(Response.Status.PRECONDITION_FAILED)
+-                .entity(new ErrorResponse(Response.Status.PRECONDITION_FAILED.getStatusCode(), Response.Status.PRECONDITION_FAILED.getReasonPhrase(),
+-                        e.getMessage())).build();
+-
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/QueryParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/QueryParseExceptionHandler.java
+deleted file mode 100644
+index ab9459c..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/QueryParseExceptionHandler.java
++++ /dev/null
+@@ -1,42 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.springframework.stereotype.Component;
+-
+-import org.slc.sli.domain.QueryParseException;
+-
+-/**
+- * Handler for Query Parsing errors
+- */
+-@Provider
+-@Component
+-public class QueryParseExceptionHandler implements ExceptionMapper<QueryParseException> {
+-    
+-    public Response toResponse(QueryParseException e) {
+-        Response.Status errorStatus = Response.Status.BAD_REQUEST;
+-        return Response
+-                .status(errorStatus)
+-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+-                        "Error Parsing the Query: " + e.getMessage())).build();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/ResponseTooLargeExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/ResponseTooLargeExceptionHandler.java
+deleted file mode 100644
+index fac3013..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/ResponseTooLargeExceptionHandler.java
++++ /dev/null
+@@ -1,41 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.slc.sli.api.security.context.ResponseTooLargeException;
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * Hander for when the request is too large to manage
+- */
+-@Provider
+-@Component
+-public class ResponseTooLargeExceptionHandler implements ExceptionMapper<ResponseTooLargeException> {
+-    
+-    @Override
+-    public Response toResponse(ResponseTooLargeException exception) {
+-        
+-        return Response
+-                .status(CustomStatus.ENTITY_TOO_LARGE)
+-                .entity(new ErrorResponse(CustomStatus.ENTITY_TOO_LARGE.getStatusCode(), CustomStatus.ENTITY_TOO_LARGE.getReasonPhrase(),
+-                        "The request is too large to resolve.")).build();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/SelectorParseExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/SelectorParseExceptionHandler.java
+deleted file mode 100644
+index 45cb7fa..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/SelectorParseExceptionHandler.java
++++ /dev/null
+@@ -1,41 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-package org.slc.sli.api.representation;
+-
+-import org.slc.sli.api.selectors.model.SelectorParseException;
+-import org.springframework.stereotype.Component;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.core.Response.Status;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-/**
+- * @author jstokes
+- */
+-@Provider
+-@Component
+-public class SelectorParseExceptionHandler implements ExceptionMapper<SelectorParseException> {
+-
+-    public Response toResponse(SelectorParseException e) {
+-        return Response
+-                .status(Response.Status.BAD_REQUEST)
+-                .entity(new ErrorResponse(Status.BAD_REQUEST.getStatusCode(), Status.BAD_REQUEST.getReasonPhrase(),
+-                        e.getMessage())).build();
+-    }
+-}
+-
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/SortingExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/SortingExceptionHandler.java
+deleted file mode 100644
+index 7fb9abb..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/SortingExceptionHandler.java
++++ /dev/null
+@@ -1,46 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.springframework.stereotype.Component;
+-
+-import org.slc.sli.api.service.query.SortingException;
+-
+-/**
+- * Exception handler for SortingExceptions
+- * 
+- * @author Ryan Farris <rfarris@wgen.net>
+- * 
+- */
+-@Provider
+-@Component
+-public class SortingExceptionHandler implements ExceptionMapper<SortingException> {
+-    
+-    @Override
+-    public Response toResponse(SortingException e) {
+-        Response.Status errorStatus = Response.Status.BAD_REQUEST;
+-        return Response.status(errorStatus)
+-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(), e.getMessage()))
+-                .build();
+-    }
+-    
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/UncategorizedMongoExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/UncategorizedMongoExceptionHandler.java
+deleted file mode 100644
+index 4c39d62..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/UncategorizedMongoExceptionHandler.java
++++ /dev/null
+@@ -1,50 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.core.Response.Status;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.slf4j.Logger;
+-import org.slf4j.LoggerFactory;
+-import org.springframework.data.mongodb.UncategorizedMongoDbException;
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * Handle connection issues to mongo
+- *
+- * @author nbrown
+- *
+- */
+-@Provider
+-@Component
+-public class UncategorizedMongoExceptionHandler implements ExceptionMapper<UncategorizedMongoDbException> {
+-
+-    private static final Logger LOG = LoggerFactory.getLogger(UncategorizedMongoExceptionHandler.class);
+-
+-    @Override
+-    public Response toResponse(UncategorizedMongoDbException exception) {
+-        Status errorStatus = Status.SERVICE_UNAVAILABLE;
+-        LOG.error("Could not access database", exception);
+-        return Response
+-                .status(errorStatus)
+-                .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+-                        "Could not access database:" + exception.getMessage())).build();
+-    }
+-
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/ValidationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/ValidationExceptionHandler.java
+deleted file mode 100644
+index 4120377..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/ValidationExceptionHandler.java
++++ /dev/null
+@@ -1,44 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.core.Response.Status;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.apache.commons.lang3.StringUtils;
+-import org.springframework.stereotype.Component;
+-
+-import org.slc.sli.validation.EntityValidationException;
+-
+-/**
+- * Hander for validation errors
+- */
+-@Provider
+-@Component
+-public class ValidationExceptionHandler implements ExceptionMapper<EntityValidationException> {
+-
+-    public Response toResponse(EntityValidationException e) {
+-        String exceptionMessage = "Validation failed: " + StringUtils.join(e.getValidationErrors(), "\n");
+-        return Response
+-                .status(Response.Status.BAD_REQUEST)
+-                .entity(new ErrorResponse(Status.BAD_REQUEST.getStatusCode(), Status.BAD_REQUEST.getReasonPhrase(),
+-                        exceptionMessage)).build();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/representation/WebApplicationExceptionHandler.java b/sli/api/src/main/java/org/slc/sli/api/representation/WebApplicationExceptionHandler.java
+deleted file mode 100644
+index bfb6b24..0000000
+--- a/sli/api/src/main/java/org/slc/sli/api/representation/WebApplicationExceptionHandler.java
++++ /dev/null
+@@ -1,51 +0,0 @@
+-/*
+- * Copyright 2012-2013 inBloom, Inc. and its affiliates.
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- * http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-
+-package org.slc.sli.api.representation;
+-
+-import javax.ws.rs.WebApplicationException;
+-import javax.ws.rs.core.Response;
+-import javax.ws.rs.ext.ExceptionMapper;
+-import javax.ws.rs.ext.Provider;
+-
+-import org.slf4j.Logger;
+-import org.slf4j.LoggerFactory;
+-import org.springframework.stereotype.Component;
+-
+-/**
+- * Hander for jax-rs web application exceptions
+- */
+-@Provider
+-@Component
+-public class WebApplicationExceptionHandler implements ExceptionMapper<WebApplicationException> {
+-
+-    public static final Logger LOG = LoggerFactory.getLogger(WebApplicationExceptionHandler.class);
+-    
+-    @Override
+-    public Response toResponse(WebApplicationException e) {
+-        if (e.getResponse().getStatus() == 500) {
+-            LOG.error("Caught exception thrown by ReST handler", e);
+-            Response.Status errorStatus = Response.Status.INTERNAL_SERVER_ERROR;
+-            
+-            return Response
+-                    .status(errorStatus)
+-                    .entity(new ErrorResponse(errorStatus.getStatusCode(), errorStatus.getReasonPhrase(),
+-                            "Internal Server Error: " + e.getMessage())).build();
+-        }
+-        return e.getResponse();
+-    }
+-}
+diff --git a/sli/api/src/main/java/org/slc/sli/api/resources/security/AdminDelegationResource.java b/sli/api/src/main/java/org/slc/sli/api/resources/security/AdminDelegationResource.java
+index 2edc43f..516f40c 100644
+--- a/sli/api/src/main/java/org/slc/sli/api/resources/security/AdminDelegationResource.java
++++ b/sli/api/src/main/java/org/slc/sli/api/resources/security/AdminDelegationResource.java
+@@ -23,8 +23,8 @@ import org.slc.sli.api.representation.EntityBody;
+ import org.slc.sli.api.resources.v1.HypermediaType;
+ import org.slc.sli.api.security.RightsAllowed;
+ import org.slc.sli.api.security.SecurityEventBuilder;
++import org.slc.sli.api.security.context.APIAccessDeniedException;
+ import org.slc.sli.api.security.service.AuditLogger;
+-import org.slc.sli.api.service.EntityNotFoundException;
+ import org.slc.sli.api.service.EntityService;
+ import org.slc.sli.api.util.SecurityUtil;
+ import org.slc.sli.common.util.logging.SecurityEvent;
+@@ -108,7 +108,7 @@ public class AdminDelegationResource {
+ 
+             String edOrg = SecurityUtil.getEdOrg();
+             if (edOrg == null) {
+-                throw new EntityNotFoundException("No edorg exists on principal.");
++                throw new APIAccessDeniedException("Can not grant access because no edOrg exists on principal.");
+             }
+ 
+             List<Map<String, Object>> results = new ArrayList<Map<String, Object>>();
+@@ -205,14 +205,14 @@ public class AdminDelegationResource {
+     private EntityBody getDelegationRecordForPrincipal() {
+         String edOrgId = SecurityUtil.getEdOrgId();
+         if (edOrgId == null) {
+-            throw new EntityNotFoundException("No edorg exists on principal.");
++            throw new APIAccessDeniedException("Can not grant access because no edOrg exists on principal.");
+         }
+ 
+         NeutralQuery query = new NeutralQuery();
+         query.addCriteria(new NeutralCriteria(LEA_ID, "=", edOrgId));
+         Iterator<EntityBody> it = service.list(query).iterator();
+         //Iterator<String> it = service.listIds(query).iterator();
+-        if (it.hasNext()){
++        if (it.hasNext()) {
+             return it.next();
+         } else {
+             return null;
+diff --git a/sli/api/src/main/java/org/slc/sli/api/resources/security/RealmResource.java b/sli/api/src/main/java/org/slc/sli/api/resources/security/RealmResource.java
+index 7b606b4..fc357e7 100644
+--- a/sli/api/src/main/java/org/slc/sli/api/resources/security/RealmResource.java
++++ b/sli/api/src/main/java/org/slc/sli/api/resources/security/RealmResource.java
+@@ -136,7 +136,7 @@ public class RealmResource {
+             @Context final UriInfo uriInfo) {
+ 
+         if (updatedRealm == null) {
+-            throw new EntityNotFoundException("Entity was null");
++            throw new IllegalArgumentException("Updated Realm was null");
+         }
+ 
+         EntityBody oldRealm = service.get(realmId);
+diff --git a/sli/api/src/main/java/org/slc/sli/api/search/service/SearchResourceService.java b/sli/api/src/main/java/org/slc/sli/api/search/service/SearchResourceService.java
+index 78261fa..cd3ed53 100644
+--- a/sli/api/src/main/java/org/slc/sli/api/search/service/SearchResourceService.java
++++ b/sli/api/src/main/java/org/slc/sli/api/search/service/SearchResourceService.java
+@@ -43,6 +43,7 @@ import org.elasticsearch.common.settings.ImmutableSettings;
+ import org.elasticsearch.common.settings.Settings;
+ import org.elasticsearch.node.Node;
+ import org.elasticsearch.node.NodeBuilder;
++import org.slc.sli.api.exceptions.EntityTypeNotFoundException;
+ import org.slf4j.Logger;
+ import org.slf4j.LoggerFactory;
+ import org.springframework.beans.factory.annotation.Autowired;
+@@ -68,7 +69,6 @@ import org.slc.sli.api.security.SLIPrincipal;
+ import org.slc.sli.api.security.context.ContextValidator;
+ import org.slc.sli.api.security.context.resolver.EdOrgHelper;
+ import org.slc.sli.api.security.context.validator.IContextValidator;
+-import org.slc.sli.api.service.EntityNotFoundException;
+ import org.slc.sli.api.service.EntityService;
+ import org.slc.sli.api.service.query.ApiQuery;
+ import org.slc.sli.common.constants.EntityNames;
+@@ -393,7 +393,7 @@ public class SearchResourceService {
+       for (String resourceName : resourceNames.split(",")) {
+          def = resourceHelper.getEntityDefinition(resourceName);
+          if (def == null || !searchEntityDefinition.getService().collectionExists(def.getType())) {
+-            throw new EntityNotFoundException(resourceName);
++            throw new EntityTypeNotFoundException(resourceName);
+          }
+          entityTypes.add(def.getType());
+       }
+diff --git a/sli/api/src/main/java/org/slc/sli/api/security/context/ContextValidator.java b/sli/api/src/main/java/org/slc/sli/api/security/context/ContextValidator.java
+index c546780..843abf2 100644
+--- a/sli/api/src/main/java/org/slc/sli/api/security/context/ContextValidator.java
++++ b/sli/api/src/main/java/org/slc/sli/api/security/context/ContextValidator.java
+@@ -393,36 +393,47 @@ public class ContextValidator implements ApplicationContextAware {
+     */
+     protected Set<String> getEntityIdsToValidate(EntityDefinition def, Collection<Entity> entities, boolean isTransitive, Collection<String> ids)
+                           throws APIAccessDeniedException, EntityNotFoundException {
+-         int found = 0;
+-         Set<String> entityIdsToValidate = new HashSet<String>();
+-            for (Entity ent : entities) {
+-                found++;
+-                Collection<String> userEdOrgs = edOrgHelper.getDirectEdorgs(ent);
+-                if (isOrphanCreatedByUser(ent)) {
+-                    LOG.debug("Entity is orphaned: id {} of type {}", ent.getEntityId(), ent.getType());
+-                } else if (SecurityUtil.getSLIPrincipal().getEntity() != null
++        Set<String> entityIdsToValidate = new HashSet<String>();
++        for (Entity ent : entities) {
++            Collection<String> userEdOrgs = edOrgHelper.getDirectEdorgs(ent);
++            if (isOrphanCreatedByUser(ent)) {
++                LOG.debug("Entity is orphaned: id {} of type {}", ent.getEntityId(), ent.getType());
++            } else if (SecurityUtil.getSLIPrincipal().getEntity() != null
+                         && SecurityUtil.getSLIPrincipal().getEntity().getEntityId().equals(ent.getEntityId())) {
+-                    LOG.debug("Entity is themselves: id {} of type {}", ent.getEntityId(), ent.getType());
++                LOG.debug("Entity is themselves: id {} of type {}", ent.getEntityId(), ent.getType());
++            } else {
++                if (ownership.canAccess(ent, isTransitive)) {
++                    entityIdsToValidate.add(ent.getEntityId());
+                 } else {
+-                    if (ownership.canAccess(ent, isTransitive)) {
+-                        entityIdsToValidate.add(ent.getEntityId());
+-                    } else {
+-                        throw new APIAccessDeniedException("Access to " + ent.getEntityId() + " is not authorized", userEdOrgs);
+-                    }
++                    throw new APIAccessDeniedException("Access to " + ent.getEntityId() + " is not authorized", userEdOrgs);
+                 }
+             }
++        }
+ 
+-            if (found != ids.size()) {
+-                LOG.debug("Invalid reference, an entity does not exist. collection: {} entities: {}",
+-                        def.getStoredCollectionName(), entities);
+-                throw new EntityNotFoundException("Could not locate " + def.getType() + " with ids " + ids);
++        // report an EntityNotFoundException on the id we find without a corresponding entity
++        // so that we don't use the constructor for EntityNotFoundException incorrectly
++        if (entities.size() != ids.size()) {
++            for (String id : ids ) {
++                boolean foundentity = false;
++                for (Entity ent : entities) {
++                    if (ent.getEntityId().contains(id)){
++                    	foundentity = true;
++                    	break;
++                    }
++                }
++                if (!foundentity) {
++                    LOG.debug("Invalid reference, an entity does not exist. collection: {} entities: {}",
++                            def.getStoredCollectionName(), entities);
++                    throw new EntityNotFoundException(id);
++                }
+             }
++        }
+ 
+-         return entityIdsToValidate;
+-       }
++        return entityIdsToValidate;
++    }
+ 
+     /**
+-     * Returns true is the entity is an orphan that is created by the user, false otherwise
++     * Returns true if the entity is an orphan that is created by the user, false otherwise
+      *
+      * @param entity - Collection of entities to filter for validation
+      *
+diff --git a/sli/api/src/main/java/org/slc/sli/api/security/oauth/AuthController.java b/sli/api/src/main/java/org/slc/sli/api/security/oauth/AuthController.java
+index 9dfc519..6ec4b13 100644
+--- a/sli/api/src/main/java/org/slc/sli/api/security/oauth/AuthController.java
++++ b/sli/api/src/main/java/org/slc/sli/api/security/oauth/AuthController.java
+@@ -28,7 +28,7 @@ import javax.ws.rs.core.Response;
+ import org.apache.commons.lang3.tuple.Pair;
+ import org.codehaus.jackson.map.ObjectMapper;
+ import org.slc.sli.api.init.RealmInitializer;
+-import org.slc.sli.api.representation.OAuthAccessExceptionHandler;
++import org.slc.sli.api.jersey.exceptionhandlers.OAuthAccessExceptionHandler;
+ import org.slc.sli.api.security.OauthSessionManager;
+ import org.slc.sli.api.security.saml.SamlHelper;
+ import org.slc.sli.api.util.SecurityUtil;
+diff --git a/sli/api/src/main/java/org/slc/sli/api/security/pdp/UriMutator.java b/sli/api/src/main/java/org/slc/sli/api/security/pdp/UriMutator.java
+index ea70732..412c981 100644
+--- a/sli/api/src/main/java/org/slc/sli/api/security/pdp/UriMutator.java
++++ b/sli/api/src/main/java/org/slc/sli/api/security/pdp/UriMutator.java
+@@ -33,6 +33,7 @@ import javax.ws.rs.core.PathSegment;
+ 
+ import org.apache.commons.lang3.StringUtils;
+ import org.apache.commons.lang3.tuple.Pair;
++import org.slc.sli.api.exceptions.UriMutationException;
+ import org.slc.sli.api.resources.security.ApplicationResource;
+ import org.slc.sli.api.security.RightsAllowed;
+ import org.slc.sli.domain.enums.Right;
+@@ -50,11 +51,9 @@ import org.slc.sli.api.constants.PathConstants;
+ import org.slc.sli.api.constants.ResourceNames;
+ import org.slc.sli.api.security.SLIPrincipal;
+ import org.slc.sli.api.security.context.APIAccessDeniedException;
+-import org.slc.sli.api.security.context.ResponseTooLargeException;
+ import org.slc.sli.api.security.context.resolver.EdOrgHelper;
+ import org.slc.sli.api.security.context.resolver.GradingPeriodHelper;
+ import org.slc.sli.api.security.context.resolver.SectionHelper;
+-import org.slc.sli.api.service.EntityNotFoundException;
+ import org.slc.sli.api.util.SecurityUtil;
+ import org.slc.sli.api.util.SessionUtil;
+ import org.slc.sli.common.constants.EntityNames;
+@@ -370,7 +369,7 @@ public class UriMutator {
+      *         to be rewritten.
+      */
+     private MutatedContainer mutateUriAsNecessary(List<PathSegment> segments, String queryParameters, Entity user)
+-            throws ResponseTooLargeException {
++            throws IllegalArgumentException {
+         MutatedContainer mutatedPathAndParameters = null;
+         if (mutateToTeacher()) {
+             mutatedPathAndParameters = mutateTeacherRequest(segments, queryParameters, user);
+@@ -499,8 +498,7 @@ public class UriMutator {
+                 mutated.setPath(String.format("/schools/%s/teacherSchoolAssociations",
+                         StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
+             } else if (PathConstants.STAFF.equals(baseEntity)) {
+-                mutated.setPath(String.format(
+-                        "/educationOrganizations/%s/staffEducationOrgAssignmentAssociations/staff",
++                mutated.setPath(String.format("/educationOrganizations/%s/staffEducationOrgAssignmentAssociations/staff",
+                         StringUtils.join(edOrgHelper.getDirectEdorgs(user), ",")));
+             } else if (PathConstants.STAFF_COHORT_ASSOCIATIONS.equals(baseEntity)) {
+                 mutated.setPath(String.format("/cohorts/%s/staffCohortAssociations", getCohortIds(principal)));
+@@ -760,17 +758,17 @@ public class UriMutator {
+     }
+ 
+     /**
+-     * Throws Response Too Large exception if there are multiple _id's specified in the transitive
++     * Throws Illegal Argument exception if there are multiple _id's specified in the transitive
+      * _id path segment.
+      *
+      * @param id
+      *            String representing transitive _id path segment.
+-     * @throws ResponseTooLargeException
++     * @throws IllegalArgumentException
+      *             Thrown if multiple _id's are specified (only one should be specified).
+      */
+-    protected void verifySingleTransitiveId(String id) throws ResponseTooLargeException {
++    protected void verifySingleTransitiveId(String id) throws IllegalArgumentException {
+         if (id.split(",").length > 1) {
+-            throw new ResponseTooLargeException();
++            throw new IllegalArgumentException();
+         }
+     }
+ 
+@@ -1242,7 +1240,7 @@ public class UriMutator {
+         }
+ 
+         if (programsIds == null || programsIds.isEmpty()) {
+-            throw new EntityNotFoundException("No association to any programs");
++            throw new UriMutationException("No association to any educational programs");
+         }
+ 
+         return programsIds;
+@@ -1264,7 +1262,7 @@ public class UriMutator {
+         }
+ 
+         if (cohortsIds == null || cohortsIds.isEmpty()) {
+-            throw new EntityNotFoundException("No association to any cohorts");
++            throw new UriMutationException("No association to any cohorts");
+         }
+         return cohortsIds;
+     }
+diff --git a/sli/api/src/main/java/org/slc/sli/api/translator/URITranslator.java b/sli/api/src/main/java/org/slc/sli/api/translator/URITranslator.java
+index 77dbc2b..4475708 100644
+--- a/sli/api/src/main/java/org/slc/sli/api/translator/URITranslator.java
++++ b/sli/api/src/main/java/org/slc/sli/api/translator/URITranslator.java
+@@ -27,6 +27,7 @@ import javax.ws.rs.core.PathSegment;
+ import com.sun.jersey.spi.container.ContainerRequest;
+ 
+ import org.apache.commons.lang3.StringUtils;
++import org.slc.sli.api.exceptions.URITranslationException;
+ import org.slf4j.Logger;
+ import org.slf4j.LoggerFactory;
+ import org.springframework.beans.factory.annotation.Autowired;
+@@ -37,7 +38,6 @@ import org.slc.sli.common.constants.EntityNames;
+ import org.slc.sli.api.constants.PathConstants;
+ import org.slc.sli.api.constants.ResourceNames;
+ import org.slc.sli.api.security.context.PagingRepositoryDelegate;
+-import org.slc.sli.api.service.EntityNotFoundException;
+ import org.slc.sli.domain.Entity;
+ import org.slc.sli.domain.NeutralCriteria;
+ import org.slc.sli.domain.NeutralQuery;
+@@ -242,7 +242,7 @@ public class URITranslator {
+                 }
+                 if (translatedIdList.isEmpty()) {
+                     LOG.warn("Failed upversioning rewrite {} -> {} due not being able to find intermediate entities", requestPath, this.transformTo);
+-                    throw new EntityNotFoundException("Upversioning rewrite failed.  No target entities found.");
++                    throw new URITranslationException("Upversioning rewrite failed.  No target entities found.");
+                 }
+             }
+ 
+diff --git a/sli/api/src/test/java/org/slc/sli/api/representation/InsufficientAuthenticationHandlerTest.java b/sli/api/src/test/java/org/slc/sli/api/representation/InsufficientAuthenticationHandlerTest.java
+index 56eafef..37c0640 100644
+--- a/sli/api/src/test/java/org/slc/sli/api/representation/InsufficientAuthenticationHandlerTest.java
++++ b/sli/api/src/test/java/org/slc/sli/api/representation/InsufficientAuthenticationHandlerTest.java
+@@ -27,10 +27,8 @@ import javax.ws.rs.core.Response;
+ 
+ import org.junit.Test;
+ import org.junit.runner.RunWith;
+-import org.mockito.InjectMocks;
+-import org.mockito.Mock;
+ import org.mockito.Mockito;
+-import org.mockito.stubbing.Answer;
++import org.slc.sli.api.jersey.exceptionhandlers.InsufficientAuthenticationHandler;
+ import org.slc.sli.api.security.SecurityEventBuilder;
+ import org.slc.sli.api.security.service.AuditLogger;
+ import org.slc.sli.api.test.WebContextTestExecutionListener;
+diff --git a/sli/api/src/test/java/org/slc/sli/api/representation/QueryParseExceptionHandlerTest.java b/sli/api/src/test/java/org/slc/sli/api/representation/QueryParseExceptionHandlerTest.java
+index 1bd5dc8..d39c0b4 100644
+--- a/sli/api/src/test/java/org/slc/sli/api/representation/QueryParseExceptionHandlerTest.java
++++ b/sli/api/src/test/java/org/slc/sli/api/representation/QueryParseExceptionHandlerTest.java
+@@ -19,6 +19,7 @@ import static org.junit.Assert.assertFalse;
+ import static org.junit.Assert.assertTrue;
+ 
+ import org.junit.Test;
++import org.slc.sli.api.jersey.exceptionhandlers.QueryParseExceptionHandler;
+ import org.slc.sli.domain.QueryParseException;
+ 
+ import javax.ws.rs.core.Response;
+diff --git a/sli/api/src/test/java/org/slc/sli/api/resources/security/AdminDelegationResourceTest.java b/sli/api/src/test/java/org/slc/sli/api/resources/security/AdminDelegationResourceTest.java
+index f4107ac..1e53c51 100644
+--- a/sli/api/src/test/java/org/slc/sli/api/resources/security/AdminDelegationResourceTest.java
++++ b/sli/api/src/test/java/org/slc/sli/api/resources/security/AdminDelegationResourceTest.java
+@@ -18,19 +18,14 @@
+ package org.slc.sli.api.resources.security;
+ 
+ import javax.ws.rs.core.Response;
+-import javax.ws.rs.core.UriInfo;
+ 
+ import junit.framework.Assert;
+ 
+ import org.junit.Test;
+ import org.junit.runner.RunWith;
+-import org.mockito.Mockito;
+-import org.slc.sli.api.representation.EntityBody;
+ import org.slc.sli.api.resources.SecurityContextInjector;
+-import org.slc.sli.api.resources.util.ResourceTestUtil;
+ import org.slc.sli.api.security.SLIPrincipal;
+-import org.slc.sli.api.security.SecurityEventBuilder;
+-import org.slc.sli.api.service.EntityNotFoundException;
++import org.slc.sli.api.security.context.APIAccessDeniedException;
+ import org.slc.sli.api.test.WebContextTestExecutionListener;
+ import org.springframework.beans.factory.annotation.Autowired;
+ import org.springframework.security.core.context.SecurityContextHolder;
+@@ -58,19 +53,18 @@ public class AdminDelegationResourceTest {
+     @Autowired
+     private SecurityContextInjector securityContextInjector;
+ 
+-    @Test(expected = EntityNotFoundException.class)
++    @Test(expected = APIAccessDeniedException.class)
+     public void testGetDelegationsNoEdOrg() throws Exception {
+ 
+         securityContextInjector.setLeaAdminContext();
+         resource.getDelegations();
+-
+     }
+ 
+     @Test
+     public void testGetDelegationsBadRole() throws Exception {
+ 
+         securityContextInjector.setEducatorContext();
+-        Assert.assertEquals(resource.getDelegations().getStatus(), Response.Status.FORBIDDEN.getStatusCode());
++        Assert.assertEquals(Response.Status.FORBIDDEN.getStatusCode(), resource.getDelegations().getStatus());
+ 
+     }
+ 
+@@ -82,6 +76,6 @@ public class AdminDelegationResourceTest {
+         ((SLIPrincipal) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).setEdOrgId("1234");
+ 
+ 
+-        Assert.assertEquals(resource.getSingleDelegation().getStatus(), Response.Status.NOT_FOUND.getStatusCode());
++        Assert.assertEquals(Response.Status.NOT_FOUND.getStatusCode(), resource.getSingleDelegation().getStatus());
+     }
+ }
+diff --git a/sli/api/src/test/java/org/slc/sli/api/resources/security/RealmResourceTest.java b/sli/api/src/test/java/org/slc/sli/api/resources/security/RealmResourceTest.java
+index 1966135..43cf457 100644
+--- a/sli/api/src/test/java/org/slc/sli/api/resources/security/RealmResourceTest.java
++++ b/sli/api/src/test/java/org/slc/sli/api/resources/security/RealmResourceTest.java
+@@ -45,7 +45,6 @@ import org.springframework.test.context.support.DirtiesContextTestExecutionListe
+ import org.slc.sli.api.representation.EntityBody;
+ import org.slc.sli.api.resources.SecurityContextInjector;
+ import org.slc.sli.api.resources.util.ResourceTestUtil;
+-import org.slc.sli.api.service.EntityNotFoundException;
+ import org.slc.sli.api.service.EntityService;
+ import org.slc.sli.api.test.WebContextTestExecutionListener;
+ 
+@@ -117,7 +116,7 @@ public class RealmResourceTest {
+ 
+             resource.updateRealm("-1", null, null);
+             assertFalse(false);
+-        } catch (EntityNotFoundException e) {
++        } catch (IllegalArgumentException e) {
+             assertTrue(true);
+         }
+         UriInfo uriInfo = ResourceTestUtil.buildMockUriInfo("");
+diff --git a/sli/api/src/test/java/org/slc/sli/api/security/context/ContextValidatorTest.java b/sli/api/src/test/java/org/slc/sli/api/security/context/ContextValidatorTest.java
+index ee4ccd4..db41aae 100644
+--- a/sli/api/src/test/java/org/slc/sli/api/security/context/ContextValidatorTest.java
++++ b/sli/api/src/test/java/org/slc/sli/api/security/context/ContextValidatorTest.java
+@@ -252,14 +252,15 @@ public class ContextValidatorTest {
+         Mockito.when(edOrgHelper.getDirectEdorgs(Mockito.eq(student1))).thenReturn(new HashSet<String>(Arrays.asList("edOrg1")));
+         boolean isTransitive = false;
+         Mockito.when(ownership.canAccess(student1, isTransitive)).thenReturn(true);
+-
+-        Collection<String> ids = new HashSet<String>(Arrays.asList("student1"));
+-
++        
++        String id = "student1";
++        Collection<String> ids = new HashSet<String>(Arrays.asList(id));
++        
+         try {
+             contextValidator.validateContextToEntities(def, ids, isTransitive);
+             Assert.fail();
+         } catch (EntityNotFoundException ex) {
+-            Assert.assertEquals("Could not locate " + def.getType() + " with ids " + ids, ex.getId());
++            Assert.assertEquals(id, ex.getId());
+         }
+     }
+ 
